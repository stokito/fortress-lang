
In this section we describe how to mechanically check 
the three overloading rules from Section~\ref{sec:rules}. The
algorithm we describe does not check every possible valid set of overloaded
functions (according to the rule definitions), but it does accept
many desired overloadings, including all of the (valid) example overloadings
provided so far.
Thus we provide a sound but incomplete algorithm for determining that a
set of overloaded function declarations is valid.


Previously the notions of applicability and specificity for generic
declarations required an existential quantification over instances thereof.
We rephrase these definitions in terms of universal and existential types,
the generalizations of ````arrow type'' and ````domain type'' of generic
declarations, in the same manner as \cite{bourdoncle97}.


For a generic function declaration $d = \hdeclg{f}{\Delta}{S}{T}$,
its arrow type, written $\arrow(d)$, is
the \emph{universal type} \mbox{$\forall\ob{\Delta}S \rightarrow T$}.
A universal type binds type parameter declarations over some type and
can be instantiated by any types fitting the type parameters' bounds.
We write $\forall\tplist{X}{N}T$ to bind each type variable $X_i$ with bounds
$\{\bar{N_i}\}$ over the type $T$, and we use the metavariable $\sigma$ to range over universal types.


Moreover, the domain type of $d$, written $\dom(d)$, is the
\emph{existential type} $\exists\ob{\Delta}{S}$. An \emph{existential type}
also binds type parameter declarations over a type, 
but unlike a universal type, it cannot be instantiated; 
instead, it represents some hidden type instantiation 
and the corresponding instantiated type. We write
$\exists\tplist{X}{N}T$ to bind each type variable $X_i$ with bounds
$\{\bar{N_i}\}$ over the type $T$, and we use the metavariable $\delta$ to
range over existential types.

Note that universal and existential types are not actually \emph{types} in
our system. To distinguish between the different notions, we refer to types
$T$ as \emph{simple types} and the original subtyping relation $\subtypeof$ as
\emph{simple subtyping}. When the meaning is clear from context, we equate
both $\forall\ob{}T$ and $\exists\ob{}T$ with the simple type $T$. 

% \input{fig-application}

%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCE SUBTYPING!
\subsection{Universal and Existential Subtyping}
We define subtyping judgments for universal types and for existential types,
which we utilize in checking the overloading rules. We actually define inner
and outer subtyping judgments on universals and existentials; the former
corresponds to a relatively standard interpretation of each (which
resembles those defined in \cite{bourdoncle97}), while the latter
incorporates \emph{quantifier reduction}, defined in the next section.


\input{fig-existential}

The inner subtyping judgment on universals defined in
Figure~\ref{fig:existential}, 
$\jleinner{\sigma_1}{\sigma_2}$, stems from the notion of ````generic
instances'' from Hindley-Milner type systems \cite{damas82},
augmented with F-bounded quantification \cite{canning89,baldan99} to account
for type parameters that may appear in their bounds. The single rule
states that $\sigma_1$ is a subtype
of $\sigma_2$ if, in the environment extended by $\sigma_2$'s type parameters,
there exists an instantiation $\bar{V}$ of $\sigma_1$ such that the
constituent type of $\sigma_1$ is a (simple) subtype of the constituent type
of $\sigma_2$; in other words, $\sigma_1$ must be instantiated in $\sigma_2$'s
environment to a simple subtype of $\sigma_2$'s type.

The inner subtyping judgment on existentials also defined in
Figure~\ref{fig:existential}, $\jleinner{\delta_1}{\delta_2}$, is the
logical dual of that for universals. The rule states that $\delta_1$ is
a subtype of $\delta_2$ if $\delta_2$'s type parameters can be instantiated
in $\delta_1$'s environment such that its instantiated type is a simple
supertype of $\delta_1$'s type.

The outer subtyping judgments incorporate a single step of \emph{quantifier reduction}.
In the existential subtyping judgment $\jle{\delta}{\delta}$ the l.h.s. is reduced and its result is checked with the r.h.s. using the inner subtyping judgment.
Dually, in the universal subtyping judgment $\jle{\sigma}{\sigma}$ the r.h.s. is reduces and its result is checked with the l.h.s. using the inner subtyping judment. 

We explain how to compute generic reductions in more detail in Section~\ref{sec:exred}, but the behavior of of reduction can be understood almost entirely
using the following lemmas which we state without proof.
\begin{lemma}
Suppose that $\jtred{\delta}{\delta'}$, then $\jleinner{\delta'}{\delta}$.
\end{lemma}
\begin{lemma}
Suppose that $\jtred{\delta}{\delta'}$. If $\jgnequiv{T}{\Bottom}$ then $\jleinner{\exttype[]{T}}{\delta}$ if and only if $\jleinner{\exttype[]{T}}{\delta'}$.
\end{lemma}
\begin{lemma}
Suppose that $\jtred{\sigma}{\sigma'}$ and $\arrowtype{S}{T}$ has $\jgnequiv{S}{\Bottom}$, then $\arrowtype{S}{T}$ is and instance of $\sigma$ if and only if
$\arrowtype{S}{T}$ is an instance of $\sigma'$.
\end{lemma}


The these offer a nice interpretation of applicability and
specificity of generic function declarations. Recall that a generic
function declaration $d = \hdeclg{f}{\Delta}{S}{T}$ is applicable to a type
$T$ if there is some instance $d'$ such that $T \le \dom(d')$.
Note the existential quantification over instances of the generic function
declaration. With our extended notion of domain type, we lift this
criterion to the level of existential types; observe the same existential
quantification over type instantiations $\bar{V}$ in the definition of
existential subtyping. We can
interpret the fact that a generic function declaration $d$ is applicable 
to a type $T$ with the existential subtyping assertion $\vdash T \le \dom(d)$. 
Furthermore, we interpret the fact that $d_1$ is more specific than
$d_2$ with the existential subtyping assertion
$\vdash \dom(d_1) \le \dom(d_2)$. These interpretations are clearly correct with respect
to the inner subtyping judgments and our theorems immediately imply that they
are correct with respect to the outer subtyping judments as well.

\input{fig-meet}

\subsection{Mechanically Checking the Rules}
With our interpretations of applicability and specificity into existential
subtyping, we now describe the process of checking the validity of a set of 
overloaded declarations $\Df$ according to the rules in
Section~\ref{sec:rules}.

We can check the No Duplicates Rule by verifying that for every pair of distinct function
declarations $d_1, d_2 \in \Df$ either $d_1 \not \ms d_2$ or $d_1 \not \ms d_2$. 

The Meet Rule requires that every pair of declarations $d_1, d_2 \in \Df$ has a meet in $\Df$. Thus, because
more specific relation on function declarations corresponds to the subtyping relation on existential types, we just
need to compute the meet $\dom(d_1) \wedge \dom(d_2)$ of the existential types $\dom(d_1)$ and $\dom(d_2)$ and search for a declaration
$d_0 \in \Df$ with $dom(d_0) \equiv \dom(d_1) \wedge \dom(d_2)$. Fortunately, computing the meet of two existential types is easily dones (see Figure~\ref{fig:meet}).

\begin{lemma}\label{lem:meet}
$\delta_1 \meet \delta_2$ is actually the meet of $\delta_1$ and $\delta_2$ under $\le$.
\end{lemma}
\begin{proof}
First we will show that $\delta_1 \meet \delta_2$ is the meet of $\delta_1$ and $\delta_2$ under $\leinner$. That $\delta_1 \meet \delta_2 \leinner \delta_1$ and $\delta_1 \meet \delta_2 \leinner \delta_2$ is obvious.
For any $\delta_0$, if $\bar{U}$ and $\bar{V}$ are instantiations that prove
$\delta_0 \leinner \delta_1$ and $\delta_0 \leinner \delta_1$, respectively,
then we can use the instantiation $\bar{U},\bar{V}$ to prove that $\delta_0 \le \delta_1 \meet \delta_2$.

Now we will show that the meet under $\leinner$ is also the meet under $\le$. Suppose that $\delta_0 \le \delta_1$, $\delta_0] \le \delta_1$
and $\delta_0 \eqred \reduce(\delta_0)$. A little work lets us deduce that $\reduce(\delta_0) \leinner \delta_1 \meet \delta_2$ and hence $\delta_0 \le \delta_1 \meet \delta_2$.
The fact that $\delta_1 \meet \delta_2 \le \delta_1$ and $\delta_1 \meet \delta_2 \le \delta_1$ follows from the fact that $\leinner$ implies $\le$.
\end{proof}

We can check the Return Type Rule using the subtype relation on universal types.
\begin{theorem}
Let $d_1 = \hdeclg{f}{\Delta_1}{S_1}{T_1}$ and $d_2 = \hdeclg{f}{\Delta_2}{S_2}{T_2}$ be declarations
in $\Df$ with $d_1 \ms d_2$. They satisfy the return type rule if and only if $\arrow(d_1)$ is a subtype of
the arrow type $\sigma_{\wedge} = \forall\ob{\Delta_1, \Delta_2}(S_1 \cap S_2) \rightarrow T_2$.
\end{theorem}

\begin{proof}
Note that $arrow(d_1)$ and $\sigma_{\wedge}$ are equally specific and that $arrow(d1) \le \sigma_{\wedge}$ implies that for every instance $\arrowtype{U}{V}$ of $\sigma_{\wedge}$ with $U \not \equiv \Bottom$
we can find an instance $\arrowtype{U_1}{V_1}$ of $\arrow(d_1)$ with $U \subtypeof U_1$ and $V_1 \subtypeof V$. Thus the pair $d_1, d_2$ satisfies the return type rule if
the pair $\sigma_{\wedge}, d_2$ does. This is clear because $\sigma_{\wedge}$ can match the return type of any instance of $d_2$ whose domain type is not $\Bottom$.
\end{proof}



