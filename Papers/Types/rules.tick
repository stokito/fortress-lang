%%%%%%%%%%%%%%%%%%%%% BEGIN SUBTYPING %%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[ht]
\begin{center}
  \begin{tabular}{c|c}

  %% MINIPAGE FOR LEFT COLUMN
  \begin{minipage}{.45\textwidth}

    %%% UNIVERSAL SUBTYPING RULE
    \begin{center}
      \fbox{\textbf{Universal subtyping:} \jqsub{\sigma}{\sigma}}
    \end{center}

    \infrule
      {\Delta' = \Delta, \bds{Y}{N}
          \andalso \bar{Y} \cap FV(T) = \emptyset \\
       \jgsub[\Delta']{\substb{V}{X}T}{U} \andalso
           % \forall i\,.\;\jgsub[\Delta']{V_i}{\substb{V}{X}\bd{M_i}}
           \bar{\jgsub[\Delta']{V}{\substb{V}{X}\bar{M}}}
      }
      {\jqsub{\forall\obb{X <: \bd{M}}T}{\forall\obb{Y <: \bd{N}}U}}
    %%% SYNTAX DEF
    \begin{tabularx}{\textwidth}{RcX}
    $\sigma_1 \le \sigma_2$ &
      \syndef &
      $\jqsub[\emptyset]{\sigma_1}{\sigma_2}$ \\
    % $dom(\unitype{\arrowtype{T}{U}})$ &
    %   \syndef &
    %   $\exttype{T}$
    \end{tabularx}

    %%% DOMAIN SUBTYPING RULE
    \begin{center}
      \fbox{\textbf{Existential subtyping:} \jqsub{\delta}{\delta}}
    \end{center}
    \infrule
      {\Delta' = \Delta, \bds{X}{M}
          \andalso \bar{X} \cap FV(U) = \emptyset \\
       \jgsub[\Delta']{T}{\substb{V}{Y}U} \andalso
                % \forall i\,.\;\jgsub[\Delta']{V_i}{\substb{V}{Y}\bd{N_i}}
          \bar{\jgsub[\Delta']{V}{\substb{V}{Y}\bar{N}}}
          }
      {\jqsub{\exists\obb{X <: \bd{M}}T}{\exists\obb{Y <: \bd{N}}U}}
    %%% SYNTAX DEF
    \begin{tabularx}{\textwidth}{RcX}
    $\delta_1 \le \delta_2$ & \syndef & $\jqsub[\emptyset]{\delta_1}{\delta_2}$
    \end{tabularx}
  \end{minipage}

  %%% RIGHT COLUMN
  &

  %% MINIPAGE FOR RIGHT COLUMN
  \begin{minipage}{.45\textwidth}
    %%% APPLICABILITY
    \begin{center}
%      \fbox{\textbf{Applicability:} \japp{\delta}{T}~~$f \ni T$}
      \fbox{
\begin{tabular}{lc}
\textbf{Applicability:}& \japp{\delta}{T}\\
&$f \ni T$
\end{tabular}
}
    \end{center}
    \infrule
      {\jqsub{\exists\ob{}T}{\delta}}
      {\japp{\delta}{T}}
    %%% SYNTAX DEF

    \begin{tabularx}{\textwidth}{RcX}
    $\delta \ni T$ & \syndef & $\japp[\emptyset]{\delta}{T}$ \\
    $f \ni T$ & \syndef & $\japp[\emptyset]{dom(f)}{T}$\\
    \end{tabularx}

    %%% MORE SPECIFIC
    \begin{center}
      \fbox{\textbf{Specificity:} \jms{f}{f}}
    \end{center}
    \infrule
      {\jqsub{dom(f_1)}{dom(f_2)}}
      {\jms{f_1}{f_2}}
    %%% SYNTAX DEF
    \begin{tabularx}{\textwidth}{RcX}
    $f_1 \ms f_2$ & \syndef & $\jms[\emptyset]{f_1}{f_2}$
    \end{tabularx}
  \end{minipage} \\
  \hline
  \end{tabular}

  %%% SECOND ROW
  \begin{tabular}{c}
  \begin{minipage}{0.95\textwidth}
%  \begin{center}
\vspace*{.5em}
    \fbox{\textbf{Existential meet:} \quad $\delta_1 \;\meet\; \delta_2$}
    \[
\begin{array}{c}
      \left(\exists\tplist{X}{M}T\right) \; \meet \;
          \left(\exists\tplist{Y}{N}U\right)
      \quad \syndef \quad
      \exists\ob{\bds{X}{M}, \bds{Y}{N}}(T \cap U)
\\[.5em]
       %% \text{where} \quad
       %%  \begin{cases}
       %%    \bar{X} \cap \bar{Y} \;=\; \emptyset \\
       %%    \bar{X} \cap FV(U) \;=\; \emptyset \\
       %%    \bar{Y} \cap FV(T) \;=\; \emptyset
       %%  \end{cases}
\text{where}\;
\bar{X} \cap \bar{Y} \;=\; \emptyset \quad
\bar{X} \cap FV(U) \;=\; \emptyset \quad
\bar{Y} \cap FV(T) \;=\; \emptyset
\end{array}
    \] % \vspace{-1em}
    %     %%% SYNTAX DEF
    %     \[
    %       f_1 \;\meet\; f_2
    %       \quad \syndef \quad
    %       dom(f_1) \;\meet\; dom(f_2)
    %     \]
%  \end{center}
\end{minipage}
  \end{tabular}
\end{center}
  \caption{Subtyping on universal and existential types, applicability and specificity on generic function declarations,
and meet of existential types}
  \label{fig:sub}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%% END SUBTYPING %%%%%%%%%%%%%%%%%%%%%%


% Stuff needed in set up
% intersection and union types
%   can be structural types
%   distribute over structural types (tuples, arrows, intersection, union)
% Extensions of the class table
%   what does it mean for an extension to be well formed
%   what does this mean for condition 1)
% Language is call by value

Guaranteeing valid overloading requires constraints on the sets of overloaded function declarations
that are allowed to appear in a legal program \cite{millstein02,millstein03}.
Some languages require program constructs that encapsulate all overloaded definitions;
such constructs essentially guarantee valid overloading ````by construction''.
Examples in other languages include type classes \cite{wadler89,dreyer07,siek05}
and multimethods \cite{millstein02,millstein03,bourdoncle97}.
We take a different approach: rather than introducing additional language facilities,
we impose rules on the function declarations themselves.
% These aren't necessarily strictly "minimal" though, so:
We intend these rules to be ````minimal'' in that they should be as unrestrictive as possible
while preserving the ability to guarantee valid overloading and be checked in a modular way.
We took a similar approach to guarantee safety for overloaded monomorphic functions \cite{allen07}.
However, handling parametric polymorphism and implicit instantiation (i.e., type inference)
requires more sophisticated type analysis.
We achieve this analysis by introducing universal and existential quantification
over the ground types defined by class tables.

Specifically, in this section, we define three rules---the \emph{No Duplicates Rule},
\emph{Meet Rule}, and \emph{Return Type Rule}---for sets of overloaded function definitions,
and say that such a set is \emph{well-formed with respect to a class table}
if it satisfies all these rules using the subtyping relation induced by the class table.
We describe how to mechanically verify these rules in a modular way
in terms of subtyping relations on universal and existential types in Section~\ref{sec:checking},
and we show that any valid set of overloaded function declarations is safe in Section~\ref{sec:safety}.

\subsection{Overloading Rules}\label{sec:threerules}
In this section, we describe the rules for valid overloading.
For each function name $f$,
we determine whether a set of overloaded function declarations $\D(f)$ is valid
by independently considering every pair of declarations in the set.
A pair of declarations is a valid overloading if it satisfies one of three rules described below.
%the more-specific-than relation on these declarations by the subtyping relation induced by a class table $\T$.


To avoid the obvious ambiguity, $\D(f)$ should not contain equally specific declarations:
for each pair of overloaded declarations, either one declaration is strictly more specific
than the other or they are incomparable.
\begin{description}
\item[No Duplicates Rule]
$\D(f)$ does not contain any two declarations that are equally specific.
%(i.e., each declaration is more specific than the other).
In other words, there are no (distinct) declarations $f_1, f_2 \in \D(f)$ such that $f_1 \ms f_2$ and $f_2 \ms f_1$.
\end{description}


A pair of declarations is a valid overloading if for any call to which both declarations are applicable,
there is a {\em disambiguating declaration} (possibly one of the pair)
that is also applicable to the call and is at least as specific as both declarations.
Thus, at run time, the disambiguating declaration is chosen over the pair of declarations
because it is also applicable and and it is more specific than both.
\begin{description}
\item[Meet Rule]
For each pair of declarations $f_1, f_2 \in \D(f)$,
and for every type $T \in \T$, there should exist a third declaration $f_0 \in \D(f)$
(possibly one of the pair) such that $f_0$ is applicable to $T$ if and only if
both $f_1$ and $f_2$ are applicable to $T$.
\end{description}



If one monomorphic declaration is more specific than the other monomorphic one
then there is no ambiguity between these two declarations:
for any call to which both are applicable, the first is more specific.
In the parametrically polymorphic setting,
if one declaration is more specific than the other,
we require that for every instance of the second that is applicable to a call,
there exist an instance of the first that is also applicable to the call.
As in other object-oriented languages, to ensure type safety in the face of dynamic dispatch,
we also require that the return type of the latter declaration is a subtype of the return type of the former.
% We can ensure that the second well-formedness condition for overloading
% holds by checking the following rule for each function name $f$:
\begin{description}
\item[Return Type Rule]
For every $f_1, f_2 \in \D(f)$ with $f_1 \ms f_2$, for every type $W$ to which $f_1$ is applicable
(and therefore $f_2$ is also applicable)
and every instance $\decl{f_2'}{S_2'}{T_2'}$ of $f_2$ that is applicable to $W$,
there must exist an instance \decl{f_1'}{S_1'}{T_1'} of $f_1$
that is applicable to $W$ and satisfies \mbox{$T_1' <: T_2'$}.
\end{description}


\subsection{Overloading Rules Checking}\label{sec:checking}
This section describes how to check three overloading rules described in Section~\ref{sec:threerules} mechanically.
Because the rules use the notions of applicability and specificity for generic functions,
we first formalize them which in turn need formalization of
the ````arrow type of $f$'' for a generic function declaration $f$.

% For a generic function declaration \declg{f}{X}{N}{S}{T},
% its arrow type (written $arrow(f)$) is
% the \emph{universal type} $\forall\tplist{X}{N}S \rightarrow T$.
For a generic function declaration $\hdeclg{f}{\Delta}{S}{T}$,
its arrow type (written $arrow(f)$) is
the \emph{universal type} \mbox{$\forall\ob{\Delta}S \rightarrow T$}.
A universal type binds type parameter declarations over some type and
can be instantiated by any types valid for those type parameters.
We write $\forall\tplist{X}{N}T$ to quantify each type variable $X_i$ with bounds
$\{\bar{N_i}\}$ over the type $T$, and we use the metavariable $\sigma$ to range over universal types.


%applicability of a generic function
A generic function declaration $\hdeclg{f}{\Delta}{S}{T}$ is \emph{applicable} to a type $U$
if and only if \emph{there exists some instantiation} of $f$,
$\decl{f}{S'}{T'}$ with $\bar{W}$, that is applicable to $U$.
A monomorphic function declaration $\decl{f}{S'}{T'}$ is applicable to a type $U$
if and only if $U <: dom(f)$,
where $dom(f)$ is the domain $S'$ of $S' \rightarrow T'$, the arrow type of $f$.
%We must then extend our notion of the ````arrow type of $f$'' for a generic function declaration $f$,
%but first we need to characterize the type of a generic function.
% In particular, we need a higher-level notion of universally
% quantified types separate from the language of types $W$.
This existential quantification over possible
instantiations of the domain directly corresponds to an existentially
quantified type as in \cite{bourdoncle97}. An \emph{existential type}
$\exists\tplist{X}{N}T$ also binds type parameter declarations over a type, but
unlike a universal type, it cannot be instantiated; instead, it represents
some hidden type instantiation $\bar{W}$ and the corresponding instantiated
type $\substb{W}{X}T$. Therefore, we say that the domain of the universal arrow type for $f$,
$\forall\ob{\Delta}S \rightarrow T$ (again written $dom(f)$ as an abuse of notation),
is the existential type $\exists\ob{\Delta}{S}$.
We use the metavariable $\delta$ to range over existential types.
Note that we abbreviate both the universal type $\forall\ob{}T$ and
the existential type $\exists\ob{}T$ as simply $T$ when the meaning is clear from context.
Figure~\ref{fig:sub} presents the formal definition of applicability for a generic function $f$
to a type $T$, $f \ni T$.



%specificity for a generic function
A generic function declaration is \emph{more specific} than another generic function declaration
if and only if the domain of the former is a subtype of the latter as presented in Figure~\ref{fig:sub}.
Figure~\ref{fig:sub} also presents the subtype relation on existential types
as originally given by Mitchell \cite{mitchell88}.
Roughly, an existential type $\delta_1 = \exists \ob{\Delta_1} T_1$ is a
subtype of another existential type $\delta_2 = \exists\ob{\Delta_2}T_2$
(written $\delta_1 \le \delta_2$)
if $T_2$ can be instantiated to a supertype of $T_1$ in the environment $\Delta_1$.


Now, we can mechanically check the No Duplicates Rule
by mechanically determining if two declarations are equally specific.
To check whether one declaration is more specific than another,
we check whether the domain of the former is a subtype of the latter.
Checking whether one existential type is a subtype of another
is described in Figure~\ref{fig:sub}.


To check the Meet Rule, for every pair of declarations $f_1, f_2 \in \D(f)$,
we must find a function declaration $f_0 \in \D(f)$ that is
applicable to a type $T$ if and only if both $f_1$ and $f_2$ are applicable to $T$.
In other words, we need to find $f_0$ that is equivalent under specificity to
the meet of $f_1$ and $f_2$.
To mechanically find the meet of two generic function declarations,
we define the \emph{computed meet} of $f_1$ and $f_2$ as
a declaration $f_\meet$, not necessarily in $\D(f)$,
such that $dom(f_\meet) \equiv dom(f_1) \meet dom(f_2)$\footnote{Note that the computed meet, as defined,
is not actually unique since the return type is unspecified.
By an abuse of notation, we refer to ````the'' computed meet to mean any such computed meet.}: \begin{align*}
  dom(f_0) &\;\le\; dom(f_1) \meet dom(f_2) \\
  dom(f_1) \meet dom(f_2) &\;\le\; dom(f_0)
\end{align*}
Figure~\ref{fig:sub} defines the meet of two existential types $\delta_1 \meet \delta_2$,
which may require alpha renaming on the existential types' parameters.
The following lemma shows that the definition of the meet of two existential types is correct:
\begin{lemma}\label{lem:meet}
$\delta_1 \meet \delta_2$ is the meet of $\delta_1$ and $\delta_2$ under $\le$.
\end{lemma}
\begin{proof}
That $\delta_1 \meet \delta_2$ is a subtype of both $\delta_1$ and $\delta_2$ is obvious.
For any $\delta_0$, if $\bar{U}$ and $\bar{V}$ are instantiations that prove
$\delta_0$ is a subtype of $\delta_1$ and $\delta_2$, respectively,
then we can use $\bar{U},\bar{V}$ to prove that $\delta_0$ is a subtype of $\delta_1 \meet \delta_2$.
\end{proof}


We can check the Return Type Rule using the subtype relation on universal types.
The generic declarations $f_1 = \hdeclg{f}{\Delta_1}{S_1}{T_1}$ 
and $f_2 = \hdeclg{f}{\Delta_2}{S_2}{T_2}$ with $f_1 \ms f_2$ satisfy the Return Type Rule
whenever
\renewcommand{\theequation}{\fnsymbol{equation}}
\begin{equation} \label{eq:rtr}
  \forall\ob{\Delta_1}S_1 \rightarrow T_1 \; \le \; \forall\ob{\Delta_1, \Delta_2}(S_1 \cap S_2) \rightarrow T_2
\end{equation}
To see this, suppose $W$ is a type to which $f_1$ is applicable and the instance $\decl{f_2'}{S_2'}{T_2'}$ of $f_2$
is also applicable to $W$.
Let $f_\meet = \hdeclg{f}{\Delta_1, \Delta_2}{S_1 \cap S_2}{T_2}$ be the
computed meet of $f_1$ and $f_2$;
clearly, there is an instance 
$\decl{f_\meet'}{U'}{V'}$ of $f_\meet$ 
that is applicable to $W$ with $V' = T_2'$. 
If $arrow(f_1) \le arrow(f_\meet)$,
then there must be an instantiation $\decl{f_1'}{S_1'}{T_1'}$ of $f_1$
with $U' <: S_1'$ and $T_1' <: V'$. Moreover, since $V'=T_2'$,
such an $f_1'$ would satisfy the Return Type Rule for $f_1$ and $f_2$.
Finally, observe that $arrow(f_1) \le arrow(f_\meet)$ is identical to the
condition (\ref{eq:rtr}), and so the verification of (\ref{eq:rtr}) implies
the verification of the Return Type Rule.
Figure~\ref{fig:sub} presents the subtype relation on universal types, again,
as originally given by Mitchell \cite{mitchell88}.
Roughly, a universal type $\sigma_1 = \forall\ob{\Delta_1} T_1$ is a subtype of another universal
type $\sigma_2 = \forall\ob{\Delta_2} T_2$ (written $\sigma_1 \le \sigma_2$) if
$T_1$ can be instantiated to a subtype of $T_2$ in the environment $\Delta_2$.
