% * multiple dispatch
%   * fortress
%   * CLOS
%   * multijava
%   * cecil
% * type classes
%   * wadler 89
%   * qualified types (mpj)
%   * concepts (siek)
%   * inability to add ad-hoc overloaded functions
% * GADTs
%   * GADT inference (spj)
%   * HMG(X) (pottier)
%   * with OOP (russo)
%
\subsection{Overloading and dynamic dispatch.} Primarily, our system
strictly extends our previous effort \cite{allen07} with parametric polymorphism;
all previous properties and results remain intact. The inclusion of parametric
functions and types represents a shift in the research literature on overloading
and multiple dynamic dispatch.

Millstein and Chambers \cite{millstein02,millstein03} devised the language
Dubious to study overloaded functions with symmetric multiple dynamic dispatch
(\emph{multimethods}), and with Clifton and Leavens they developed MultiJava
\cite{multijava}, an extension of Java with Dubious' semantics for multimethods.
In \cite{feml}, Lee and Chambers presented F(E\textsc{ml}), a language with
classes, symmetric multiple dispatch, and parameterized modules, but without
parametricity at the level of functions or types. None of these systems support
polymorphic functions or types. F(E\textsc{ml})'s parameterized modules
(\emph{functors}) constitute a form of parametricity but they cannot be implicitly
applied; the functions defined therein cannot be \emph{overloaded} with those
defined in other functors. For a more detailed comparison of modularity and
dispatch between our system and these, we refer to the related work section of
our previous paper \cite{allen07}.

Overloading and multiple dispatch in the context of polymorphism has previously
been studied by Bourdoncle and Merz \cite{bourdoncle97}. Their system, ML$_\le$,
integrates parametric polymorphism, class-based object orientation, and multimethods,
but lacks multiple inheritance and true modularity. Each multimethod (overloaded set)
requires a unique specification (principal type), which prevents overloaded
functions defined on disjoint domains; the domains of the multimethod branches
must partition the specification domain, which eliminates subtype-based specialization;
and link-time checks must be performed to ensure that multimethods are fully
implemented across modules, which undermines true modularity. Further, ML$_\le$
allows variance annotations on type constructors --- something we attribute to
future work.
Litvinov~\cite{litvinov98} developed a type system for the Cecil language,
which supports bounded parametric polymorphism and multimethods.
Because Cecil has a type-erasure semantics, the statically checked
parametric polymorphism does not have any effects in runtime dispatches.


\subsection{Type classes.} Wadler and Blott \cite{wadler89} introduced
\emph{type class} as a means to specify and implement overloaded
functions like equality and arithmetic operators in Haskell. Other authors
have translated type classes to languages besides Haskell \cite{dreyer07,siek05,wehr07}.
Type classes encapsulate overloaded function declarations, with separate
\emph{instances} that define the behavior of those functions (called \emph{class methods})
for any particular type schema. Parametric polymorphism is then augmented to
express type class constraints, providing a way to quantify a type variable --- and
thus a function definition --- over all types that instantiate the type class. 

% In his thesis \cite{jonesbook} Jones generalized Haskell's underlying type
% system as \emph{qualified types}, in which the satisfaction of type predicates
% must be proved with constructed \emph{evidence}. Qualified type systems (such
% as Haskell) exhibit the \emph{principal types} property necessary for full
% Damas-Milner style type inference \cite{dm82,jonesbook}; our system conservatively
% assumes only \emph{local type inference} \cite{pierce00} --- implicit type
% instantiation for polymorphic function calls.

In systems with type classes, overloaded functions must be contained in some
type class, and their signatures must vary in exactly the same structural
position. This uniformity is necessary for an overloaded function call to
admit a principal type; with a principal type for some function call's context,
the type checker can determine the constraints under which a correct overloaded
definition will be found. Because of this requirement, type classes are ill-suited
for fixed, \emph{ad hoc} sets of overloaded functions like:
`    println(): () = println("")
    println(s: String): () = ...`
or functions lacking uniform variance in the domain and range\footnote{With the
\emph{multi-parameter type class} extension, one could define functions as these.
A reference to the method \mono{bar}, however, would require an explicit type
annotation like \mono{:: Int -> Bool} to apply to an \mono{Int}.} like:
`    bar(x: ZZ): Boolean = (x = 0)
    bar(x: Boolean): ZZ = if x then 1 else 2 end
    bar(x: String): String = x`
With type classes one can write overloaded functions with identical domain
types. Such behavior is consistent with the \emph{static}, \emph{type-based}
dispatch of Haskell, but it would lead to irreconcilable ambiguity in the
\emph{dynamic}, \emph{value-based} dispatch of our system.
%% In Appendix~\ref{app:haskell}, we present a further discussion of how our overloading resolution differs from that of Haskell and how our system might translate to that language, thereby addressing an existing inconsistency in modern type class extensions.

A broader interpretation of Wadler and Blott's \cite{wadler89} sees type
classes as program abstractions that quotient the space of ad-hoc polymorphism
into the much smaller space of class methods. Indeed, Wadler and Blott's title
suggests that the unrestricted space of ad-hoc polymorphism should be tamed,
whereas our work embraces the possible expressivity achieved from mixing ad-hoc
and parametric polymorphism by specifying the requisites for determinism and type safety.
