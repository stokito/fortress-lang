(*******************************************************************************
    Copyright 2008,2011, Oracle and/or its affiliates.
    All rights reserved.


    Use is subject to license terms.

    This distribution may include materials developed by third parties.

 ******************************************************************************)

component CompilerLibrary
(*
import java com.sun.fortress.nativeHelpers.{LocalRandom.localRandomDouble => jRandomDouble,
                                            LocalRandom.localRandomInt => jRandomInt }
*)
import CompilerBuiltin.{...}
import java com.sun.fortress.nativeHelpers.{equality.sEquiv => jSEQUIV}
export CompilerLibrary


(************************************************************
 * Value bindings
 ************************************************************)

(************************************************************
 * Simple Combinators
 ************************************************************)

(** Useful functions *)

ignore(_:Any):() = ()

(************************************************************
 * Control over locality and location
 ************************************************************)

(*) isShared(x:Any): Boolean = true

(************************************************************
 * Equality and ordering
 ************************************************************)

(* This is incomplete *)
opr ===(a:Any, b:Any):Boolean = jSEQUIV(a,b)
opr ===(a:ZZ64, b:ZZ64):Boolean = a=b
opr ===(a:ZZ32, b:ZZ32):Boolean = a=b
opr ===(a:RR64, b:RR64):Boolean = a=b
opr ===(a:RR32, b:RR32):Boolean = a=b
opr ===(a:String, b:String):Boolean = a=b
opr ===(a:Boolean, b:Boolean):Boolean = a<->b

opr NEQV(a:Any, b:Any):Boolean = NOT (a === b)

(*) For now, we cannot compile `throw`
fail(s:String):() = do
    errorPrintln("FAIL: " s)
(*)    throw FailCalled(s)
  end

(*
(** Assertion *)
assert(flag:Boolean): () =
    if NOT flag then
        fail("Assertion failed!")
    end

assert(flag: Boolean, failMsg: String): () =
    if NOT flag then
        fail(failMsg)
    end


assert(x:Any, y:Any, failMsg: Any...): () =
    if x =/= y then
        msg = x.asDebugString " =/= " y.asDebugString "; " (BIG || failMsg)  (* use || here instead of loose juxt *)
        fail(msg)
    end
*)

(*
deny(flag:Boolean): () = assert(NOT flag)

deny(flag: Boolean, failMsg: String): () = assert(NOT flag, failMsg)


deny(x:Any, y:Any, failMsg: Any...): () =
    if x = y then
        msg = x.asDebugString " = " y.asDebugString "; " (BIG || failMsg)
        fail(msg)
    end
*)

(************************************************************
* Exception hierarchy
************************************************************)
trait Exception comprises { UncheckedException, CheckedException }
end

(* Exceptions which are not checked *)

trait UncheckedException extends Exception excludes CheckedException
end

(*
object FailCalled(s:String) extends UncheckedException
    getter asString(): String = "FAIL: " s
end

object DivisionByZero extends UncheckedException
    getter asString(): String = "Division by zero"
end

object UnpastingError extends UncheckedException
    getter asString(): String = "Unpasting error"
end

object CallerViolation extends UncheckedException
    getter asString(): String = "Caller violation"
end

object CalleeViolation extends UncheckedException
    getter asString(): String = "Callee violation"
end

object LabelException extends UncheckedException
    getter asString(): String = "Exiting without an enclosing label block"
end

object TestFailure extends UncheckedException
    getter asString(): String = "Test failure"
end

object ContractHierarchyViolation extends UncheckedException
    getter asString(): String = "Contract hierarchy violation"
end

object NoEqualityOnFunctions extends UncheckedException
    getter asString(): String = "No equality on functions"
end

object InvalidRange extends UncheckedException
    getter asString(): String = "Invalid range"
end

object ForbiddenException(chain : Exception) extends UncheckedException
    getter asString(): String = "Forbidden exception"
end

(* Should this be called "IndexNotFound" instead? *)
object NotFound extends UncheckedException
    getter asString(): String = "Not found"
end

object IndexOutOfBounds[\I\](range:Range[\I\],index:I) extends UncheckedException
    getter asString(): String = index " is outside the range " range
end

object EmptyReduction extends UncheckedException
    getter asString(): String = "EmptyReduction: no identity, no elements"
end

object NegativeLength extends UncheckedException
    getter asString(): String = "Negative length"
end

object IntegerOverflow extends UncheckedException
    getter asString(): String = "Integer Overflow"
end

object RationalComparisonError extends UncheckedException
    getter asString(): String = "Rational comparison error"
end

object FloatingComparisonError extends UncheckedException
    getter asString(): String = "Floating comparison error"
end
*)

(* Checked Exceptions *)

trait CheckedException extends Exception excludes UncheckedException
end

(*
object CastError extends CheckedException
    getter asString(): String = "Cast error"
end

object IOFailure extends CheckedException
    getter asString(): String = "I/O error"
end

object MatchFailure extends CheckedException
    getter asString(): String = "Match failure"
end

(* SetsNotDisjoint? *)
object DisjointUnionError extends CheckedException
    getter asString(): String = "Disjoint union error"
end

object APIMissing extends CheckedException
    getter asString(): String = "Api is missing"
end

object APINameCollision extends CheckedException
    getter asString(): String = "Api name collides with another"
end

object ExportedAPIMissing extends CheckedException
    getter asString(): String = "Exported api is missing"
end

object HiddenAPIMissing extends CheckedException
    getter asString(): String = "Hidden api is missing"
end

object TryAtomicFailure extends CheckedException
    getter asString(): String = "Try/atomic failure"
end

(* Should take a spawned thread as an argument *)
object AtomicSpawnSynchronization extends {UncheckedException}
    getter asString(): String = "Atomic spawn synchronization"
end
*)

(*
opr SEQV(a:Any, b:Any) = jSEQV(a,b)
*)

(************************************************************
 * Simple Range support
 ************************************************************)

trait GeneratorZZ32 excludes { Boolean }
    getter asString(): String
    seq(self): SeqGeneratorZZ32 = SeqGenZZ32(self)
    loop(body:ZZ32->()): ()
    generate(r: ReductionString, body: ZZ32->String): String
    seqloop(body:ZZ32->()): ()
    seqgenerate(r: ReductionString, body: ZZ32->String): String
    filter(f: ZZ32 -> Boolean): GeneratorZZ32
    opr IN(x:ZZ32, self): Boolean = false
end

opr =(left:GeneratorZZ32, right:GeneratorZZ32): Boolean = false

trait SeqGeneratorZZ32 extends GeneratorZZ32
    getter asString(): String
    seq(self): SeqGeneratorZZ32 = self
    loop(body:ZZ32->()): () = seqloop(body)
    generate(r: ReductionString, body: ZZ32->String): String = seqgenerate(r, body)
    seqloop(body:ZZ32->()): () = loop(body)
    seqgenerate(r: ReductionString, body: ZZ32->String): String = generate(r,body)
    filter(f: ZZ32 -> Boolean): SeqGeneratorZZ32
end

__loop(g: GeneratorZZ32, body: ZZ32->()): () = g.loop(body)

__bigOperator(o:ReductionString,
              desugaredClauses:(ReductionString, String->String)->String): String =
    desugaredClauses(o,fn (s:String):String => s)

__generate(g: GeneratorZZ32, r: ReductionString, f:ZZ32->String): String =
    g.generate(r,f)
__generate(p: Boolean, r: ReductionString, f:()->String): String =
    if p then f() else r.empty() end


object SeqGenZZ32(g: GeneratorZZ32) extends SeqGeneratorZZ32
    getter asString(): String = "seq(" g.asString ")"
    loop(body:ZZ32->()): () = g.seqloop(body)
    generate(r: ReductionString, body: ZZ32->String): String = g.seqgenerate(r, body)
    seqloop(body:ZZ32->()): () = g.seqloop(body)
    seqgenerate(r: ReductionString, body: ZZ32->String): String =
        g.seqgenerate(r,body)
    filter(f: ZZ32 -> Boolean): SeqGeneratorZZ32 = seq(g.filter(f))
end

opr PAR(a:(), b:()): () = ()

parloop(lo:ZZ32, hi:ZZ32, p:ZZ32->Boolean, body:ZZ32->()): () =
    if lo=hi then
        if p(lo) then body(lo) end
    else
        mid = (lo+hi) DIV 2
        parloop(lo, mid, p, body) PAR parloop(mid+1, hi, p, body)
    end

countedseqloop(lo:ZZ32, hi:ZZ32, p:ZZ32->Boolean, body:ZZ32->()): () =
    if lo=hi then
        if p(lo) then body(lo) end
    else
        mid = (lo+hi) DIV 2
        countedseqloop(lo, mid, p, body)
        countedseqloop(mid+1, hi, p, body)
    end

gen(lo:ZZ32, hi:ZZ32, p: ZZ32->Boolean, r:ReductionString, body: ZZ32->String): String =
    if lo=hi then
        if p(lo) then body(lo) else r.empty() end
    else
        mid = (lo+hi) DIV 2
        r.join(gen(lo, mid, p, r, body), gen(mid+1, hi, p, r, body))
    end

seqgen(lo:ZZ32, hi:ZZ32, p: ZZ32->Boolean, r:ReductionString, body: ZZ32->String): String =
    if lo=hi then
        if p(lo) then body(lo) else r.empty() end
    else
        mid = (lo+hi) DIV 2
        left = seqgen(lo, mid, p, r, body)
        right = seqgen(mid+1, hi, p, r, body)
        r.join(left, right)
    end

object FilteredRange(lo: ZZ32, hi:ZZ32, p: ZZ32 -> Boolean) extends GeneratorZZ32
    getter asString(): String = "filtered(" lo.asString ":" hi.asString ")"
    seq(self): SeqGeneratorZZ32 = SeqGenZZ32(self)
    loop(body:ZZ32->()): () = if lo > hi then () else parloop(lo,hi,p,body) end
    seqloop(body:ZZ32->()): () = if lo > hi then () else countedseqloop(lo,hi,p,body) end
    generate(r: ReductionString, body: ZZ32->String): String =
        if lo > hi then r.empty() else gen(lo,hi,p,r,body) end
    seqgenerate(r: ReductionString, body: ZZ32->String): String =
        if lo > hi then r.empty() else seqgen(lo,hi,p,r,body) end
    filter(q: ZZ32 -> Boolean): FilteredRange =
        FilteredRange(lo, hi, fn n => p(n) AND: q(n))
end

opr :(lo:ZZ32, hi:ZZ32): GeneratorZZ32 = FilteredRange(lo, hi, fn (n) => true)
opr #(lo:ZZ32, sz:ZZ32): GeneratorZZ32 = lo : (lo+sz-1)

trait ReductionString
    empty(): String
    join(a: String, b: String): String
end

object StringConcatenation extends ReductionString
    empty(): String = ""
    join(a: String, b: String): String = a || b
end

(*
opr BIG ||(): StringConcatenation = StringConcatenation
*)

(************************************************************
* Random numbers
************************************************************)

(*
random(i:RR64): RR64 = jRandomDouble(i)
randomZZ32(x:ZZ32): ZZ32 = jRandomInt(0,x)
*)

(************************************************************
* Matrices (stub)
************************************************************)
trait Matrix[\T, nat s0, nat s1\] extends Object end

end
