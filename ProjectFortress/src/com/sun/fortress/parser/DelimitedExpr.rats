/*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress expressions that are enclosed by keywords.
 */
module DelimitedExpr(TraitObject, Header, Type, Expr, LocalDecl, Literal,
                     Identifier, Keyword, Symbol, Spacing);
import TraitObject;
import Header;
import Type;
import Expr;
import LocalDecl;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* DelimitedExpr ::=
     TupleExpr
   | Parenthesized
   | object (w Extends)? (w GoInAnObject)? w end
   | Do
   | label w Id w BlockElems w end w Id
   | while w Expr w Do
   | for w GeneratorList w DoFront w end
   | if w Expr w then w BlockElems (w Elifs)? (w Else)? w end
   | ( w if w Expr w then w BlockElems (w Elifs)? w Else (w end)? w )
   | case w Expr (w Op)? w of w CaseClauses (w CaseElse)? w end
   | case w (largest | smallest) (w Op)? w of w CaseClauses w end
   | typecase w TypecaseBindings w of w TypecaseClauses (br CaseElse)? w end
   | try w BlockElems (w Catch)? (w forbid w TraitTypes)? (w finally w BlockElems)? w end
 */
Expr DelimitedExpr =
     TupleExpr
   / Parenthesized
   / object a1:(w ExtendsWhere)? a2:(w GoInAnObject)? w end
     { if (a1 == null) a1 = FortressUtil.emptyTraitTypeWheres();
       if (a2 == null) a2 = Collections.<Decl>emptyList();
       yyValue = new ObjectExpr(createSpan(yyStart,yyCount), false, a1, a2);
     }
   / Do
   / label w a1:Id w a2:BlockElems w end w a3:Id
     { if (!a1.getName().equals(a3.getName()))
           error(a1, "Mismatched identifiers for label expressions.");
       yyValue = new Label(createSpan(yyStart,yyCount), false, a1, a2);
     }
   / while w a1:Expr w a2:Do
     { yyValue = new While(createSpan(yyStart,yyCount), false, a1, a2); }
   / for w a1:GeneratorList w a2:DoFront w end
     { yyValue = new For(createSpan(yyStart,yyCount), false, a1, a2); }
   / if w a1:Expr w then w a2:BlockElems a3:(w Elifs)? a4:(w Else)? w end
     { IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
       List<IfClause> clauses = FortressUtil.mkList(ic);
       if (a3 != null) clauses.addAll(a3);
       Option<Block> elseC = Option.wrap(a4);
       yyValue = new If(createSpan(yyStart,yyCount), false, clauses, elseC);
     }
   / openparen w if w a1:Expr w then w a2:BlockElems a3:(w Elifs)? w a4:Else
       (w end)? w closeparen
     { IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
       List<IfClause> clauses = FortressUtil.mkList(ic);
       if (a3 != null) clauses.addAll(a3);
       yyValue = new If(createSpan(yyStart,yyCount),false,clauses,
                        Option.some(a4));
     }
   / case w a1:Expr a2:(w Op)? w of w a3:CaseClauses a4:(w CaseElse)? w end
     { CaseParam e1 = new CaseParamExpr(a1.getSpan(), a1);
       Option<Op> compare;
       if (a2 == null) compare = Option.none();
       else            compare = Option.some(a2);
       if (a4 == null) a4 = FortressUtil.doBlock(FortressUtil.emptyExprs());
       yyValue = new CaseExpr(createSpan(yyStart,yyCount), false, e1, compare,
                              a3, Option.some(a4));
     }
   / case w a1:(largest / smallest)  a2:(w Op)? w of w a3:CaseClauses w end
     { CaseParam e1;
       if (a1.equals("largest"))
           e1 = new CaseParamLargest(createSpan(yyStart+5,7));
       else // a1.equals("smallest")
           e1 = new CaseParamSmallest(createSpan(yyStart+5,8));
       Option<Op> compare = Option.wrap(a2);
       yyValue = new CaseExpr(createSpan(yyStart,yyCount), false, e1, compare,
                              a3, Option.some(FortressUtil.doBlock(FortressUtil.emptyExprs())));
     }
   / typecase w a1:TypecaseBindings w of w a2:TypecaseClauses a3:(br CaseElse)?
       w end
     { Option<Block> caseElse = Option.wrap(a3);
       yyValue = new Typecase(createSpan(yyStart,yyCount), false, a1, a2, caseElse);
     }
   / try w a1:BlockElems a2:(w Catch)? a3:(w forbid w TraitTypes)?
     a4:(w finally w BlockElems)? w end
     { Option<Catch> catch_ = Option.wrap(a2);
       if (a3 == null) a3 = FortressUtil.emptyTraitTypes();
       Option<Block> finally_ = Option.wrap(a4);
       yyValue = new Try(createSpan(yyStart,yyCount), false, a1, catch_, a3,
                         finally_);
     };

/* Do ::= (DoFront w also w)* DoFront w end */
Do Do = a1s:(DoFront w also w)* a2:DoFront w end
     { yyValue = new Do(createSpan(yyStart, yyCount), false,
                        FortressUtil.mkList(a1s.list(), a2));
     };

/* DoFront ::= (at w Expr w)? (atomic w)? do (w BlockElems)? */
private DoFront DoFront =
     a1:(at w Expr w)? a2:(atomic w)? do a3:(w BlockElems)?
     { Option<Expr> at = Option.wrap(a1);
       boolean atomic = (a2 == null) ? false : true;
       if (a3 == null) a3 = FortressUtil.doBlock(FortressUtil.emptyExprs());
       yyValue = new DoFront(createSpan(yyStart,yyCount), at, atomic, a3);
     };

/* TupleExpr ::=
     ( w (Expr w , w)* (Expr w ... w , w)? Binding (w , w Binding)* w )
   | NoKeyTuple
 */
Expr TupleExpr =
     openparen w a1s:(Expr w comma w)* a2:(Expr w ellipses w comma w)?
       a3:Binding a4s:(w comma w Binding)* w closeparen
     { List<Expr> es = a1s.list();
       Option<VarargsExpr> vs = ((a2 != null) ?
                              Option.some(new VarargsExpr(a2.getSpan(), a2)) :
                              Option.<VarargsExpr>none());
       List<Binding> ks = new ArrayList<Binding>();
       ks.add(new Binding(a3.getId(), a3.getInit()));
       for (Binding b : (List<Binding>)a4s.list()) {
           ks.add(b);
       }
       yyValue = new TupleExpr(createSpan(yyStart,yyCount), false, es, vs, ks);
     }
   / NoKeyTuple ;

/* NoKeyTuple ::=
     ( w (Expr w , w)*  Expr w ... w )
   | ( w (Expr w , w)+  Expr w )
 */
Expr NoKeyTuple =
     openparen w a1s:(Expr w comma w)* a2:Expr w ellipses w closeparen
     { Option<VarargsExpr> vs = Option.some(new VarargsExpr(a2.getSpan(), a2));
       yyValue = new TupleExpr(createSpan(yyStart,yyCount), false, a1s.list(), vs);
     }
   / openparen w a1s:(Expr w comma w)+ a2:Expr w closeparen
     { List<Expr> es = FortressUtil.mkList(a1s.list(), a2);
       yyValue = new TupleExpr(createSpan(yyStart,yyCount), false, es);
     } ;

/* Parenthesized ::= ( w Expr w ) */
Expr Parenthesized =
     openparen w a1:Expr w closeparen
     { yyValue = ExprFactory.makeInParentheses(a1); };

/* Elifs ::= Elif (w Elif)* */
List<IfClause> Elifs = a1:Elif a2s:(w Elif)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* Elif ::= elif w Expr w then w BlockElems */
private IfClause Elif = elif w a1:Expr w then w a2:BlockElems
     { yyValue = new IfClause(createSpan(yyStart,yyCount), a1, a2); };

/* Else ::= else w BlockElems */
Block Else = else w yyValue:BlockElems;

/* CaseClauses ::= CaseClause (br CaseClause)* */
private List<CaseClause> CaseClauses = a1:CaseClause a2s:(br CaseClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* CaseElse ::= else w => w BlockElems */
Block CaseElse = else w match w BlockElems ;

/* TypecaseBindings ::=
     ( w BindingList w )
   | Binding
   | Id
 */
private List<Binding> TypecaseBindings =
     openparen w BindingList w closeparen
   / a1:Binding
     { yyValue = FortressUtil.mkList(a1); }
   / a1:Id
     { yyValue = FortressUtil.mkList(new Binding(createSpan(yyStart,yyCount), a1,
                                              ExprFactory.makeVarRef(a1.getSpan(), a1)));
     };

/* BindingList ::= Binding (w , w Binding)*  */
private List<Binding> BindingList = a1:Binding a2s:(w comma w Binding)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* Binding ::= Id w = w Expr */
private Binding Binding = a1:Id w equals w a2:Expr
     { yyValue = new Binding(createSpan(yyStart,yyCount), a1, a2); };

/* TypecaseClauses ::= TypecaseClause (br TypecaseClause)* */
private List<TypecaseClause> TypecaseClauses =
     a1:TypecaseClause a2s:(br TypecaseClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* TypecaseClause ::= TypecaseTypes w => w BlockElems */
TypecaseClause TypecaseClause =
     a1:TypecaseTypes w match w a2:BlockElems
     { yyValue = new TypecaseClause(createSpan(yyStart,yyCount), a1, a2); };

/* TypecaseTypes ::=
     ( w TypeList w )
   | Type
 */
List<Type> TypecaseTypes =
     openparen w TypeList w closeparen
   / a1:Type
     { yyValue = FortressUtil.mkList(a1); };

/* Catch ::= catch w Id w CatchClauses */
Catch Catch = catch w a1:Id w a2:CatchClauses
     { yyValue = new Catch(createSpan(yyStart,yyCount), a1, a2); };

/* CatchClauses ::= CatchClause (br CatchClause)* */
private List<CatchClause> CatchClauses = a1:CatchClause a2s:(br CatchClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* CatchClause ::= TraitType w => w BlockElems */
private CatchClause CatchClause = a1:TraitType w match w a2:BlockElems
     { yyValue = new CatchClause(createSpan(yyStart,yyCount), a1, a2); };

/* Comprehension ::=
     { w Expr wr | wr GeneratorList w }
   | { w Entry wr | wr GeneratorList w }
   | <| w Expr wr | wr GeneratorList w |>
   | [ w ArrayComprehensionClause (br ArrayComprehensionClause)* w ]
 */
Comprehension Comprehension =
     opencurly w a1:Expr wr bar wr a2:GeneratorList w closecurly
     { yyValue = new SetComprehension(createSpan(yyStart,yyCount),false,a2,a1); }
   / opencurly w a1:Entry wr bar wr a2:GeneratorList w closecurly
     { yyValue = new MapComprehension(createSpan(yyStart,yyCount),false,a2,a1); }
   / openangle w a1:Expr wr bar wr a2:GeneratorList w closeangle
     { yyValue = new ListComprehension(createSpan(yyStart,yyCount),false,a2,a1);}
   / opensquare w a1:ArrayComprehensionClause a2s:(br ArrayComprehensionClause)*
       w closesquare
     { List<ArrayComprehensionClause> clauses = FortressUtil.mkList(a1, a2s.list());
       yyValue = new ArrayComprehension(createSpan(yyStart,yyCount), false, clauses);
     };

/* The operator "|->" should not be in the left-hand sides of map expressions
   and map/array comprehensions.
 */
String mapstoOp = !("|->" w Expr (w mapsto / wr bar / w closecurly / w comma)) "|->" ;

/* Entry ::= Expr w |-> w Expr */
Entry Entry = a1:Expr w mapsto w a2:Expr
     { yyValue = new Entry(createSpan(yyStart,yyCount), a1, a2); };

/* ArrayComprehensionLeft ::=
     IdOrInt w |-> w Expr
   | ( w IdOrInt w , w IdOrIntList w ) w |-> w Expr
 */
com.sun.fortress.useful.Pair<List<Expr>,Expr> ArrayComprehensionLeft =
     a1:IdOrInt w mapsto w a2:Expr
     { List<Expr> exprs = FortressUtil.mkList(a1);
       yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a2);
     }
   / openparen w a1:IdOrInt w comma w a2:IdOrIntList w closeparen w mapsto w a3:Expr
     { List<Expr> exprs = FortressUtil.mkList(a1);
       for (Expr i : a2) {
           exprs.add(i);
       }
       yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a3);
     };

/* IdOrInt ::= Id | IntLiteral */
Expr IdOrInt =
     a1:Id { yyValue = ExprFactory.makeVarRef(a1.getSpan(), a1); }
   / IntLiteral ;

/* IdOrIntList ::= IdOrInt (w , w IdOrInt)* */
List<Expr> IdOrIntList = a1:IdOrInt a2s:(w comma w IdOrInt)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* BaseExpr ::=
     NoKeyTuple
   | Parenthesized
   | Literal
   | Aggregate
   | DottedId
   | self
 */
Expr BaseExpr =
     NoKeyTuple
   / Parenthesized
   / Literal
   / Aggregate
   / a1:DottedId
     { yyValue = new VarRef(createSpan(yyStart,yyCount), false, a1); }
   / a1:self
     { yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1); };

/* ExprList ::= Expr (w , w Expr)* */
List<Expr> ExprList = a1:Expr a2s:(w comma w Expr)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };
