/*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress headers.
 */
module Header(Other, Type, Expr, DelimitedExpr, Identifier, Keyword, Symbol,
              Spacing);

import Other;
import Type;
import Expr;
import DelimitedExpr;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* ExtendsWhere ::= extends w TraitTypeWheres */
List<TraitTypeWhere> ExtendsWhere = extends w TraitTypeWheres ;

/* TraitTypeWheres ::= TraitTypeWhere | { w TraitTypeWhereList w } */
private List<TraitTypeWhere> TraitTypeWheres =
     a1:TraitTypeWhere { yyValue = FortressUtil.mkList(a1); }
   / opencurly w TraitTypeWhereList w closecurly ;

/* TraitTypeWhereList ::= TraitTypeWhere (w , w TraitTypeWhere)* */
private List<TraitTypeWhere> TraitTypeWhereList =
     a1:TraitTypeWhere a2s:(w comma w TraitTypeWhere)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* TraitTypeWhere ::= TraitType (w Where)? */
private TraitTypeWhere TraitTypeWhere =
     a1:TraitType a2:(w Where)?
     { if (a2 == null) a2 = Collections.<WhereClause>emptyList();
       yyValue = new TraitTypeWhere(a1, a2);
     };

/* Extends ::= extends w TraitTypes */
List<TraitType> Extends = extends w TraitTypes ;

/* Excludes ::= excludes w TraitTypes */
List<TraitType> Excludes = excludes w TraitTypes ;

/* Comprises ::= comprises w TraitTypes */
List<TraitType> Comprises = comprises w TraitTypes ;

/* AbsComprises ::= comprises w ComprisingTypes */
List<TraitType> AbsComprises = comprises w ComprisingTypes ;

/* TraitTypes ::= TraitType | { w TraitTypeList w } */
List<TraitType> TraitTypes =
     a1:TraitType { yyValue = FortressUtil.mkList(a1); }
   / opencurly w TraitTypeList w closecurly ;

/* TraitTypeList ::= TraitType (w , w TraitType)* */
private List<TraitType> TraitTypeList = a1:TraitType a2s:(w comma w TraitType)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* ComprisingTypes ::= TraitType | { w ComprisingTypeList w } */
private List<TraitType> ComprisingTypes =
     a1:TraitType { yyValue = FortressUtil.mkList(a1); }
   / opencurly w ComprisingTypeList w closecurly ;

/* ComprisingTypeList ::=
     ...
   | TraitType (w , w TraitType)* (w , w ...)?
 */
private List<TraitType> ComprisingTypeList =
     ellipses
     { yyValue = FortressUtil.emptyTraitTypes(); }
   / a1:TraitType a2s:(w comma w TraitType)* (w comma w ellipses)?
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* Where ::= where w { w WhereClauseList w } */
List<WhereClause> Where =
      where w opencurly w WhereClauseList w closecurly ;

/* WhereClauseList ::= WhereClause (w , w WhereClause)* */
private List<WhereClause> WhereClauseList =
     a1:WhereClause a2s:(w comma w WhereClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* WhereClause ::=
     Id w Extends
   | TypeAlias
   | nat w Id
   | int w Id
   | bool w Id
   | unit w Id
   | Type w coerces w Type
   | Type w widens w Type
   | dimensionless w = w Id
   | Id w = w dimensionless
   | DottedId w = w DottedId
   | IntConstraint
   | BoolConstraint
 */
private WhereClause WhereClause =
     a1:Id w a2:Extends
     { yyValue = new WhereExtends(createSpan(yyStart,yyCount), a1, a2); }
   / TypeAlias
   / nat w a1:Id
     { yyValue = new WhereNat(createSpan(yyStart,yyCount), a1); }
   / int w a1:Id
     { yyValue = new WhereInt(createSpan(yyStart,yyCount), a1); }
   / bool w a1:Id
     { yyValue = new WhereBool(createSpan(yyStart,yyCount), a1); }
   / unit w a1:Id
     { yyValue = new WhereUnit(createSpan(yyStart,yyCount), a1); }
   / a1:Type w coerces w a2:Type
     { yyValue = new WhereCoerces(createSpan(yyStart,yyCount), a1, a2); }
   / a1:Type w widens w a2:Type
     { yyValue = new WhereWidens(createSpan(yyStart,yyCount), a1, a2); }
   / "dimensionless" w equals w a1:Id
     { yyValue = new UnitConstraint(createSpan(yyStart,yyCount), a1); }
   / a1:Id w equals w "dimensionless"
     { yyValue = new UnitConstraint(createSpan(yyStart,yyCount), a1); }
   / a1:DottedId w equals w a2:DottedId
     { yyValue = new WhereEquals(createSpan(yyStart,yyCount), a1, a2); }
   / IntConstraint
   / BoolConstraint ;

/* IntConstraint ::=
     IntExpr w <= w IntExpr
   | IntExpr w <  w IntExpr
   | IntExpr w >= w IntExpr
   | IntExpr w >  w IntExpr
   | IntExpr w =  w IntExpr
 */
private IntConstraint IntConstraint =
     a1:IntExpr w "<=":op w a2:IntExpr
     { yyValue = new LEConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:IntExpr w "<":op  w a2:IntExpr
     { yyValue = new LTConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:IntExpr w ">=":op w a2:IntExpr
     { yyValue = new GEConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:IntExpr w ">":op  w a2:IntExpr
     { yyValue = new GTConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:IntExpr w equals w a2:IntExpr
     { yyValue = new IEConstraint(createSpan(yyStart,yyCount), a1, a2); };

/* IntVal ::=
     Number
   | DottedId
 */
IntVal IntVal =
     a1:Number
     { yyValue = new NumberConstraint(createSpan(yyStart,yyCount), a1); }
   / a1:DottedId
     { yyValue = new IntIdConstraint(createSpan(yyStart,yyCount), a1); };

/* IntExpr ::=
     IntVal
   | IntExpr w + w IntExpr
   | IntExpr w - w IntExpr
   | IntExpr sr IntExpr
   | IntExpr w DOT w IntExpr
   | IntExpr ^ IntVal
   | ( w IntExpr w )
 */
private IntExpr IntExpr =
     seed:IntExprFront list:IntExprTail*
     { yyValue = (IntExpr)apply(list, seed); };

private IntExpr IntExprFront =
     IntVal
   / openparen w a1:IntExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<IntExpr> IntExprTail =
     SumIntExpr
   / MinusIntExpr
   / ProductIntExpr
   / ExponentIntExpr
   ;

private constant inline Action<IntExpr> SumIntExpr =
     w plus w a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               return new SumConstraint(createSpan(yyStart,yyCount),
                                        (IntExpr)base, a1);
           }};
     };

private constant inline Action<IntExpr> MinusIntExpr =
     w minus w a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               return new MinusConstraint(createSpan(yyStart,yyCount),
                                          (IntExpr)base, a1);
           }};
     };

private constant inline Action<IntExpr> ProductIntExpr =
     (w DOT w / sr) a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               return new ProductConstraint(createSpan(yyStart,yyCount),
                                            (IntExpr)base, a1);
           }};
     };

private constant inline Action<IntExpr> ExponentIntExpr =
     caret a1:IntVal
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               return new ExponentConstraint(createSpan(yyStart,yyCount),
                                             (IntExpr)base, a1);
           }};
     };

/* BoolConstraint ::=
     NOT w BoolExpr
   | BoolExpr w OR w BoolExpr
   | BoolExpr w AND w BoolExpr
   | BoolExpr w IMPLIES w BoolExpr
   | BoolExpr w = w BoolExpr
 */
private BoolConstraint BoolConstraint =
     seed:BoolConstraintFront list:BoolConstraintTail*
     { yyValue = (BoolConstraint)apply(list, seed); };

private BoolConstraint BoolConstraintFront =
     "NOT":op w a1:BoolExpr
     { yyValue = new NotConstraint(createSpan(yyStart,yyCount), a1); }
   / a1:BoolConstraintHead w "OR":op  w a2:BoolExpr
     { yyValue = new OrConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:BoolConstraintHead w "AND":op w a2:BoolExpr
     { yyValue = new AndConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:BoolConstraintHead w "IMPLIES":op  w a2:BoolExpr
     { yyValue = new ImpliesConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:BoolConstraintHead w equals w a2:BoolExpr
     { yyValue = new BEConstraint(createSpan(yyStart,yyCount), a1, a2); };

private BoolExpr BoolConstraintHead =
     BoolVal
   / openparen w a1:BoolExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<BoolConstraint> BoolConstraintTail =
     OrBoolConstraint
   / AndBoolConstraint
   / ImpliesBoolConstraint
   / EqualsBoolConstraint
   ;

private constant inline Action<BoolConstraint> OrBoolConstraint =
     w "OR":op  w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               return new OrConstraint(createSpan(yyStart,yyCount),
                                       NodeFactory.makeBoolConstraintExpr((BoolConstraint)base), a1);
           }};
     };

private constant inline Action<BoolConstraint> AndBoolConstraint =
     w "AND":op w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               return new AndConstraint(createSpan(yyStart,yyCount),
                                        NodeFactory.makeBoolConstraintExpr((BoolConstraint)base), a1);
           }};
     };

private constant inline Action<BoolConstraint> ImpliesBoolConstraint =
     w "IMPLIES":op  w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               return new ImpliesConstraint(createSpan(yyStart,yyCount),
                                            NodeFactory.makeBoolConstraintExpr((BoolConstraint)base), a1);
           }};
     };

private constant inline Action<BoolConstraint> EqualsBoolConstraint =
     w equals w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               return new BEConstraint(createSpan(yyStart,yyCount),
                                       NodeFactory.makeBoolConstraintExpr((BoolConstraint)base), a1);
           }};
     };

/* BoolVal ::=
     true
   | false
   | DottedId
 */
private BoolVal BoolVal =
     a1:"true"
     { yyValue = new TrueConstraint(createSpan(yyStart,yyCount)); }
   / a1:"false"
     { yyValue = new FalseConstraint(createSpan(yyStart,yyCount)); }
   / a1:DottedId
     { yyValue = new BoolIdConstraint(createSpan(yyStart,yyCount), a1); };

/* BoolExpr ::=
     BoolVal
   | BoolConstraint
   | ( w BoolExpr w )
 */
private BoolExpr BoolExpr =
     seed:BoolExprFront list:BoolExprTail*
     { yyValue = (BoolExpr)apply(list, seed); };

private BoolExpr BoolExprFront =
     BoolVal
   / openparen w a1:BoolExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); }
   / "NOT":op w a1:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new BoolConstraintExpr(span, new NotConstraint(span, a1));
     };

private constant transient Action<BoolExpr> BoolExprTail =
     OrBoolExpr
   / AndBoolExpr
   / ImpliesBoolExpr
   / EqualsBoolExpr
   ;

private constant inline Action<BoolExpr> OrBoolExpr =
     w "OR":op  w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               return new BoolConstraintExpr(span, new OrConstraint(span,
                                                       (BoolExpr)base, a1));
           }};
     };

private constant inline Action<BoolExpr> AndBoolExpr =
     w "AND":op w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               return new BoolConstraintExpr(span, new AndConstraint(span,
                                                   (BoolExpr)base, a1));
           }};
     };

private constant inline Action<BoolExpr> ImpliesBoolExpr =
     w "IMPLIES":op  w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               return new BoolConstraintExpr(span, new ImpliesConstraint(span,
                                                   (BoolExpr)base, a1));
           }};
     };

private constant inline Action<BoolExpr> EqualsBoolExpr =
     w equals w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               return new BoolConstraintExpr(span, new BEConstraint(span,
                                                   (BoolExpr)base, a1));
           }};
     };

/* FnHeaderClause ::= (w IsType)? FnClauses */
FnHeaderClause FnHeaderClause = a1:(w IsType)? a2:FnClauses
     { Option<Type> returnType = Option.wrap(a1);
       yyValue = new FnHeaderClause(a2.getThrowsClause(), a2.getWhereClause(),
                                    a2.getContractClause(), returnType);
     };

/* FnClauses ::= (w Throws)? (w Where)? Contract */
FnHeaderClause FnClauses = a1:(w Throws)? a2:(w Where)? a3:Contract
     { Option<List<TraitType>>   throwsClause = Option.wrap(a1);
       Option<List<WhereClause>> whereClause = Option.wrap(a2);
       Option<Contract>          contractClause = Option.wrap(a3);
       yyValue = new FnHeaderClause(throwsClause, whereClause, contractClause,
                                    Option.<Type>none());
     };

/* Throws ::= throws w MayTraitTypes */
List<TraitType> Throws = throws w MayTraitTypes ;

/* MayTraitTypes ::= { w } | TraitTypes  */
private List<TraitType> MayTraitTypes =
     opencurly w closecurly { yyValue = FortressUtil.emptyTraitTypes(); }
   / TraitTypes ;

/* Contract ::= (w Requires)? (w Ensures)? (w Invariant)? */
Contract Contract =
     a1:(w Requires)? a2:(w Ensures)? a3:(w Invariant)?
     { Option<List<Expr>> requires = Option.wrap(a1);
       Option<List<EnsuresClause>> ensures = Option.wrap(a2);
       Option<List<Expr>> invariant = Option.wrap(a3);
       if (a1 == null && a2 == null && a3 == null) yyValue = null;
       else yyValue = new Contract(createSpan(yyStart,yyCount), requires,
                                   ensures, invariant);
     };

/* Requires ::= requires w { (w ExprList)? w } */
private List<Expr> Requires = requires w opencurly a1:(w ExprList)? w closecurly
     { if (a1 == null) yyValue = FortressUtil.emptyExprs();
       else            yyValue = a1;
     };

/* Ensures  ::= ensures w { (w EnsuresClauseList)? w } */
private List<EnsuresClause> Ensures =
     ensures w opencurly a1:(w EnsuresClauseList)? w closecurly
     { if (a1 == null) yyValue = FortressUtil.emptyEnsuresClauses();
       else            yyValue = a1;
     };

/* EnsuresClauseList ::= EnsuresClause (w , w EnsuresClause)* */
private List<EnsuresClause> EnsuresClauseList =
     a1:EnsuresClause a2s:(w comma w EnsuresClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* EnsuresClause ::= Expr (w provided w Expr)? */
private EnsuresClause EnsuresClause = a1:Expr a2:(w provided w Expr)?
     { Option<Expr> ensures = Option.wrap(a2);
       yyValue = new EnsuresClause(createSpan(yyStart,yyCount), a1, ensures);
     };

/* Invariant::= invariant w { (w ExprList)? w } */
private List<Expr> Invariant =
     invariant w opencurly a1:(w ExprList)? w closecurly
     { if (a1 == null) yyValue = FortressUtil.emptyExprs();
       else            yyValue = a1;
     };

/* CoercionClauses ::= (w CoercionWhere)? w CoercionContract */
FnHeaderClause CoercionClauses = a1:(w CoercionWhere)? w a2:CoercionContract
     { Option<List<WhereClause>> whereClause = Option.wrap(a1);
       Option<Contract>          contractClause = Option.wrap(a2);
       yyValue = new FnHeaderClause(Option.<List<TraitType>>none(), whereClause,
                                    contractClause, Option.<Type>none());
     };

/* CoercionWhere ::= where w { w CoercionWhereClauseList w } */
private List<WhereClause> CoercionWhere =
     where w opencurly w CoercionWhereClauseList w closecurly ;

/* CoercionWhereClauseList ::= CoercionWhereClause (w , w CoercionWhereClause)*
 */
private List<WhereClause> CoercionWhereClauseList =
     a1:CoercionWhereClause a2s:(w comma w CoercionWhereClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* CoercionWhereClause ::=
     WhereClause
   | Type w widens w or w coerces w Type
*/
private WhereClause CoercionWhereClause =
     WhereClause
   / a1:Type w widens w or w coerces w a2:Type
     { yyValue = new WhereWidensCoerces(createSpan(yyStart,yyCount), a1, a2); };

/* CoercionContract ::= (w Ensures)? (w Invariant)? */
Contract CoercionContract = a1:(w Ensures)? a2:(w Invariant)?
     { Option<List<EnsuresClause>> ensures = Option.wrap(a1);
       Option<List<Expr>> invariant = Option.wrap(a2);
       if (a1 == null && a2 == null) yyValue = null;
       else yyValue = new Contract(createSpan(yyStart,yyCount),
                                   Option.<List<Expr>>none(), ensures, invariant);
     };

/* Each modifier cannot appear more than once. */
/* TraitMods ::= (TraitMod w)+ */
List<Modifier> TraitMods = a1s:(TraitMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* TraitMod ::= AbsTraitMod | private */
private Modifier TraitMod =
     AbsTraitMod
   / private { yyValue = new ModifierPrivate(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* AbsTraitMods ::= (AbsTraitMod w)+ */
List<Modifier> AbsTraitMods = a1s:(AbsTraitMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* AbsTraitMod ::= value | test */
private Modifier AbsTraitMod =
     value { yyValue = new ModifierValue(createSpan(yyStart,yyCount)); }
   / test  { yyValue = new ModifierTest(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* ObjectMods ::= TraitMods */
List<Modifier> ObjectMods = TraitMods ;

/* Each modifier cannot appear more than once. */
/* AbsObjectMods ::= AbsTraitMods */
List<Modifier> AbsObjectMods = AbsTraitMods ;

/* Each modifier cannot appear more than once. */
/* MdMods ::= (MdMod w)+ */
List<Modifier> MdMods = a1s:(MdMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* MdMod ::= FnMod | override */
private Modifier MdMod =
     FnMod
   / override { yyValue = new ModifierOverride(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* AbsMdMods ::= (AbsMdMod w)+ */
List<Modifier> AbsMdMods = a1s:(AbsMdMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* AbsMdMod ::= AbsMdMod | override */
private Modifier AbsMdMod =
     AbsFnMod
   / override { yyValue = new ModifierOverride(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* FnMods ::= (FnMod w)+ */
List<Modifier> FnMods = a1s:(FnMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* FnMod ::= AbsFnMod | private */
private Modifier FnMod =
     AbsFnMod
   / private { yyValue = new ModifierPrivate(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* AbsFnMods ::= (AbsFnMod w)+ */
List<Modifier> AbsFnMods = a1s:(AbsFnMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* AbsFnMod ::= LocalFnMod | test */
private Modifier AbsFnMod =
     LocalFnMod
   / test { yyValue = new ModifierTest(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* LocalFnMods ::= (LocalFnMod w)+ */
List<Modifier> LocalFnMods = a1s:(LocalFnMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* LocalFnMod ::= atomic | io */
private Modifier LocalFnMod =
     atomic { yyValue = new ModifierAtomic(createSpan(yyStart,yyCount)); }
   / io     { yyValue = new ModifierIO(createSpan(yyStart,yyCount)); } ;

/* Each modifier cannot appear more than once. */
/* ParamFldMods ::= (ParamFldMod w)+ */
List<Modifier> ParamFldMods = a1s:(ParamFldMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* ParamFldMod ::= var | hidden | settable | wrapped */
private Modifier ParamFldMod =
     var      { yyValue = new ModifierVar(createSpan(yyStart,yyCount)); }
   / hidden   { yyValue = new ModifierHidden(createSpan(yyStart,yyCount)); }
   / settable { yyValue = new ModifierSettable(createSpan(yyStart,yyCount)); }
   / wrapped  { yyValue = new ModifierWrapped(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* FldMods ::= (FldMod w)+ */
List<Modifier> FldMods = a1s:(FldMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* FldMod ::= var | AbsFldMod */
private Modifier FldMod =
     var { yyValue = new ModifierVar(createSpan(yyStart,yyCount)); }
   / AbsFldMod ;

/* Each modifier cannot appear more than once. */
/* AbsFldMods ::= (AbsFldMod w)+ */
List<Modifier> AbsFldMods = a1s:(AbsFldMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* AbsFldMod ::= ApiFldMod | wrapped | private */
private Modifier AbsFldMod =
     ApiFldMod
   / wrapped { yyValue = new ModifierWrapped(createSpan(yyStart,yyCount)); }
   / private { yyValue = new ModifierPrivate(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* ApiFldMods ::= (ApiFldMod w)+ */
List<Modifier> ApiFldMods = a1s:(ApiFldMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* ApiFldMod ::= hidden | settable | test */
private Modifier ApiFldMod =
     hidden   { yyValue = new ModifierHidden(createSpan(yyStart,yyCount)); }
   / settable { yyValue = new ModifierSettable(createSpan(yyStart,yyCount)); }
   / test     { yyValue = new ModifierTest(createSpan(yyStart,yyCount)); };

/* StaticParams ::= [\ w StaticParamList w \] */
List<StaticParam> StaticParams =
     opendoublesquare w StaticParamList w closedoublesquare ;

/* StaticParamList ::= StaticParam (w , w StaticParam)* */
private List<StaticParam> StaticParamList =
     a1:StaticParam a2s:(w comma w StaticParam)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* StaticParam ::=
     Id (w Extends)? (w absorbs w unit)?
   | nat w Id
   | int w Id
   | bool w Id
   | dim w Id
   | unit w Id (w : w DimExpr)? (w absorbs w unit)?
   | opr w Op
*/
private StaticParam StaticParam =
     a1:Id a2:(w Extends)? a3:(w absorbs w unit)?
     { if (a2 == null) a2 = Collections.<TraitType>emptyList();
       boolean absorbs;
       if (a3 == null) absorbs = false;
       else            absorbs = true;
       yyValue = new SimpleTypeParam(createSpan(yyStart,yyCount),a1,a2,absorbs);
     }
   / nat  w a1:Id { yyValue = new NatParam(createSpan(yyStart,yyCount), a1); }
   / int  w a1:Id { yyValue = new IntParam(createSpan(yyStart,yyCount), a1); }
   / bool w a1:Id { yyValue = new BoolParam(createSpan(yyStart,yyCount), a1); }
   / dim  w a1:Id {yyValue = new DimensionParam(createSpan(yyStart,yyCount),a1);}
   / unit w a1:Id a2:(w colon w DimExpr)? a3:(w absorbs w unit)?
     { Option<DimExpr> derived = Option.wrap(a2);
       boolean absorbs = (a3 == null) ? false : true;
       yyValue = new UnitParam(createSpan(yyStart,yyCount),a1,derived,absorbs);
     }
   / opr  w a1:Op {yyValue = new OperatorParam(createSpan(yyStart,yyCount),a1);};
