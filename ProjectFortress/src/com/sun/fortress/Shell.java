/*******************************************************************************
    Copyright 2008,2010, Oracle and/or its affiliates.
    All rights reserved.


    Use is subject to license terms.

    This distribution may include materials developed by third parties.

 ******************************************************************************/

package com.sun.fortress;

import com.sun.fortress.repository.CacheBasedRepository;
import com.sun.fortress.repository.FortressRepository;
import com.sun.fortress.repository.GraphRepository;
import com.sun.fortress.repository.ProjectProperties;
import java.io.*;
import java.util.*;

import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;

import com.sun.fortress.compiler.*;
import com.sun.fortress.exceptions.shell.UserError;
import com.sun.fortress.exceptions.CompilerBug;
import com.sun.fortress.exceptions.InterpreterBug;
import com.sun.fortress.exceptions.MultipleStaticError;
import com.sun.fortress.exceptions.LabelException;
import com.sun.fortress.exceptions.StaticError;
import com.sun.fortress.exceptions.WrappedException;
import com.sun.fortress.exceptions.ProgramError;
import com.sun.fortress.exceptions.FortressException;
import com.sun.fortress.exceptions.ParserError;
import com.sun.fortress.exceptions.shell.RepositoryError;
import com.sun.fortress.compiler.Parser;
import com.sun.fortress.compiler.index.ComponentIndex;
import com.sun.fortress.compiler.phases.Phase;
import com.sun.fortress.compiler.phases.PhaseOrder;
import com.sun.fortress.nodes.Api;
import com.sun.fortress.nodes.APIName;
import com.sun.fortress.nodes.CompilationUnit;
import com.sun.fortress.nodes.Component;
import com.sun.fortress.nodes.Node;
import com.sun.fortress.nodes_util.NodeFactory;
import com.sun.fortress.nodes_util.NodeUtil;
import com.sun.fortress.nodes_util.ASTIO;
import com.sun.fortress.interpreter.Driver;
import com.sun.fortress.interpreter.evaluator.Init;
import com.sun.fortress.interpreter.evaluator.values.FValue;
import com.sun.fortress.useful.Path;
import com.sun.fortress.useful.Debug;
import com.sun.fortress.useful.Files;
import com.sun.fortress.useful.Useful;
import com.sun.fortress.tests.unit_tests.FileTests;
import com.sun.fortress.tools.FortressAstToConcrete;
import com.sun.fortress.nodes_util.ApiMaker;

public final class Shell {
    public static final String turnOnDebugMessage =
        "Turn on \"-debug interpreter\" for Java-level stack trace.";

    /* This object groups in one place all the public static flags that
     * we had lying around before.  To set a flag on / off, one must
     * invoke its corresonding static method in Shell to do so.
     * This approach works better with JUnit.  We have seen weird behaviors
     * when using public static variables with JUnit tests.
     */
    private static CompileProperties compileProperties = new CompileProperties();

    /* set this statically if you only want to run up to a certain phase */
    private static PhaseOrder[] finalPhaseOrder = null;

    private static final String defaultRepositoryDir = ProjectProperties.ANALYZED_CACHE_DIR;
    private static final CacheBasedRepository defaultCache = new CacheBasedRepository(defaultRepositoryDir);
    private static final String interpreterRepositoryDir = ProjectProperties.INTERPRETER_PARSED_CACHE_DIR;
    private static final CacheBasedRepository interpreterCache = new CacheBasedRepository(interpreterRepositoryDir);

    private final FortressRepository _repository;

    protected static FortressRepository CURRENT_INTERPRETER_REPOSITORY = null;

    public Shell(FortressRepository repository) { _repository = repository; }

    public FortressRepository getRepository() {
        return _repository;
    }
   
    public static void setPhaseOrder( PhaseOrder[] order ){
        finalPhaseOrder = order;
    }

    /**
     * This is used to communicate, clumsily, with parsers generated by syntax expansion.
     * The interface should be improved.
    */
    public static void setCurrentInterpreterRepository( FortressRepository g ){
        CURRENT_INTERPRETER_REPOSITORY = g;
    }

    private static GraphRepository specificRepository(Path p, CacheBasedRepository cache ) throws IOException {
        GraphRepository fr = new GraphRepository( p, cache );
        CURRENT_INTERPRETER_REPOSITORY = fr;
        return fr;
    }

    public static GraphRepository specificRepository(Path p) throws IOException {
        return specificRepository( p, defaultCache);
    }

    public static GraphRepository specificInterpreterRepository(Path p) throws IOException {
        return specificRepository( p, interpreterCache);
    }

    public static void resetRepository() throws IOException {
        if (CURRENT_INTERPRETER_REPOSITORY != null) {
            CURRENT_INTERPRETER_REPOSITORY.clear();
        }
        File cache = new File(ProjectProperties.REPOSITORY + File.separator + "caches");
        System.err.println("Deleting cache " + cache.getName());
        removeFiles(cache);
    }

    private static void removeFiles(File file) throws IOException {
        if (file.exists() && file.isDirectory()) {
            for (File f : file.listFiles()) {
                removeFiles(f);
            }
        }
        else if (file.exists() && ! file.isDirectory()) {
            if (! file.delete())
                throw new IOException();
        }

    }

    /* Helper method to print usage message.*/
    private static void printUsageMessage() {
        System.err.println("Usage:");
        System.err.println(" parse [-out file] [-debug [type]* [#]] somefile.fs{s,i}");
        System.err.println(" disambiguate [-compiler-lib] [-out file] [-debug [type]* [#]] somefile.fs{s,i}");
        System.err.println(" desugar [-compiler-lib] [-out file] [-debug [type]* [#]] somefile.fs{s,i}");
        System.err.println(" grammar [-compiler-lib] [-out file] [-debug [type]* [#]] somefile.fs{s,i}");
        System.err.println(" typecheck [-compiler-lib] [-out file] [-debug [type]* [#]] somefile.fs{s,i}");
        System.err.println(" compile [-out file] [-debug [type]* [#]] somefile.fs{s,i}");
        System.err.println(" link [-debug [type]* [#]] somecomponent[.fss]");
        System.err.println(" build [-debug [type]* [#]] somecomponent[.fss]");
        System.err.println(" run somecomponent");
        System.err.println(" [walk] [-compiler-lib] [-debug [type]* [#]] somefile.fss arg...");
        System.err.println(" test [-verbose] [-debug [type]* [#]] somefile.fss...");
        System.err.println(" junit [-debug [type]* [#]] sometest.test...");
        System.err.println("");
        System.err.println(" api [-out file] [-prepend prependFile] [-debug [type]* [#]] somefile.fss");
        System.err.println(" compare [-debug [type]* [#]] somefile.fss anotherfile.fss");
        System.err.println(" unparse [-unqualified] [-unmangle] [-out file] [-debug [type]* [#]] somefile.tf{s,i}");
        System.err.println("");
        System.err.println(" expand property");
        System.err.println("");
        System.err.println(" help");
    }

    private static void printHelpMessage() {
        System.err.println
        ("Invoked as script: fortress args\n"+
         "Invoked by java: java ... com.sun.fortress.Shell args\n"+
         "\n"+
         "fortress parse [-out file] [-debug [type]* [#]] somefile.fs{i,s}\n"+
         "  Parses a file. If parsing succeeds the message \"Ok\" will be printed.\n"+
         "  If -out file is given, a message about the file being written to will be printed.\n"+
         "\n"+
         "fortress disambiguate [-compiler-lib] [-out file] [-debug [type]* [#]] somefile.fs{i,s}\n"+
         "  Disambiguates a file.\n"+
         "  If -out file is given, a message about the file being written to will be printed.\n"+
         "\n"+
         "fortress desugar [-compiler-lib] [-out file] [-debug [#]] somefile.fs{i,s}\n"+
         "  Desugars a file.\n"+
         "  If -out file is given, a message about the file being written to will be printed.\n"+
         "\n"+
         "fortress grammar [-compiler-lib] [-out file] [-debug [#]] somefile.fs{i,s}\n"+
         "  Rewrites syntax grammars in a file.\n"+
         "  If -out file is given, a message about the file being written to will be printed.\n"+
         "\n"+
         "fortress typecheck [-compiler-lib] [-out file] [-debug [#]] somefile.fs{i,s}\n"+
         "  Typechecks a file. If type checking succeeds no message will be printed.\n"+
         "\n"+
         "fortress compile [-out file] [-debug [type]* [#]] somefile.fs{s,i}\n"+
         "  Compiles somefile. If compilation succeeds no message will be printed.\n"+
         "\n"+
         "fortress link [-debug [type]* [#]] somecomponent[.fss]\n"+
         "  Links compiled components implementing APIs imported by somecomponent.\n"+
         "\n"+
         "fortress build [-debug [type]* [#]] somecomponent[.fss]\n"+
         "  Builds and links components implementing APIs imported by somecomponent.\n"+
         "\n"+
         "fortress run somecomponent\n"+
         "  Runs the compiler-generated bytecode for somecomponent.\n"+
         "\n"+
         "fortress [walk] [-compiler-lib] [-debug [type]* [#]] somefile.fss arg ...\n"+
         "  Runs somefile.fss through the Fortress interpreter, passing arg ... to the\n"+
         "  run method of somefile.fss.\n"+
         "\n"+
         "fortress test [-verbose] [-debug [type]* [#]] somefile.fss ...\n"+
         "  Runs the functions with the test modifier in the specified components \n"+
         "  If -verbose is set, the name of each test function is printed before and after running the function\n"+
         "\n"+
         "fortress junit [-debug [type]* [#]] somefile1.test ...\n"+
         "  Runs the system test file(s) somefile1.test (etc) in a junit textui harness.\n"+
         "\n"+
         "\n"+
         "fortress api [-out file] [-prepend prependFile] [-debug [type]* [#]] somefile.fss\n"+
         "  Automatically generate an API from a component.\n"+
         "  If -out file is given, a message about the file being written to will be printed.\n"+
         "  If -prepend prependFile is given, the prependFile is prepended to the generated API.\n"+
         "\n"+
         "fortress compare [-debug [type]* [#]] somefile.fss anotherfile.fss\n"+
         "  Compare results of two components.\n"+
         "\n"+
         "fortress unparse [-unqualified] [-unmangle] [-out file] [-debug [type]* [#]] somefile.tf{i,s}\n"+
         "  Convert a parsed file back to Fortress source code. The output will be dumped to stdout if -out is not given.\n"+
         "  If -unqualified is given, identifiers are dumped without their API prefixes.\n"+
         "  If -unmangle is given, internally mangled identifiers are unmangled.\n"+
         "  If -out file is given, a message about the file being written to will be printed.\n"+
         "\n"+
         "fortress expand property\n"+
         "  Prints the contents of the given property name from the local Fortress repository.\n"+
         "\n"+
         "\n"+
         "More details on each flag:\n"+
         "   -out file : dumps the processed abstract syntax tree to a file.\n"+
         "   -debug : enables debugging to the maximum level (99) for all \n"+
         "            debugging types and prints java stack traces.\n"+
         "   -debug # : sets debugging to the specified level, where # is a number, \n"+
         "            and sets all debugging types on.\n"+
         "   -debug types : sets debugging types to the specified types with \n"+
         "            the maximum debugging level. \n" +
         "   -debug types # : sets debugging to the specified level, where # is a number, \n"+
         "            and the debugging types to the specified types. \n" +
         "   The acceptable debugging types are:\n"+
         "            " + Debug.typeStrings() + "\n"+
         "\n"
        );
    }

    public static boolean withMacro() {
        return compileProperties.macro;
    }

    public static boolean getTypeChecking() {
        return compileProperties.type_check;
    }

    public static boolean getScala() {
        return compileProperties.use_scala;
    }

    public static boolean testCoercion() {
        return compileProperties.test_coercion;
    }

    public static boolean getObjExprDesugaring(){
        return compileProperties.objExpr_desugar;
    }

    public static boolean getGetterSetterDesugaring(){
        return compileProperties.getter_setter_desugar;
    }

    public static boolean getAssignmentDesugaring(){
        return compileProperties.use_scala && compileProperties.assignment_desugar;
    }

    public static boolean getAssignmentPreDesugaring(){
        return compileProperties.assignment_pre_desugar;
    }

    public static boolean getExtendsObjectPreDesugaring(){
        return compileProperties.extendsObject_pre_desugar;
    }

    public static boolean getCoercionDesugaring(){
        return compileProperties.use_scala && compileProperties.coercion_desugar;
    }

    public static boolean getChainExprDesugaring(){
        return compileProperties.use_scala && compileProperties.chainexpr_desugar;
    }
    
    public static boolean getCompiledExprDesugaring(){
        return compileProperties.compiled_expr_desugarer;
    }

    public static void setMacro(boolean macro) {
        compileProperties.macro = macro;
    }

    public static void setTypeChecking(boolean type_check) {
        compileProperties.type_check = type_check;
    }

    public static void setScala(boolean use_scala){
        compileProperties.use_scala = use_scala;
    }

    public static void setTestCoercion(boolean test_coercion) {
        compileProperties.test_coercion = test_coercion;
    }

    public static void setObjExprDesugaring(boolean desugar){
        compileProperties.objExpr_desugar = desugar;
    }

    public static void setGetterSetterDesugaring(boolean desugar){
        compileProperties.getter_setter_desugar = desugar;
    }

    public static void setAssignmentDesugaring(boolean desugar){
        compileProperties.assignment_desugar = desugar;
    }

    public static void setAssignmentPreDesugaring(boolean desugar){
        compileProperties.assignment_pre_desugar = desugar;
    }

    public static void setExtendsObjectPreDesugaring(boolean desugar){
        compileProperties.extendsObject_pre_desugar = desugar;
    }

    public static void setCoercionDesugaring(boolean desugar){
        compileProperties.coercion_desugar = desugar;
    }

    public static void setChainExprDesugaring(boolean desugar){
        compileProperties.chainexpr_desugar = desugar;
    }

    public static void setCompiledExprDesugaring(boolean desugar) {
    	compileProperties.compiled_expr_desugarer = desugar;
    }
    
    /**
     * Main entry point for the fortress shell.
     * In order to support accurate testing of error messages, this method immediately
     * forwards to its two parameter helper method.
     * *** Please do not directly add code to this method, as it will interfere with testing.
     * *** Tests will silently fail.
     * *** Instead, add code to its helper method.
     */
    public static void main(String[] tokens) throws InterruptedException, Throwable {
        main(false, tokens);
    }

    /* Helper method that allows main to be called from tests
     * (without having to worry about System.exit).
     */
    public static void main(boolean runFromTests, String[] tokens) throws InterruptedException, Throwable {
        if (tokens.length == 0) {
            printUsageMessage();
            if (! runFromTests) { System.exit(-1); }
            else { return; }
        }

        int return_code = subMain(tokens);


        if (return_code != 0) {
            if (! runFromTests) { System.exit(return_code); }
            else { return; }
        }
    }

    public static void useCompilerLibraries() {
	setExtendsObjectPreDesugaring(true);
	setAssignmentPreDesugaring(false);
	setAssignmentDesugaring(true);
        WellKnownNames.useCompilerLibraries();
        Types.useCompilerLibraries();
    }

    public static void useInterpreterLibraries() {
	setExtendsObjectPreDesugaring(false};
	setAssignmentPreDesugaring(false);
	setAssignmentDesugaring(true);
	setCompiledExprDesugaring(false);
        WellKnownNames.useFortressLibraries();
        Types.useFortressLibraries();
    }


    /**
     * @param tokens
     * @return
     * @throws InterruptedException
     * @throws Throwable
     */
    public static int subMain(String[] tokens) throws InterruptedException,
            Throwable {
        int return_code = 0;

        // Now match the assembled string.
        try {
            String what = tokens[0];
            List<String> args = Arrays.asList(tokens).subList(1, tokens.length);
            if (what.equals("compile")) {
                useCompilerLibraries();
                setTypeChecking(true);
                setPhaseOrder( PhaseOrder.compilerPhaseOrder );
                return_code = compilerPhases(args, Option.<String>none(), what);
            } else if (what.equals("junit")) {
                return_code = junit(args);
            } else if (what.equals("link")) {
                useCompilerLibraries();
                setTypeChecking(true);
                setPhaseOrder( PhaseOrder.compilerPhaseOrder );
                return_code = link(args);
            } else if (what.equals("build")) {
                useCompilerLibraries();
                setTypeChecking(true);
                setPhaseOrder( PhaseOrder.compilerPhaseOrder );
                return_code = link(args);
            } else if (what.equals("walk")) {
                useInterpreterLibraries();
                setScala(false);
                setPhaseOrder( PhaseOrder.interpreterPhaseOrder );
                walk(args);
            } else if ( what.equals("api" ) ){
                useCompilerLibraries();
                api(args, Option.<String>none(), Option.<String>none());
            } else if ( what.equals("compare" ) ){
                useCompilerLibraries();
                compare(args);
            } else if ( what.equals("parse" ) ){
                useCompilerLibraries();
                return_code = parse(args, Option.<String>none());
            } else if ( what.equals("unparse" ) ){
                useCompilerLibraries();
                unparse(args, Option.<String>none(), false, false);
            } else if ( what.equals( "disambiguate" ) ){
                useCompilerLibraries();
                setPhaseOrder( PhaseOrder.disambiguatePhaseOrder );
                return_code = compilerPhases(args, Option.<String>none(), what);
            } else if ( what.equals( "desugar" ) ){
                useCompilerLibraries();
                setTypeChecking(true);
                setObjExprDesugaring(true);
                setPhaseOrder( PhaseOrder.desugarPhaseOrder );

                return_code = compilerPhases(args, Option.<String>none(), what);
            } else if ( what.equals( "grammar" ) ){
                useCompilerLibraries();
                setPhaseOrder( PhaseOrder.grammarPhaseOrder );

                return_code = compilerPhases(args, Option.<String>none(), what);
            } else if (what.equals("typecheck")) {
                useCompilerLibraries();
                setTypeChecking(true);
                setPhaseOrder( PhaseOrder.typecheckPhaseOrder );

                return_code = compilerPhases(args, Option.<String>none(), what);
            } else if (what.equals("test-coercion")) {
                useCompilerLibraries();
                setTypeChecking(true);
                setPhaseOrder( PhaseOrder.typecheckPhaseOrder );

                return_code = compilerPhases(args, Option.<String>none(), what);
            } else if (what.equals("typecheck-old")) {
                useInterpreterLibraries();
                setScala(false);
                /* TODO: remove the next line once type checking is permanently turned on */
                setTypeChecking(true);
                setPhaseOrder( PhaseOrder.typecheckPhaseOrder );

                return_code = compilerPhases(args, Option.<String>none(), what);
            } else if (what.equals("test")) {
                useInterpreterLibraries();
                setScala(false);
                setPhaseOrder( PhaseOrder.interpreterPhaseOrder );
                walkTests(args, false);
            } else if (what.contains(ProjectProperties.COMP_SOURCE_SUFFIX)
                       || (what.startsWith("-") && tokens.length > 1)) {
                useInterpreterLibraries();
                setScala(false);
                setPhaseOrder( PhaseOrder.interpreterPhaseOrder );
                walk(Arrays.asList(tokens));
            } else if (what.equals("help")) {
                useCompilerLibraries();
                printHelpMessage();
            } else if (what.equals("expand") && tokens.length == 2) {
                System.out.println(ProjectProperties.get(tokens[1], ""));
            } else {
                useCompilerLibraries();
                printUsageMessage();
            }
        } catch (StaticError e) {
            System.err.println(e);
            if (Debug.stackTraceOn()) {
                e.printStackTrace();
            }
            return_code = -1;
        } catch (UserError error) {
            System.err.println(error.getMessage());
            return_code = -1;
        } catch (IOException error) {
            System.err.println(error.getMessage());
            return_code = -2;
        } catch (CompilerBug error) {
            System.err.println(error.getMessage());
            if (Debug.stackTraceOn()) {
                error.printStackTrace();
            }
            return_code = -3;
        }

        Init.allowForLeakChecks();
        return return_code;
    }

    private static void invalidFlag(String flag, String command)
        throws UserError {
        throw new UserError(flag + " is not a valid flag for `fortress " + command + "`");
    }

    /**
     * Automatically generate an API from a component.
     */
    private static void api(List<String> args, Option<String> out, Option<String> prepend)
        throws UserError, InterruptedException, IOException {
        if (args.size() == 0) {
            throw new UserError("Need a file to generate an API.");
        }
        String s = args.get(0);
        List<String> rest = args.subList(1, args.size());

        if (s.startsWith("-")) {
            if (s.equals("-debug")){
                rest = Debug.parseOptions(rest);
            }
            else if (s.equals("-out") && ! rest.isEmpty() ){
                out = Option.<String>some(rest.get(0));
                rest = rest.subList( 1, rest.size() );
            }
            else if (s.equals("-prepend") && ! rest.isEmpty() ){
                prepend = Option.<String>some(rest.get(0));
                rest = rest.subList( 1, rest.size() );
            }
            else
                invalidFlag(s, "api");
            api( rest, out, prepend );
        } else {
            api( s, out, prepend );
        }
    }

    private static void api( String file, Option<String> out, Option<String> prepend )
        throws UserError, IOException{
        if (! isComponent(file)) {
            throw new UserError( "The api command needs a Fortress component file; filename " +
                    file + " must end with .fss" );
        }
        Component c = (Component) Parser.parseFileConvertExn(new File(file));
        String logFile = file + ".api.log";
        Option<Node> result = c.accept( new ApiMaker(logFile) );
        File log = new File( logFile );
        if ( log.length() != 0 ) {
            System.err.println("To generate an API, the following types are required:");
            BufferedReader reader = Useful.filenameToBufferedReader( logFile );
            String line = reader.readLine();
            while ( line != null ) {
                System.err.println( line );
                line = reader.readLine();
            }
            try { Files.rm( logFile ); }
            catch (IOException e) {}
            throw new UserError("Missing types from the component.");
        }
        try { Files.rm( logFile ); }
        catch (IOException e) {}
        if ( result.isNone() )
            throw new UserError("The api command needs a Fortress component file.");
        Api a = (Api) result.unwrap();
        String code = a.accept( new FortressAstToConcrete() );
        if ( out.isSome() ){
            try{
                BufferedWriter writer = Useful.filenameToBufferedWriter(out.unwrap());
                if ( prepend.isSome() ) {
                    BufferedReader reader = Useful.filenameToBufferedReader(prepend.unwrap());
                    String line = reader.readLine();
                    while ( line != null ) {
                        writer.write( line + "\n" );
                        line = reader.readLine();
                    }
                }
                writer.write(code);
                writer.close();
                System.out.println( "Dumped code to " + out.unwrap() );
            } catch ( IOException e ){
                throw new IOException( "IOException " + e +
                        " while writing " + out.unwrap() );
            }
        } else {
            System.out.println( code );
        }
    }

    /**
     * Evaluate a given component and return its value.
     */
    public static FValue eval( String file, boolean unCacheWhenDone )
        throws Throwable {
        return eval( file, new ArrayList<String>(), unCacheWhenDone );
    }

    public static FValue eval( String file, List<String> args, boolean unCacheWhenDone )
        throws Throwable {
        setPhaseOrder( PhaseOrder.interpreterPhaseOrder );
        if ( ! isComponent(file) )
            throw new UserError(file + " is not a component file.");
        APIName name = NodeUtil.apiName( file );
        Path path = sourcePath( file, name );
        GraphRepository bcr = specificInterpreterRepository( path );
        ComponentIndex c =  bcr.getLinkedComponent(name);
        FValue result = Driver.runProgram(bcr, c, args);
        bcr.deleteComponent(c.ast().getName(), unCacheWhenDone);
        return result;
    }

    /**
     * Compare results of two components.
     */
    private static void compare(List<String> args)
        throws UserError, InterruptedException, IOException, Throwable {
        if (args.size() == 0) {
            throw new UserError("Need files to compare the results.");
        }
        String s = args.get(0);
        List<String> rest = args.subList(1, args.size());

        if (s.startsWith("-")) {
            if (s.equals("-debug")){
                rest = Debug.parseOptions(rest);
            }
            else
                invalidFlag(s, "compare");

            compare( rest );
        } else {
            if (args.size() == 1)
                throw new UserError("Need one more file to compare the results.");
            compare( s, args.get(1) );
        }
    }

    private static void compare( String first, String second )
        throws Throwable, IOException  {
        if ( ! (isComponent(first) && isComponent(second)) ) {
            throw new UserError("The compare command needs two component (.fss) files" +
                     "found " + first + "and " + second);
        }

        FValue value1 = eval( first, false );
        FValue value2 = eval( second, false );
        if (value1 == value2)
            System.out.println( "Compare: values are equal" );
        else System.out.println( "Compare failed: " +
                first + " evaluated to " + value1 +
                " but " + second + " evaluated to " + value2 );
    }

    /**
     * Parse a file. If the file parses ok it will say "Ok".
     * If you want a dump then give -out somefile.
     */
    private static int parse(List<String> args, Option<String> out)
        throws UserError, InterruptedException, IOException {
        if (args.size() == 0) {
            throw new UserError("Need a file to parse");
        }
        String s = args.get(0);
        List<String> rest = args.subList(1, args.size());

        if (s.startsWith("-")) {
            if (s.equals("-debug")){
                rest = Debug.parseOptions(rest);
            }
            else if (s.equals("-out") && ! rest.isEmpty() ){
                out = Option.<String>some(rest.get(0));
                rest = rest.subList( 1, rest.size() );
            }
            else
                invalidFlag(s, "parse");

            return parse( rest, out );
        } else {
            return parse( s, out );
        }
    }

    private static int parse( String file, Option<String> out) throws UserError, IOException {
        int return_code = 0;
        try{
            CompilationUnit unit = Parser.parseFileConvertExn(new File(file));
            System.out.println( "Ok" );
            if ( out.isSome() ){
                try{
                    ASTIO.writeJavaAst(unit, out.unwrap());
                    System.out.println( "Dumped parse tree to " + out.unwrap() );
                } catch ( IOException e ){
                    throw new IOException("IOException " + e +
                            "while writing " + out.unwrap() );
                }
            }
        } catch (ParserError e) {
            if (Debug.stackTraceOn()) {
                System.err.println(e.getMessage());
                e.printStackTrace();
            } else {
                System.err.println(turnOnDebugMessage);
            }
            return_code = 1;
        } catch (ProgramError e) {
            failureBoilerplate(e);
            return_code = 1;
        } catch (CompilerBug e) {
            failureBoilerplate(e);
            return_code = 1;
        } catch (InterpreterBug e) {
            failureBoilerplate(e);
            return_code = 1;
        } catch ( FileNotFoundException f ){
            throw new UserError(file + " not found");
        } finally {
            try { Files.rm( ProjectProperties.preparserErrorLog(file) ); }
            catch (IOException e) {}
        }
        return return_code;
    }

    /**
     * @param e
     */
    private static void failureBoilerplate(FortressException e) {
        System.err.println(e.getMessage());
        e.printInterpreterStackTrace(System.err);
        if (Debug.stackTraceOn()) {
            e.printStackTrace();
        } else {
            System.err.println(turnOnDebugMessage);
        }
        (new Throwable()).printStackTrace();
    }

    /**
     * UnParse a file.
     * If you want a dump then give -out somefile.
     */
    private static void unparse(List<String> args,
                                Option<String> out,
                                boolean _unqualified,
                                boolean _unmangle)
        throws UserError, InterruptedException, IOException {
        if (args.size() == 0) {
            throw new UserError("The unparse command needs a file to unparse.");
        }
        String s = args.get(0);
        List<String> rest = args.subList(1, args.size());
        boolean unqualified = _unqualified;
        boolean unmangle = _unmangle;

        if (s.startsWith("-")) {
            if (s.equals("-unqualified")){
                unqualified = true;
            }
            else if (s.equals("-unmangle")){
                unmangle = true;
            }
            else if (s.equals("-debug")){
                rest = Debug.parseOptions(rest);
            }
            else if (s.equals("-out") && ! rest.isEmpty() ){
                out = Option.<String>some(rest.get(0));
                rest = rest.subList( 1, rest.size() );
            }
            else
                invalidFlag(s, "unparse");

            unparse( rest, out, unqualified, unmangle );
        } else {
            unparse( s, out, unqualified, unmangle );
        }
    }

    private static void unparse( String file,
            Option<String> out,
            boolean unqualified,
            boolean unmangle )
    throws IOException {
        String code = ASTIO.readJavaAst( file ).unwrap().accept( new FortressAstToConcrete(unqualified,unmangle) );
        if ( out.isSome() ){
            try{
                BufferedWriter writer = Useful.filenameToBufferedWriter(out.unwrap());
                writer.write(code);
                writer.close();
            } catch ( IOException e ){
                throw new IOException("IOException " + e +
                        "while writing " + out.unwrap() );
            }
        } else {
            System.out.println( code );
        }
    }

    private static boolean isApi(String fileName){
        return fileName.endsWith(ProjectProperties.API_SOURCE_SUFFIX);
    }

    private static boolean isComponent(String fileName){
        return fileName.endsWith(ProjectProperties.COMP_SOURCE_SUFFIX);
    }

    private static APIName cuName( String fileName ){
        if ( fileName.endsWith( ProjectProperties.COMP_SOURCE_SUFFIX ) ||
             fileName.endsWith( ProjectProperties.API_SOURCE_SUFFIX ) ){
            return NodeFactory.makeAPIName(NodeFactory.shellSpan,
                                           fileName.substring( 0, fileName.lastIndexOf(".") ));
        }
        return NodeFactory.makeAPIName(NodeFactory.shellSpan,fileName);
    }

    public static boolean checkCompilationUnitName(String filename,
                                                   String cuname) {
        String rootName = filename.substring( 0, filename.lastIndexOf(".") );
        rootName = rootName.replace('/','.');
        rootName = rootName.replace('\\','.');
        String regex = "(.*\\.)?" + cuname.replace(".", "\\.") + "$";
        Debug.debug( Debug.Type.REPOSITORY, 3,
                     "Checking file name ", rootName, " vs cuname ", regex );
        return rootName.matches( regex );
    }

    /**
     * Compile a file.
     * If you want a dump then give -out somefile.
     */
    public static int compilerPhases(List<String> args, Option<String> out, String phase)
        throws UserError, InterruptedException, IOException, RepositoryError {
        int return_code = 0;
        if (args.size() == 0) {
            throw new UserError("The " + phase + " command must be given a file.");
        }
        String s = args.get(0);
        List<String> rest = args.subList(1, args.size());

        if (s.startsWith("-")) {
            if (s.equals("-debug")){
                rest = Debug.parseOptions(rest);
            }
            else if (s.equals("-out") && ! rest.isEmpty() ){
                out = Option.<String>some(rest.get(0));
                rest = rest.subList( 1, rest.size() );
            }
            else if (s.equals("-compiler-lib")) {
                WellKnownNames.useCompilerLibraries();
                Types.useCompilerLibraries();
            }
            else if (s.equals("-typecheck-java")) {
                setScala(false);
            }
            else if (s.equals("-coercion")) {
                setTestCoercion(true);
            }
            else
                invalidFlag(s, phase);
            return_code = compilerPhases(rest, out, phase);
        } else {
            return_code = compileWithErrorHandling(s, out, false);
        }
        return return_code;
    }

    /**
     * @param out
     * @param path
     * @param file_name
     * @param doLink
     * @return
     * @throws UserError
     * @throws IOException
     */
    private static int compileWithErrorHandling(String s, Option<String> out,
                                                boolean doLink)
            throws UserError, IOException {
        int return_code = 0;
        try {
            APIName name = NodeUtil.apiName( s );
            Path path = sourcePath( s, name );
            String file_name = name.toString() + (s.endsWith(".fss") ? ".fss" : ".fsi");

            List<StaticError> errors = new ArrayList<StaticError>();
            for ( StaticError error : IterUtil.sort(compilerPhases(path, file_name, out, doLink),
                                                    StaticError.comparator) ) {
                if ( ! error.toString().equals("") )
                    errors.add( error );
            }
            return_code = reportErrors(errors, file_name);
        } catch (StaticError e) {
            return_code = reportErrors(flattenErrors(e), new File(s).getName());
        } catch (ProgramError e) {
            System.err.println(e.getMessage());
            e.printInterpreterStackTrace(System.err);
            if (Debug.stackTraceOn()) {
                e.printStackTrace();
            } else {
                System.err.println(turnOnDebugMessage);
            }
            return_code = 1;
        }
        return return_code;
    }

    private static int reportErrors(List<? extends StaticError> errors, String file_name) {
        int num_errors = IterUtil.sizeOf(errors);
        if ( !IterUtil.isEmpty(errors) ) {
            for (StaticError error: errors) {
                System.err.println(error);
            }
            String err_string;
            if (num_errors == 0) {
                err_string = "File " + file_name + " compiled successfully.";
            } else {
                err_string = "File " + file_name + " has " + num_errors + " error" +
                    (num_errors == 1 ? "." : "s.");
            }
            System.err.println(err_string);
            return -1;
        } else return 0;
    }

    /**
     * Compile a file.
     */
    public static Iterable<? extends StaticError> compilerPhases(Path path,
                                                                 String file)
        throws UserError {
        return compilerPhases(path, file, Option.<String>none(), false);
    }

    private static Iterable<? extends StaticError> compilerPhases(Path path,
                                                                  String file,
                                                                  Option<String> out,
                                                                  boolean link)
        throws UserError {
        GraphRepository bcr = null;
        Debug.debug( Debug.Type.FORTRESS, 2, "Compiling file ", file );
        APIName name = null;
        try {
            bcr = specificRepository(path);
            name = cuName(file);

            if (isApi(file)) {
                Api a = (Api) bcr.getApi(name).ast();
                if ( out.isSome() )
                    ASTIO.writeJavaAst(a, // defaultRepository.getApi(name).ast(),
                            out.unwrap());
            } else if (isComponent(file)) {
                Component c;
                if (link)
                    c = (Component) bcr.getLinkedComponent(name).ast();
                else
                    c = (Component) bcr.getComponent(name).ast();
                if (out.isSome()) {
                    ASTIO.writeJavaAst(c, // defaultRepository.getComponent(name).ast(),
                                       out.unwrap());
                    bcr.deleteComponent( name, true );
                }
            } else {
                throw new UserError( "What kind of file is " + file +
                                    "? Name should end with .fsi or .fss." );
            }
        } catch (ProgramError pe) {
            Iterable<? extends StaticError> se = pe.getStaticErrors();
            if (se == null)
                return IterUtil.singleton(new WrappedException(pe, Debug.stackTraceOn()));
            else
                return flattenErrors(se);
        } catch (RepositoryError ex) {
            throw ex;
        } catch (FileNotFoundException ex) {
            throw new WrappedException(ex);
        } catch (IOException e) {
            throw new WrappedException(e);
        } catch (StaticError ex) {
            return flattenErrors(ex);
        } catch (CompilerBug e) {
            return IterUtil.singleton(new WrappedException(e, Debug.stackTraceOn()));
        } catch (InterpreterBug e) {
            return IterUtil.singleton(new WrappedException(e, Debug.stackTraceOn()));
        } catch (FortressException e) {
             failureBoilerplate(e);
             System.exit(1);
        } finally {
            if (bcr != null && name != null)
             bcr.deleteComponent(name, false);
        }

        if (bcr != null && bcr.verbose())
            System.err.println("Compiling done.");

        return IterUtil.empty();
    }

    private static List<? extends StaticError> flattenErrors(Iterable<? extends StaticError> ex) {
        List<StaticError> result = new LinkedList<StaticError>();
        for ( StaticError err : ex ) {
            result.addAll( flattenErrors(err) );
        }
        return result;
    }

    private static List<? extends StaticError> flattenErrors(StaticError ex) {
        List<StaticError> result = new LinkedList<StaticError>();
        if ( ex instanceof MultipleStaticError ) {
            for ( StaticError err : (MultipleStaticError)ex )
                result.addAll( flattenErrors(err) );
        } else result.add(new WrappedException(ex, Debug.stackTraceOn()));
        return result;
    }

    public static void assertStaticErrors(Iterable<? extends StaticError> errors,
                                         String expected) throws UserError {
        errors = IterUtil.sort(errors, StaticError.comparator);
        StringBuilder buf = new StringBuilder();
        for ( StaticError error : errors ) {
            buf.append(error.getMessage() + "\n");
        }
        String message = buf.toString();
        message = message.substring(0,message.length()-1);
        if ( ! message.equals(expected) )
            throw new UserError("Bad error message: " + message + "\n" +
                                "Should be: " + expected);
    }

    /**
     * Link compiled components implementing APIs imported by the given component.
     */
    private static int link(List<String> args) throws UserError, IOException {
        if (args.size() == 0) {
            throw new UserError("Need a file to link.");
        }
        String s = args.get(0);
        List<String> rest = args.subList(1, args.size());

        if (s.startsWith("-")) {
            if (s.equals("-debug")){
                rest = Debug.parseOptions(rest);
            }
            else
                invalidFlag(s, "link");
            return link(rest);
        } else {
            if (! s.endsWith(".fss")) {
                s = s + ".fss";
            }

            return compileWithErrorHandling( s, Option.<String>none(), true );
        }
    }

    /**
     * Link compiled components implementing APIs imported by the given component.
     */
    private static int junit(List<String> args) throws UserError, IOException {
        if (args.size() == 0) {
            throw new UserError("Need a file to run junit tests.");
        }
        String s = args.get(0);
        List<String> rest = args.subList(1, args.size());

        if (s.startsWith("-")) {
            if (s.equals("-debug")){
                rest = Debug.parseOptions(rest);
            }
            else
                invalidFlag(s, "junit");
            return junit(rest);
        }

        junit.textui.TestRunner.run(FileTests.suiteFromListOfFiles(args, "","","",false, false));

        return 0;

    }

    /**
     * Run a file through the Fortress interpreter.
     */
    private static void walk(List<String> args)
        throws UserError, IOException, Throwable {
        if (args.size() == 0) {
            throw new UserError("Need a file to run through the Fortress interpreter.");
        }
        String s = args.get(0);
        List<String> rest = args.subList(1, args.size());

        if (s.startsWith("-")) {
            if (s.equals("-debug")){
                rest = Debug.parseOptions(rest);
            }
            else if (s.equals("-compiler-lib")) {
                WellKnownNames.useCompilerLibraries();
                Types.useCompilerLibraries();
            }
            else
                invalidFlag(s, "walk");

            walk(rest);
        } else {
            walk(s, rest);
        }
    }

    private static void walk(String fileName, List<String> args)
        throws UserError, Throwable {
        try {
            Iterable<? extends StaticError> errors = IterUtil.empty();
            try {
                eval( fileName, args, false);
            } catch (Throwable th) {
                // TODO FIXME what is the proper treatment of errors/exceptions etc.?
                if (th instanceof FortressException) {
                    FortressException pe = (FortressException) th;
                    if (pe.getStaticErrors() != null)
                        errors = pe.getStaticErrors();
                }
                if (th instanceof RuntimeException)
                    throw (RuntimeException) th;
                if (th instanceof Error)
                    throw (Error) th;
                throw new WrappedException(th, Debug.stackTraceOn());
            }

            if ( !IterUtil.isEmpty(errors) ) {
                for (StaticError error: errors) {
                    System.err.println(error);
                }
                System.exit(-1);
            }
            // If there are no errors,
            // all components will have been written to disk
            // by the CacheBasedRepository.
        } catch ( StaticError e ){
            System.err.println(e);
            if ( Debug.stackTraceOn() ){
                e.printStackTrace();
            }
            System.exit(-1);
        } catch (RepositoryError e) {
            throw e;
        } catch (LabelException e) {
            System.err.println(e.getMessage());
            if (Debug.stackTraceOn()) {
                e.printStackTrace();
            } else {
                System.err.println(turnOnDebugMessage);
            }
            System.exit(1);
        } catch (FortressException e) {
            failureBoilerplate(e);
            System.exit(1);
        }
    }

    /* find the api name for a file and chop it off the source path.
     * what remains from the source path is the directory that contains
     * the file( including sub-directories )
     */
    public static Path sourcePath( String file, APIName name ) throws IOException {
        Debug.debug( Debug.Type.REPOSITORY, 2, "True api name is ", name );
        String fullPath = new File(file).getCanonicalPath();
        Debug.debug( Debug.Type.REPOSITORY, 2, "Path is ", fullPath );
        Path path = ProjectProperties.SOURCE_PATH;
        /* the path to the file is /absolute/path/a/b/c/foo.fss and the apiname is
         * a.b.c.foo, so we need to take off the apiname plus four more characters,
         * ".fss" or ".fsi"
         */
        String source = fullPath.substring( 0, fullPath.length() - (name.toString().length() + 4) );
        path = path.prepend( source );
        Debug.debug( Debug.Type.REPOSITORY, 2, "Source path is ", source );
        Debug.debug( Debug.Type.REPOSITORY, 2, "Lookup path is ", path );
        return path;
    }

    private static void walkTests(List<String> args, boolean verbose)
        throws UserError, IOException, Throwable {
        boolean _verbose = verbose;
        if (args.size() == 0) {
            throw new UserError("Need a file to run through the Fortress interpreter.");
        }
        String s = args.get(0);
        List<String> rest = args.subList(1, args.size());

        if (s.startsWith("-")) {
            if (s.equals("-debug")){
                rest = Debug.parseOptions(rest);
            }
            else if (s.equals("-verbose")){
                _verbose = true;
            }
            else
                invalidFlag(s, "test");
            walkTests(rest, _verbose);
        } else {
            for (String file : args) {
                try {
                    Iterable<? extends StaticError> errors = IterUtil.empty();
                    try {
                        if ( ! isComponent(file) )
                            throw new UserError(file + " is not a component file.");
                        APIName name = NodeUtil.apiName( file );
                        Path path = sourcePath( file, name );
                        GraphRepository bcr = specificInterpreterRepository( path );
                        ComponentIndex cu =  bcr.getLinkedComponent(name);
                        Driver.runTests(bcr, cu, _verbose);
                    } catch (Throwable th) {
                        // TODO FIXME what is the proper treatment of errors/exceptions etc.?
                        if (th instanceof FortressException) {
                            FortressException pe = (FortressException) th;
                            if (pe.getStaticErrors() != null)
                                errors = pe.getStaticErrors();
                        }
                        if (th instanceof RuntimeException)
                            throw (RuntimeException) th;
                        if (th instanceof Error)
                            throw (Error) th;
                        throw new WrappedException(th, Debug.stackTraceOn());
                    }

                    for (StaticError error: errors) {
                        System.err.println(error);
                    }
                    // If there are no errors,
                    // all components will have been written to disk
                    // by the CacheBasedRepository.
                } catch ( StaticError e ){
                    System.err.println(e);
                    if ( Debug.stackTraceOn() ){
                        e.printStackTrace();
                    }
                } catch (RepositoryError e) {
                    System.err.println(e.getMessage());
                } catch (FortressException e) {
                    failureBoilerplate(e);
                    System.exit(1);
                }
            }
        }
    }

    /* run all the analysis available */
    public static AnalyzeResult analyze(final FortressRepository repository,
                                        final GlobalEnvironment env,
                                        Iterable<Api> apis,
                                        Iterable<Component> components,
                                        final long lastModified) throws StaticError {
        Phase ph = 
            PhaseOrder.makePhaseOrder(finalPhaseOrder, repository, env, apis, components, lastModified);
        AnalyzeResult result = ph.run();
        Debug.debug(Debug.Type.FORTRESS, 1, "All phases done");
        return result;
    }

    /**
     * The fields of this class serve as temporary switches used for testing.
     */
    private static class CompileProperties {
        boolean macro = ProjectProperties.getBoolean("fortress.compile.macro", true);    // run syntax abstraction or not
        boolean type_check = ProjectProperties.getBoolean("fortress.compile.typecheck", false); // run type checker or not
        boolean objExpr_desugar = ProjectProperties.getBoolean("fortress.compile.desugar.objexpr", false); // run obj expression desugaring or not
        boolean getter_setter_desugar = ProjectProperties.getBoolean("fortress.compile.desugar.getset", true); // run getter/setter desugaring or not
        boolean use_scala = ProjectProperties.getBoolean("fortress.compile.usescala",true); //use the scala typechecker
        boolean test_coercion = ProjectProperties.getBoolean("fortress.compile.testcoercion",false); // test coercion
        boolean assignment_desugar = ProjectProperties.getBoolean("fortress.compile.desugar.assignment",true); // run assignment desugaring or not
        boolean assignment_pre_desugar = ProjectProperties.getBoolean("fortress.compile.predesugar.assignment",false); // run predisambiguation assignment desugaring or not
        boolean extendsObject_pre_desugar = ProjectProperties.getBoolean("fortress.compile.predesugar.extendsobject",false); // run predisambiguation extendsObject desugaring or not
        boolean coercion_desugar = ProjectProperties.getBoolean("fortress.compile.desugar.coercion",true); // run coercion desugaring or not
        boolean chainexpr_desugar = ProjectProperties.getBoolean("fortress.compile.desugar.chainexpr",true); // run chain expr desugaring or not
        boolean compiled_expr_desugarer = true;
    }

}
