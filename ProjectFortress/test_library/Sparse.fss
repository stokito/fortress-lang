(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component Sparse
export Sparse

(*public*) trim[\T\](v:Array[\T,ZZ32\],l:ZZ32):Array[\T,ZZ32\] = array[\T\](l).assign(v)

(*public*) object SparseVector[\T, nat n\](mem:Array[\(ZZ32,T),ZZ32\])
  extends Vector[\T,n\]
    get(i:ZZ32):T = do
      b = mem.bounds().lower()
      lo:ZZ32 := -1
      hi:ZZ32 := mem.bounds().extent()
      while lo + 1 < hi do
        mid = (lo+hi) DIV 2
        (ii,_) = mem[b+mid]
        if ii <= i then lo := mid else hi := mid end
      end
      if lo>=0 then
        (ii,t) = mem[b+lo]
        if i=ii then t else 0.0 0.0 end
      else 0.0 0.0 end
    end
    indexValuePairs(): Generator[\(ZZ32,T)\] = mem
    put(i:ZZ32, v:T) = fail("SparseVector is immutable")
    scale(x:T):SparseVector[\T,n\] = do
      elt(i:ZZ32,t:(ZZ32,T)):T = do (j,y) = t; (j, x y) end
      SparseVector[\T,n\](mem.map(elt))
    end
    negate() = scale(-1)
    foldMatches[\U,R\](f:(ZZ32,T,U,R)->R, v: SparseVector[\U,n\],r:R):R = do
        i1: ZZ32 := 0
        t1 = v.mem.size()
        (j1: ZZ32, v1: T) := (-2, 0)
        res: T := r
        for i0 <- seq(0#mem.size()) do
            (j0,v0) = mem.get(i0)
            while j0>j1 AND i1<t1 do
                (j1,v1) := v.mem.get(i1)
                i1 += 1
            end
            if j0=j1 then
                res := f(j0,v0,v1,res)
            end
        end
        res
      end
    pmul(v: Vector[\T,n\]): SparseVector[\T,n\] =
        typecase v of
            SparseVector[\T,n\] =>
                if mem.size() > v.mem.size() then
                    v.pmul(self)
                else
                    res = mem.replica[\(ZZ32,T)\]()
                    f(i: ZZ32, x: T, y: T, entry: ZZ32) = do
                        res[entry] := (i, x y)
                        entry + 1
                      end
                    entries = foldMatches[\T,ZZ32\](f,v,0)
                    SparseVector[\T,n\](trim(res,entries))
                end
            else =>
                elt(i:ZZ32,t:(ZZ32,T)):T = do (j,x) = t; (j, x v.get(j)) end
                SparseVector[\T,n\](mem.map(elt))
        end
    toString():String = do
        elt(t:ZZ32,v:T):String = " " t "->" v
        join(a:String,b:String):String = a b
        "Sparse[" n "] = [" indexValuePairs().mapReduce[\String\](elt,join,"") "]"
     end
    dot(other:Vector[\T,n\]) =
        indexValuePairs().mapReduce[\T\](fn (i:ZZ32,v:T):T => v other[i], fn (a,b)=>a+b, 0)
    dot(other:SparseVector[\T,n\]) = do
        (* We perform sparse vector-vector multiply serially due to the
           absence of reduction variables, and the fact that this allows
           us to do it with linear work. *)
        f(i: ZZ32, x: T, y: T, r: T): T = r + x y
        foldMatches[\T,T\](f,other,0)
      end
end

(*public*) sparse[\T extends Number,nat n\](me:Array1[\RR64,0,n\]):SparseVector[\RR64,n\] = do
   sz = me.mapReduce[\ZZ32\](fn (v:RR64):ZZ32=>if v=0 then 0 else 1 end,
                             fn (a:ZZ32,b:ZZ32):ZZ32 => a+b, 0)
   res:Array[\(ZZ32,RR64),ZZ32\] := array[\(ZZ32,RR64)\](sz)
   j : ZZ32 := res.minIndex()
   for (i,v) <- seq(me.indexValuePairs().indices()) do
      if v =/= 0 then
         res[j] := (i,v)
         j += 1
      end
   end
   SparseVector[\RR64,n\](res)
end

(*public*) object Csr[\N extends Number, nat n, nat m\]
                 (rows:Array1[\SparseVector[\N,m\],0,n\])
  extends Matrix[\N,n,m\]
    get(t:(ZZ32,ZZ32)):N = do (i,j)=t; (rows[i])[j] end
    put(t:(ZZ32,ZZ32), v:N) = fail("Csr is immutable")
    replica[\U\]() = fail("Csr replica undefined")
    indexValuePairs():Generator[\((ZZ32,ZZ32),N)\] =
        SparseGen[\N,((ZZ32,ZZ32),N)\](rows,
            fn (i:ZZ32,j:ZZ32,n:N):((ZZ32,ZZ32),N) => ((i,j),n))
    zeroIndices():Generator[\(ZZ32,ZZ32)\] =
        SparseGen[\N,(ZZ32,ZZ32)\](rows,
            fn (i:ZZ32,j:ZZ32,n:N):((ZZ32,ZZ32),N) => (i,j))
    t() = Csc[\N,m,n\](rows)
    rmul(other:Vector[\N,m\]): Vector[\N,n\] = do
        res = rows.replica[\N\]()
        row(i:ZZ32,r:SparseVector[\N,n\]):() = res.put(i,r DOT other)
        j(l:(),r:()):() = ()
        rows.indexValuePairs().mapReduce[\()\](row,j,())
        res
      end
    mul[\nat p\](other: Matrix[\N,m,p\]) =
      typecase other of
        Csc[\N,m,p\] => do
            (* This do block mystically transforms the following
               function definition from a LetFn into some other
               mysterious bit of actually-implemented AST instead. *)
            row(i: ZZ32): SparseVector[\N,p\] = do
              mem0 = array[\(ZZ32,RR64)\](p)
              r = rows[i]
              o : ZZ32 := 0
              for j <- seq(0#p) do
                d = r DOT other.cols[j]
                if d=/=0 then
                  mem0[o] := (j,d)
                  o += 1
                end
              end
              SparseVector[\RR64,n\](trim(mem0,o))
            end
            Csr[\N,n,p\](array1[\SparseVector[\N,p\],n\](row))
          end
        else => other.t().mul[\n\](self.t())
      end
end

(*public*) object Csc[\N extends Number, nat n, nat m\]
                 (cols:Array1[\SparseVector[\N,n\],0,m\])
  extends Matrix[\N,n,m\]
    get(t:(ZZ32,ZZ32)) = do (i,j)=t;  (cols[j])[i] end
    put(t:(ZZ32,ZZ32), v:N) = fail("Csc is immutable")
    replica[\U\]() = fail("Csc replica undefined")
    indexValuePairs():Generator[\((ZZ32,ZZ32),N)\] =
        SparseGen[\N,((ZZ32,ZZ32),N)\](rows,
            fn (i:ZZ32,j:ZZ32,n:N):((ZZ32,ZZ32),N) => ((j,i),n))
    zeroIndices():Generator[\(ZZ32,ZZ32)\] =
        SparseGen[\N,(ZZ32,ZZ32)\](rows,
            fn (i:ZZ32,j:ZZ32,n:N):((ZZ32,ZZ32),N) => (j,i))
    t() = Csr[\N,m,n\](cols)
    lmul(other:Vector[\N,n\]): Vector[\N,m\] = t().rmul(other)
end

object SparseGen[\N extends Number, M\]
                (arr:Array[\Array[\N,ZZ32\],ZZ32\], f:(ZZ32,ZZ32,N)->M)
        extends Generator[\M\]
    generate[\R\](r: Reduction[\R\], body: E->R): R =
        arr.indexValuePairs().generate[\R\](r,
            fn (i:ZZ32, v:Array[\N,ZZ32\]): R =>
                v.indexValuePairs().generate[\R\](r,
                    fn (j:ZZ32, n:N): R => body(f(i,j,n))))
    loop(body:E->()): () =
        arr.indexValuePairs().loop(
            fn (i:ZZ32, v:Array[\N,ZZ32\]): () =>
                v.indexValuePairs().loop(fn (j:ZZ32, n:N):() => body(f(i,j,n))))

    map[\G\](f': E->G): Generator[\G\] = SparseGen[\N,G\](arr, f' COMPOSE f)
end

end
