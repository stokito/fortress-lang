(*******************************************************************************
    Copyright 2008,2011, Oracle and/or its affiliates.
    All rights reserved.


    Use is subject to license terms.

    This distribution may include materials developed by third parties.

 ******************************************************************************)

component CompilerBuiltin
import java com.sun.fortress.nativeHelpers.{simplePrintln.nativePrint => jPrint,
                                            simplePrintln.nativePrintln => jPrintln,
                                            simplePrintln.nativeErrorPrint => jErrorPrint,
                                            simplePrintln.nativeErrorPrintln => jErrorPrintln}
import java com.sun.fortress.nativeHelpers.{simpleConcatenate.nativeConcatenate => jConcatenate,
                                            simpleConcatenate.nativeStrlen => jStrlen}
import java com.sun.fortress.nativeHelpers.{simpleBoolean.booleanAnd => jBooleanAnd,
                                            simpleBoolean.booleanOr => jBooleanOr,
                                            simpleBoolean.booleanXor => jBooleanXor,
                                            simpleBoolean.booleanEqv => jBooleanEqv,
                                            simpleBoolean.booleanNot => jBooleanNot}
import java com.sun.fortress.nativeHelpers.{simpleIntArith.intToString => jIntToString,
                                            simpleIntArith.intAdd => jIntAdd,
                                            simpleIntArith.intSub => jIntSub,
                                            simpleIntArith.intMul => jIntMul,
                                            simpleIntArith.intDiv => jIntDiv,
                                            simpleIntArith.intLT => jIntLT,
                                            simpleIntArith.intLE => jIntLE,
                                            simpleIntArith.intGT => jIntGT,
                                            simpleIntArith.intGE => jIntGE,
                                            simpleIntArith.intEQ => jIntEQ,
                                            simpleIntArith.intNeg => jIntNeg,
                                            simpleIntArith.parseInt => jParseInt,
                                            simpleIntArith.intAbs => jIntAbs,
                                            simpleIntArith.longToInt => jLongToInt,
                                            simpleIntArith.intBitNot => jIntBitNot,
                                            simpleIntArith.intBitAnd => jIntBitAnd,
                                            simpleIntArith.intBitOr => jIntBitOr,
                                            simpleIntArith.intBitXor => jIntBitXor}
import java com.sun.fortress.nativeHelpers.{simpleLongArith.longToString => jLongToString,
                                            simpleLongArith.longAdd => jLongAdd,
                                            simpleLongArith.longSub => jLongSub,
                                            simpleLongArith.longMul => jLongMul,
                                            simpleLongArith.longDiv => jLongDiv,
                                            simpleLongArith.longLT => jLongLT,
                                            simpleLongArith.longLE => jLongLE,
                                            simpleLongArith.longGT => jLongGT,
                                            simpleLongArith.longGE => jLongGE,
                                            simpleLongArith.longEQ => jLongEQ,
                                            simpleLongArith.longNeg => jLongNeg,
                                            simpleLongArith.parseLong => jParseLong,
                                            simpleLongArith.longAbs => jLongAbs,
                                            simpleLongArith.intToLong => jIntToLong,
                                            simpleLongArith.longBitNot => jLongBitNot,
                                            simpleLongArith.longBitAnd => jLongBitAnd,
                                            simpleLongArith.longBitOr => jLongBitOr,
                                            simpleLongArith.longBitXor => jLongBitXor}
import java com.sun.fortress.nativeHelpers.{simpleDoubleArith.floatToDouble => jFloatToDouble,
                                            simpleDoubleArith.doubleToString => jDoubleToString,
                                            simpleDoubleArith.doubleAdd => jDoubleAdd,
                                            simpleDoubleArith.doubleSub => jDoubleSub,
                                            simpleDoubleArith.doubleMul => jDoubleMul,
                                            simpleDoubleArith.doubleDiv => jDoubleDiv,
                                            simpleDoubleArith.doubleLT => jDoubleLT,
                                            simpleDoubleArith.doubleLE => jDoubleLE,
                                            simpleDoubleArith.doubleGT => jDoubleGT,
                                            simpleDoubleArith.doubleGE => jDoubleGE,
                                            simpleDoubleArith.doubleEQ => jDoubleEQ,
                                            simpleDoubleArith.doubleNeg => jDoubleNeg,
                                            simpleDoubleArith.parseDouble => jParseDouble,
                                            simpleDoubleArith.doubleAbs => jDoubleAbs,
                                            simpleDoubleArith.doublePow => jDoublePow,
                                            simpleDoubleArith.doubleNanoTime => jNanoTime}
import java com.sun.fortress.nativeHelpers.{simpleChar.charToString => jCharToString,
                                            simpleChar.charToExprString => jCharToExprString,
                                            simpleChar.charCodePointWithSpecialCompilerHackForCharacterArgumentType => jCodePoint,
                                            simpleChar.charMakeCharacterWithSpecialCompilerHackForCharacterResultType => jMakeCharacter,
                                            simpleChar.charLT => jCharLT,
                                            simpleChar.charLE => jCharLE,
                                            simpleChar.charGT => jCharGT,
                                            simpleChar.charGE => jCharGE,
                                            simpleChar.charEQ => jCharEQ,
                                            simpleChar.charNE => jCharNE,
                                            simpleChar.charLessNotSim => jCharLessNotSim,
                                            simpleChar.charLessSim => jCharLessSim,
                                            simpleChar.charGreaterNotSim => jCharGreaterNotSim,
                                            simpleChar.charGreaterSim => jCharGreaterSim,
                                            simpleChar.charSimEq => jCharSimEq,
                                            simpleChar.charNotSimEq => jCharNotSimEq,
                                            simpleChar.charGetDirectionality => jCharGetDirectionality,
                                            simpleChar.charGetNumericValue => jCharGetNumericValue,
                                            simpleChar.charGetType => jCharGetType,
                                            simpleChar.charIsDefined => jCharIsDefined,
                                            simpleChar.charIsDigit => jCharIsDigit,
                                            simpleChar.charIsFortressIdentifierPart => jCharIsFortressIdentifierPart,
                                            simpleChar.charIsFortressIdentifierStart => jCharIsFortressIdentifierStart,
                                            simpleChar.charIsHighSurrogate => jCharIsHighSurrogate,
                                            simpleChar.charIsIdentifierIgnorable => jCharIsIdentifierIgnorable,
                                            simpleChar.charIsISOControl => jCharIsISOControl,
                                            simpleChar.charIsJavaIdentifierPart => jCharIsJavaIdentifierPart,
                                            simpleChar.charIsJavaIdentifierStart => jCharIsJavaIdentifierStart,
                                            simpleChar.charIsLetter => jCharIsLetter,
                                            simpleChar.charIsLetterOrDigit => jCharIsLetterOrDigit,
                                            simpleChar.charIsLowerCase => jCharIsLowerCase,
                                            simpleChar.charIsLowSurrogate => jCharIsLowSurrogate,
                                            simpleChar.charIsMirrored => jCharIsMirrored,
                                            simpleChar.charIsSpaceChar => jCharIsSpaceChar,
                                            simpleChar.charIsSupplementaryCodePoint => jCharIsSupplementaryCodePoint,
                                            simpleChar.charIsSurrogatePair => jCharIsSurrogatePair,
                                            simpleChar.charIsTitleCase => jCharIsTitleCase,
                                            simpleChar.charIsUnicodeIdentifierPart => jCharIsUnicodeIdentifierPart,
                                            simpleChar.charIsUnicodeIdentifierStart => jCharIsUnicodeIdentifierStart,
                                            simpleChar.charIsUpperCase => jCharIsUpperCase,
                                            simpleChar.charIsValidCodePoint => jCharIsValidCodePoint,
                                            simpleChar.charIsWhitespace => jCharIsWhitespace,
                                            simpleChar.charJavaDigit => jCharJavaDigit,
                                            simpleChar.charToLowerCase => jCharToLowerCase,
                                            simpleChar.charToTitleCase => jCharToTitleCase,
                                            simpleChar.charToUpperCase => jCharToUpperCase}
import java com.sun.fortress.nativeHelpers.{LocalRandom.localRandomDouble => jRandomDouble,
                                            LocalRandom.localRandomInt => jRandomInt }
import java com.sun.fortress.nativeHelpers.{stringOps.compareTo => jCompareTo,
                                            stringOps.substring => jSubstring,
                                            stringOps.charAt => jCharAt,
                                            stringOps.asString => jAsString}
import java com.sun.fortress.nativeHelpers.{fileOps.jbrOpen => jJavaBufferedReaderOpen,
                                            fileOps.jbrAsString => jJavaBufferedReaderAsString,
                                            fileOps.jbrRead => jJavaBufferedReaderRead,
                                            fileOps.jbrReadLine => jJavaBufferedReaderReadLine,
                                            fileOps.jbrReadk => jJavaBufferedReaderReadk,
                                            fileOps.jbrEof => jJavaBufferedReaderEof,
                                            fileOps.jbrReady => jJavaBufferedReaderReady,
                                            fileOps.jbrClose => jJavaBufferedReaderClose,
                                            fileOps.jbrWhenUnconsumed => jJavaBufferedReaderWhenUnconsumed,
                                            fileOps.jbrConsume => jJavaBufferedReaderConsume,
                                            fileOps.jbwOpen => jJavaBufferedWriterOpen,
                                            fileOps.jbwAsString => jJavaBufferedWriterAsString,
                                            fileOps.jbwWriteChar => jJavaBufferedWriterWriteChar,
                                            fileOps.jbwWriteString => jJavaBufferedWriterWriteString,
                                            fileOps.jbwNewLine => jJavaBufferedWriterNewLine,
                                            fileOps.jbwFlush => jJavaBufferedWriterFlush,
                                            fileOps.jbwClose => jJavaBufferedWriterClose }
import java com.sun.fortress.nativeHelpers.{simpleIntVector.getIndexedValue => jIntVectorGet,
                                            simpleIntVector.putIndexedValue => jIntVectorPut,
                                            simpleIntVector.getSize => jIntVectorGetSize,
                                            simpleIntVector.make => jIntVectorMake }
import java com.sun.fortress.nativeHelpers.{simpleStringVector.getIndexedValue => jStringVectorGet,
                                            simpleStringVector.putIndexedValue => jStringVectorPut,
                                            simpleStringVector.getSize => jStringVectorGetSize,
                                            simpleStringVector.make => jStringVectorMake }
import AnyType.{Any}
import CompilerAlgebra.{ Equality }
export CompilerBuiltin

nanoTime(): RR64 = jNanoTime()

trait Object extends Any
   getter asString(): String = jAsString(self)
   getter asExprString(): String = "[no expression for "  self.asString "]"
   getter asDebugString(): String = self.asString
(*)     getter asDebugString(): String  = do  (* for debugging; may contain more information *)
(*)         ilk = self.ilkName
(*)         firstChar = ilk[0]
(*)         article = if firstChar = 'a' OR: firstChar = 'e' OR: firstChar = 'i' OR: firstChar = 'o' OR:
(*)           (firstChar = 'h' AND: |ilk| >= 4 AND: ilk[0:3] = "hono") OR:
(*)           (firstChar = 'u' AND:
(*)              (do ilkNameLength = |ilk|
(*)                ilkNameLength >= 3 AND:
(*)                  (do (secondChar, thirdChar) = (ilk[1], ilk[2])
(*)                    (secondChar = 'b' AND thirdChar = 'i') OR:
(*)                    (secondChar = 'n' AND thirdChar = 'i' AND:
(*)                      (ilkNameLength = 3 OR:
(*)                    (case ilk[3] of
(*)                            'd' => ilkNameLength < 6 OR: (ilk[4:5] =/= "en" AND: ilk[4:5] =/= "io")
(*)                            'm' => ilkNameLength < 5 OR: (ilk[4] =/= 'a' AND: ilk[4] =/= 'p')
(*)                            'n' => ilkNameLength >= 5 AND: (ilk[4] = 'u')
(*)                            'r' => ilkNameLength < 6 OR: ilk[4:5] =/= "on"
(*)                        else => true))) OR:
(*)                    (secondChar = 'r' AND
(*)                  (thirdChar = 'a' OR: thirdChar = 'e' OR: thirdChar = 'i' OR: thirdChar = 'o' OR:
(*)                    (thirdChar = 'u' AND: (ilkNameLength = 3 OR: ilk[3] =/= 'g')))) OR:
(*)                    (secondChar = 't' AND
(*)                  (thirdChar = 'a' OR: thirdChar = 'e' OR: thirdChar = 'i' OR: thirdChar = 'o'))
(*)                    (secondChar = 'v' AND
(*)                  (thirdChar = 'a' OR: thirdChar = 'e' OR: thirdChar = 'i' OR: thirdChar = 'u')))))
(*)             then "an " else "a " end
(*)         article ilk ": " self.asString
(*)         self.asString
(*) end
end Object

trait String
    getter isEmpty(): Boolean = (jStrlen(self) = 0)
    getter asString(): String = self
    opr |self| : ZZ32 = jStrlen(self)
    opr <(self, b: String) = (jCompareTo(self, b) < 0)
    opr =(self, b: String) = (jCompareTo(self, b) = 0)
    opr ||(self, b:String): String =  jConcatenate(self, b)
    opr juxtaposition(self, b:String): String = jConcatenate(self, b)
    opr [i:ZZ32] : ZZ32 = jCharAt(self, i)
    substring(lo:ZZ32, hi:ZZ32):String = jSubstring(self, lo, hi)
    opr ^(self, n: ZZ32): String =
      if n <= 1 then
        if n=1 then self elif n=0 then "" else throw NegativeLength end
      else
        x = (self || self)^(n DIV 2)
        if odd n then x || self else x end
      end
end

object FlatString extends String
end FlatString

println(s:String):() = jPrintln(s)
println(c:Character):() = jPrintln(c.asString)
(*) println(x:Object): () = jPrintln(x.asString)
(*) println():() = jPrintln("")
(*) println(x:Any):() = jPrintln("<any>")

println(x:ZZ32):() = jPrintln(x.asString)
println(x:ZZ64):() = jPrintln(x.asString)
(*) println(x:RR32):() = jPrintln(x.asString)
println(x:RR64):() = jPrintln(x.asString)
(*) println(x: (Any, Any)):() = jPrintln(str(x))
(*) println(x: (Any, Any, Any)):() = jPrintln(str(x))
(*) println(x: (Any, Any, Any, Any)):() = jPrintln(str(x))
(*) println[\A,B,C,D,E\](x: (A,B,C,D,E)):() = jPrintln(str(x))
(*) println[\A,B,C,D,E,F\](x: (A,B,C,D,E,F)):() = jPrintln(str(x))
(*) println[\A,B,C,D,E,F,G\](x: (A,B,C,D,E,F,G)):() = jPrintln(str(x))

errorPrintln(s:String):() = jErrorPrintln(s)
errorPrintln(c:Character):() = jErrorPrintln(c.asString)
(*) errorPrintln(x:Object): () = jErrorPrintln(x.asString)
(*) errorPrintln():() = jErrorPrintln("")
(*) errorPrintln(x:Any):() = jErrorPrintln("<big tuple>")

errorPrintln(x:ZZ32):() = jErrorPrintln(x.asString)
errorPrintln(x:ZZ64):() = jErrorPrintln(x.asString)
(*) errorPrintln(x:RR32):() = jErrorPrintln(x.asString)
errorPrintln(x:RR64):() = jErrorPrintln(x.asString)
(*) errorPrintln[\A,B\](x: (A,B)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C\](x: (A,B,C)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D\](x: (A,B,C,D)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D,E\](x: (A,B,C,D,E)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D,E,F\](x: (A,B,C,D,E,F)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D,E,F,G\](x: (A,B,C,D,E,F,G)):() = jErrorPrintln(str(x))

(*) Utility routine for converting tuples to strings
(*) private str(x:Any):String = "<big tuple>"
(*) private str(x: Object):String = x.asString
(*) private str():String = "()"
(*) private str(x: (Any, Any)):String = do (a,b) = x; "(" str(a) ", " str(b) ")" end
(*) private str(x: (Any, Any, Any)):String = do (a,b,c) = x; "(" str(a) ", " str(b) ", " str(c) ")" end
(*) private str(x: (Any, Any, Any, Any)):String = do (a,b,c,d) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ")" end
(*) private str[\A,B,C,D,E\](x: (A,B,C,D,E)):String = do (a,b,c,d,e) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ", " str(e) ")" end
(*) private str[\A,B,C,D,E,F\](x: (A,B,C,D,E,F)):String = do (a,b,c,d,e,f) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ", " str(e) ", " str(f) ")" end
(*) private str[\A,B,C,D,E,F,G\](x: (A,B,C,D,E,F,G)):String = do (a,b,c,d,e,f,g) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ", " str(e) ", " str(f) ", " str(g) ")" end

strToInt(s:String):ZZ32 = jParseInt(s)

trait Number excludes { String }
end

trait ZZ64 extends Number excludes { RR64 }
    coerce(x: IntLiteral) = x.asZZ64
    coerce(x: ZZ32) = jIntToLong(x)
    getter asZZ32(): ZZ32 = jLongToInt(self)
    getter asString(): String = jLongToString(self)
    opr |self| : ZZ64 = jLongAbs(self)
    opr -(self): ZZ64 = jLongNeg(self)
    opr +(self, other:ZZ64): ZZ64 = jLongAdd(self,other)
    opr -(self, other:ZZ64): ZZ64 = jLongSub(self,other)
    opr DOT(self, other:ZZ64): ZZ64 = jLongMul(self,other)
    opr DIV(self, other:ZZ64): ZZ64 = jLongDiv(self,other)
    opr <(self, other:ZZ64): Boolean = jLongLT(self,other)
    opr <=(self, other:ZZ64): Boolean = jLongLE(self,other)
    opr >(self, other:ZZ64): Boolean = jLongGT(self,other)
    opr >=(self, other:ZZ64): Boolean = jLongGE(self,other)
    opr =(self, other:ZZ64): Boolean = jLongEQ(self,other)
    opr juxtaposition(self, other:ZZ64): ZZ64 = jLongMul(self,other)
    opr BITNOT(self): ZZ64 = jLongBitNot(self)
    opr BITAND(self, other:ZZ64): ZZ64 = jLongBitAnd(self,other)
    opr BITOR(self, other:ZZ64): ZZ64 = jLongBitOr(self,other)
    opr BITXOR(self, other:ZZ64): ZZ64 = jLongBitXor(self,other)
    opr MIN(self, other:ZZ64): ZZ64 = if self <= other then self else other end
    opr MAX(self, other:ZZ64): ZZ64 = if self >= other then self else other end
    opr MINMAX(self, other:ZZ64): (ZZ64, ZZ64) = if self <= other then (self, other) else (other, self) end
    even(self): Boolean = ((self BITAND 1) = 0)
    odd(self): Boolean = NOT (even self)
end

trait ZZ32 extends Number excludes { ZZ64, RR32, RR64 }
    coerce(x: IntLiteral) = x.asZZ32
    getter asZZ32(): ZZ32 = self
    getter asString(): String = jIntToString(self)
    opr |self| : ZZ32 = jIntAbs(self)
    opr -(self): ZZ32 = jIntNeg(self)
    opr +(self, other:ZZ32): ZZ32 = jIntAdd(self,other)
    opr -(self, other:ZZ32): ZZ32 = jIntSub(self,other)
    opr DOT(self, other:ZZ32): ZZ32 = jIntMul(self,other)
    opr DIV(self, other:ZZ32): ZZ32 = jIntDiv(self,other)
    opr <(self, other:ZZ32): Boolean = jIntLT(self,other)
    opr <=(self, other:ZZ32): Boolean = jIntLE(self,other)
    opr >(self, other:ZZ32): Boolean = jIntGT(self,other)
    opr >=(self, other:ZZ32): Boolean = jIntGE(self,other)
    opr =(self, other:ZZ32): Boolean = jIntEQ(self,other)
    opr juxtaposition(self, other:ZZ32): ZZ32 = jIntMul(self,other)
    opr BITNOT(self): ZZ32 = jIntBitNot(self)
    opr BITAND(self, other:ZZ32): ZZ32 = jIntBitAnd(self,other)
    opr BITOR(self, other:ZZ32): ZZ32 = jIntBitOr(self,other)
    opr BITXOR(self, other:ZZ32): ZZ32 = jIntBitXor(self,other)
    opr MIN(self, other:ZZ32): ZZ32 = if self <= other then self else other end
    opr MAX(self, other:ZZ32): ZZ32 = if self >= other then self else other end
    opr MINMAX(self, other:ZZ32): (ZZ32, ZZ32) = if self <= other then (self, other) else (other, self) end
    even(self): Boolean = ((self BITAND 1) = 0)
    odd(self): Boolean = NOT (even self)
end

trait IntLiteral excludes {ZZ32, ZZ64}
    getter asZZ32(): ZZ32
    getter asZZ64(): ZZ64
(*
    getter asNN32(): NN32
    getter asZZ(): ZZ
    getter asRR32(): RR32
*)
    getter asRR64(): RR64
end

trait RR64 extends Number excludes ZZ64
    coerce(x: FloatLiteral) = x.asRR64
    coerce(x: RR32) = jFloatToDouble(x)
    getter asString(): String = jDoubleToString(self)
    getter isNaN(): Boolean = NOT (self = self)
    opr |self| : RR64 = jDoubleAbs(self)
    opr -(self): RR64 = jDoubleNeg(self)
    opr +(self, other:RR64): RR64 = jDoubleAdd(self,other)
    opr -(self, other:RR64): RR64 = jDoubleSub(self,other)
    opr <(self, other:RR64): Boolean = jDoubleLT(self,other)
    opr <=(self, other:RR64): Boolean = jDoubleLE(self,other)
    opr >(self, other:RR64): Boolean = jDoubleGT(self,other)
    opr >=(self, other:RR64): Boolean = jDoubleGE(self,other)
    opr =(self, other:RR64): Boolean = jDoubleEQ(self,other)
    opr juxtaposition(self, other:RR64): RR64 = jDoubleMul(self,other)
    opr DOT(self, other:RR64): RR64 = jDoubleMul(self,other)
    opr /(self, other:RR64): RR64 = jDoubleDiv(self,other)
    opr MIN(self, other:RR64): RR64 = if self <= other then self elif other <= self then other elif self.isNaN then self else other end
    opr MAX(self, other:RR64): RR64 = if self >= other then self elif other >= self then other elif self.isNaN then self else other end
    opr MINNUM(self, other:RR64): RR64 = if self <= other then self elif other <= self then other elif self.isNaN then other else self end
    opr MAXNUM(self, other:RR64): RR64 = if self >= other then self elif other >= self then other elif self.isNaN then other else self end
    opr MINNUMMAX(self, other:RR64): (RR64, RR64) = if self <= other then (self, other) elif other <= self then (other, self) elif other.isNaN then (self, other) else (other, self) end
    opr MINMAXNUM(self, other:RR64): (RR64, RR64) = if self <= other then (self, other) elif other <= self then (other, self) elif self.isNaN then (self, other) else (other, self) end
    opr ^(self, other:RR64): RR64 = jDoublePow(self,other)
    opr ^(self, other:ZZ32): RR64 =
        if other > 2 then
            mid = other DIV 2
            if (mid + mid) = other then
                (self self)^mid
            else
                self (self self)^mid
            end
        elif other = 2 then self self
        elif other = 1 then self
        elif other = 0 then 1.0
        elif other = -other then
          (* Screw case of most negative `ZZ32` value *)
          1.0 / (self^(-(other DIV 2)))^2

        else (* other < 0 then *) 1.0 / (self^(-other))
        end
end

trait RR32 extends Number excludes { ZZ64, ZZ32, RR64 }
    coerce(x: FloatLiteral) = x.asRR32
end

trait FloatLiteral excludes {RR32, RR64}
    getter asRR32(): RR32
    getter asRR64(): RR64
end

trait Boolean      extends { Equality[\Boolean\] }
    excludes { String, Number }
  getter holds(): Boolean = self
  getter get(): () = ()
  getter asString(): String = self.asExprString
  getter asExprString(): String = if self then "true" else "false" end
  getter size(): ZZ32 = |self|
  opr |self| : ZZ32 = if self then 1 else 0 end
(*)   cond[\R\](t:()->R, e:()->R) : R = if self then t() else e() end
(*)   generate[\R\](r:Reduction[\R\],b:()->R): R =
(*)       if self then b() else r.empty() end
(*)   map[\G\](f: ()->G): Maybe[\G\] =
(*)       if self then Just[\G\](f()) else Nothing[\G\] end
(*)   cross[\G\](g: Generator[\G\]): Generator[\((),G)\] =
(*)       if self
(*)       then g.map[\((),G)\](fn (e:G):((),G) => ((),e))
(*)       else Nothing[\((),G)\] end

(*)   mapReduce[\R\](b: ()->R, _:(R,R)->R, z:R): R =
(*)       if self then b() else z end
(*)   loop(f:()->()): () = if self then f() end

  opr NOT(self):Boolean = jBooleanNot(self)
  opr AND(self, other:Boolean):Boolean = jBooleanAnd(self, other)
  opr AND(self, other:()->Boolean):Boolean = if self then other() else self end
  opr OR(self, other:Boolean):Boolean = jBooleanOr(self, other)
  opr OR(self, other:()->Boolean):Boolean = if self then self else other() end
  opr XOR(self, other:Boolean):Boolean = jBooleanXor(self, other)
  opr OPLUS(self, other:Boolean):Boolean = jBooleanXor(self, other)
  opr NEQV(self, other:Boolean):Boolean = jBooleanXor(self, other)
  opr EQV(self, other:Boolean):Boolean = jBooleanEqv(self, other)
  opr <->(self, other:Boolean):Boolean = jBooleanEqv(self, other)
  opr ->(self, other:Boolean):Boolean = (NOT self) OR other
  opr NAND(self, other:Boolean):Boolean = NOT (self AND other)
  opr NOR(self, other:Boolean):Boolean = NOT (self OR other)

  opr =(self, other:Boolean): Boolean = jBooleanEqv(self, other)
(*)   opr <(self, other:Boolean): Boolean = (NOT self) AND other
(*)   opr CMP(self, other:Boolean): TotalComparison =
(*)       if self then
(*)           if other then EqualTo else GreaterThan end
(*)       else
(*)           if other then LessThan else EqualTo end
(*)       end
end

true: Boolean = (0=0)
false: Boolean = (0=1)

makeCharacter(n: ZZ32): Character =
    if characterMinCodePoint <= n <= characterMaxCodePoint
    then jMakeCharacter(n)
    else throw IntegerOverflow   (*) Really should be IndexOutOfRange
    end

trait Character excludes { String, Number, Boolean }
    getter asString() : String = jCharToString(jCodePoint(self))
    getter asExprString() : String = jCharToExprString(jCodePoint(self))
    getter codePoint(): ZZ32 = jCodePoint(self)

    opr <(self, other:Character): Boolean = jCharLT(jCodePoint(self), jCodePoint(other))
    opr <=(self, other:Character): Boolean = jCharLE(jCodePoint(self), jCodePoint(other))
    opr >(self, other:Character): Boolean = jCharGT(jCodePoint(self), jCodePoint(other))
    opr >=(self, other:Character): Boolean = jCharGE(jCodePoint(self), jCodePoint(other))
    opr =(self, other:Character): Boolean = jCharEQ(jCodePoint(self), jCodePoint(other))
    opr =/=(self, other:Character): Boolean = jCharNE(jCodePoint(self), jCodePoint(other))

    opr LNSIM(self, other:Character): Boolean = jCharLessNotSim(jCodePoint(self), jCodePoint(other))
    opr LESSSIM(self, other:Character): Boolean = jCharLessSim(jCodePoint(self), jCodePoint(other))
    opr GNSIM(self, other:Character): Boolean = jCharGreaterNotSim(jCodePoint(self), jCodePoint(other))
    opr GTRSIM(self, other:Character): Boolean = jCharGreaterSim(jCodePoint(self), jCodePoint(other))
    opr SIMEQ(self, other:Character): Boolean = jCharSimEq(jCodePoint(self), jCodePoint(other))
    opr NSIMEQ(self, other:Character): Boolean = jCharNotSimEq(jCodePoint(self), jCodePoint(other))

    getDirectionality(self): ZZ32 = jCharGetDirectionality(jCodePoint(self))
    getNumericValue(self): ZZ32 = jCharGetNumericValue(jCodePoint(self))
    getType(self): ZZ32 = jCharGetType(jCodePoint(self))
    isDefined(self): Boolean = jCharIsDefined(jCodePoint(self))
    isDigit(self): Boolean = jCharIsDigit(jCodePoint(self))
    isFortressIdentifierPart(self): Boolean = jCharIsFortressIdentifierPart(jCodePoint(self))
    isFortressIdentifierStart(self): Boolean = jCharIsFortressIdentifierStart(jCodePoint(self))
    isHighSurrogate(self): Boolean = jCharIsHighSurrogate(jCodePoint(self))
    isIdentifierIgnorable(self): Boolean = jCharIsIdentifierIgnorable(jCodePoint(self))
    isISOControl(self): Boolean = jCharIsISOControl(jCodePoint(self))
    isJavaIdentifierPart(self): Boolean = jCharIsJavaIdentifierPart(jCodePoint(self))
    isJavaIdentifierStart(self): Boolean = jCharIsJavaIdentifierStart(jCodePoint(self))
    isLetter(self): Boolean = jCharIsLetter(jCodePoint(self))
    isLetterOrDigit(self): Boolean = jCharIsLetterOrDigit(jCodePoint(self))
    isLowerCase(self): Boolean = jCharIsLowerCase(jCodePoint(self))
    isLowSurrogate(self): Boolean = jCharIsLowSurrogate(jCodePoint(self))
    isMirrored(self): Boolean = jCharIsMirrored(jCodePoint(self))
    isSpaceChar(self): Boolean = jCharIsSpaceChar(jCodePoint(self))
    isSupplementaryCodePoint(self): Boolean = jCharIsSupplementaryCodePoint(jCodePoint(self))
    isSurrogatePair(self, low: Character): Boolean = jCharIsSurrogatePair(jCodePoint(self), jCodePoint(low))
    isTitleCase(self): Boolean = jCharIsTitleCase(jCodePoint(self))
    isUnicodeIdentifierPart(self): Boolean = jCharIsUnicodeIdentifierPart(jCodePoint(self))
    isUnicodeIdentifierStart(self): Boolean = jCharIsUnicodeIdentifierStart(jCodePoint(self))
    isUpperCase(self): Boolean = jCharIsUpperCase(jCodePoint(self))
    isValidCodePoint(self): Boolean = jCharIsValidCodePoint(jCodePoint(self))
    isWhitespace(self): Boolean = jCharIsWhitespace(jCodePoint(self))
    javaDigit(self, radix: ZZ32): ZZ32 = jCharJavaDigit(jCodePoint(self), radix)
    toLowerCase(self): Character = jMakeCharacter(jCharToLowerCase(jCodePoint(self)))
    toTitleCase(self): Character = jMakeCharacter(jCharToTitleCase(jCodePoint(self)))
    toUpperCase(self): Character = jMakeCharacter(jCharToUpperCase(jCodePoint(self)))
end

trait ZZ32Vector 
   getValue(i:ZZ32):ZZ32 = jIntVectorGet(self, i)
   putValue(i:ZZ32, v:ZZ32):() = jIntVectorPut(self, i, v)
   opr[i:ZZ32]:ZZ32 = getValue(i)
   opr |self| : ZZ32 = jIntVectorGetSize(self)
end

trait StringVector 
   getValue(i:ZZ32):String = jStringVectorGet(self, i)
   putValue(i:ZZ32, v:String):() = jStringVectorPut(self, i, v)
   opr[i:ZZ32]:String = getValue(i)
   opr |self| : ZZ32 = jStringVectorGetSize(self)
end

makeZZ32Vector(i:ZZ32) : ZZ32Vector = jIntVectorMake(i)
makeStringVector(i:ZZ32) : StringVector = jStringVectorMake(i)

trait JavaBufferedReader excludes { String, Number, Boolean, Character }
  getter asString(): String = jJavaBufferedReaderAsString(self)
  read(): Character throws IOException = jMakeCharacter(jJavaBufferedReaderRead(self))
  readLine(): String throws IOException = jJavaBufferedReaderReadLine(self)
  readk(k: ZZ32): String throws IOException = jJavaBufferedReaderReadk(self, k)
  eof(): Boolean = jJavaBufferedReaderEof(self)
  ready(): Boolean throws IOException = jJavaBufferedReaderReady(self)
  close(): () throws IOException = jJavaBufferedReaderClose(self)
  whenUnconsumed(): () throws IOException = jJavaBufferedReaderWhenUnconsumed(self)
  consume(): () = jJavaBufferedReaderConsume(self)
end

makeJavaBufferedReader(s: String): JavaBufferedReader throws FileNotFoundException = jJavaBufferedReaderOpen(s)

trait   JavaBufferedWriter excludes { String, Number, Boolean, Character, JavaBufferedReader }
  getter asString(): String = jJavaBufferedWriterAsString(self)
  write(c: Character): () throws IOException = jJavaBufferedWriterWriteChar(self, jCodePoint(c))
  write(s: String): () throws IOException = jJavaBufferedWriterWriteString(self, s)
  newLine(): () throws IOException = jJavaBufferedWriterNewLine(self)
  flush(): () throws IOException = jJavaBufferedWriterFlush(self)
  close(): () throws IOException = jJavaBufferedWriterClose(self)
end

makeJavaBufferedWriter(s: String): JavaBufferedWriter throws FileNotFoundException = jJavaBufferedWriterOpen(s)


(************************************************************
* Comparison values
************************************************************)

(*) Material not present for now.  See CompilerBuiltinComparison.txt


(************************************************************
* Exception hierarchy
************************************************************)

trait Exception comprises { UncheckedException, CheckedException }
end

trait UncheckedException extends Exception excludes CheckedException
end

object NegativeLength extends UncheckedException
    getter asString(): String = "Negative length"
end

object IntegerOverflow extends UncheckedException
    getter asString(): String = "Integer overflow"
end

trait CheckedException extends Exception excludes UncheckedException
end

trait IOException extends CheckedException
end

object IOFailure(s: String) extends IOException
    getter asString(): String = "[I/O failure: " s "]"
end

object FileNotFoundException(s: String) extends IOException
    getter asString(): String = "[File not found: " s "]"
end


(************************************************************
* Random numbers
************************************************************)

random(i:RR64): RR64 = jRandomDouble(i)
randomZZ32(x:ZZ32): ZZ32 = jRandomInt(0,x)


(************************************************************
* Character properties
************************************************************)

characterMinCodePoint: ZZ32 = 0
characterMaxCodePoint: ZZ32 = 1114111

end
