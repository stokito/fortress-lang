;;    Copyright 2008,2010, Oracle and/or its affiliates.
;;    All rights reserved.
;;
;;
;;    Use is subject to license terms.
;;
;;    This distribution may include materials developed by third parties.
;;
;;
;;
;; Stuff for the EMACS "fortify" command (M-&)
;;

(global-set-key "\M-#" 'newfortify)
(require 'cl)

;;; TBD: treat || etc. specially after BIG in phase 2.
;;; TBD: honorary letters
;;; TBD: Names of Greek letters, and boldface Greek
;;; TBD: ampersand-gluing of identifiers
;;; TBD: make "|" in a comprehension a separate token type, to help fractions processing?

;;; The basic plan of the new Fortify code:
;;; (1) Divide the region into a list of tokens.
;;; (2) Perform various "fixups" on the list of tokens.
;;;     (2a) Number token fixups.
;;;     (2b) Vertical-bar token fixups.
;;; (3) Compute an initial rendering of each individual token.
;;; (4) Do a lightweight, error-correcting parse that matches
;;;     left enclosers with right enclosers and also matches keywords.
;;; (5) Handle certain idioms that may span multiple lines.
;;; (6) Handle certain idioms (such as subscripts) that must fall within a line.
;;; (7) Increase size of certain bracketing delimiters.
;;; (8) Adjust spacing between pairs of tokens.
;;; (9) Insert PUSHTABS, POPTABS, and TAB "tokens" as directed by indentation and aligment.
;;; (10) Put it all back into the buffer as one big string.
;;;
;;; During processing, the token list is a Lisp list of token items,
;;; where each token item is a list that begins with an atom identifying
;;; the token type.  The second item in the list is a string; an important
;;; invariant is that concatenating all of these second-item strings
;;; should always produce the original contents of the region.
;;; The remaining items in the list are more strings, all in "TeX form";
;;; the final result is simply the concatenation of all these strings,
;;; but with care to respect the tokenizing rules of TeX: if a string
;;; ends with a backslash and one or more letters, and the next string
;;; begins with a letter, then braces must be used to prevent the letter
;;; from becoming part of the TeX command.

;;; Here are the possible token types:
;;;      AMPERSAND
;;;      BIGOP
;;;      CHARACTER-LITERAL
;;;      CIRCUMFLEX
;;;      COLON
;;;      COMMA
;;;      COMMENT
;;;      COMMENT-ALIGN-START    [introduced during phase (5) to carry formatting commands]
;;;      COMMENT-ALIGN-END      [introduced during phase (5) to carry formatting commands]
;;;      COMMENT-END
;;;      COMMENT-LINE
;;;      COMMENT-MIDDLE
;;;      COMMENT-START
;;;      DIGIT-GROUP-SEPARATOR
;;;      DOT
;;;      FRACTION-START         [introduced during phase (6) to carry formatting commands]
;;;      FRACTION-END           [introduced during phase (6) to carry formatting commands]
;;;      IDENTIFIER-RADIX       [eliminated during phase (2)]
;;;      KEYWORD
;;;      LEFT-BRACKET
;;;      LEFT-ENCLOSER
;;;      LEFT-PARENTHESIS
;;;      NEWLINE
;;;      NUMBER
;;;      NUMBER-RADIX           [eliminated during phase (2)]
;;;      OPERATOR
;;;      OPERATOR-WORD
;;;      OPERATOR-WORD-RADIX    [eliminated during phase (2)]
;;;      POPTABS                [introduced during phase (9)]
;;;      PUSHTABS               [introduced during phase (9)]
;;;      RIGHT-BRACKET
;;;      RIGHT-ENCLOSER
;;;      RIGHT-PARENTHESIS
;;;      SEMICOLON
;;;      STRING
;;;      STRING-END
;;;      STRING-MIDDLE
;;;      STRING-START
;;;      TAB                    [introduced during phase (9)]
;;;      UNKNOWN
;;;      VERTICAL-BAR-TOKEN     [eliminated during phase (2)]
;;;      WHITESPACE

(defun newfortify (prefix-arg)
  (interactive "*p")
  ;; Process the prefix-arg and determine what region to render as LaTeX code.
  (let* ((case-fold-search nil)
	 (backquote-inserted nil)
	 (process-region-p (and prefix-arg (>= prefix-arg 4)))
	 (old-point (copy-marker (point)))
	 (end (copy-marker (cond (process-region-p
				  (region-end))
				 (t (re-search-backward "[^\n \t]" nil nil)
				    (forward-char)
				    (unless (= (point) (marker-position old-point))
				      (insert "`") ;Need to delete this later!
				      (setq backquote-inserted (copy-marker (point))))
				    (point)))))
	 (start (copy-marker (cond (process-region-p
				    (region-beginning))
				   (t (re-search-backward "\\(^\\| \\|\t\\)" nil t)
				      (if (looking-at "[ \t]") (forward-char))
				      (point)))))
	 (result (newfortify-region start end)))
    (when backquote-inserted
      (goto-char (marker-position backquote-inserted))
      (delete-char -1)
      (set-marker backquote-inserted nil))
    (set-marker old-point nil)
    (goto-char start)
    (delete-region start end)
    (insert result)))

(defun newfortify-region (*fortify-region-start* *fortify-region-end*)
  ;; Phase processing begins here
  (let* ((phase1 (fortress-tokens *fortify-region-start* *fortify-region-end*))
	 (phase2 (fortress-vertical-bar-tokens-fixup
		  (fortress-number-tokens-fixup
		   phase1)))
	 (phase3 (fortify-token-list phase2))
	 (matching-hashtable (fortify-light-parse phase3))
	 (phase5 (fortress-multiline-idioms phase3 matching-hashtable))
	 (phase6 (fortress-intraline-idioms phase5 matching-hashtable))
;	 (phase7 phase6)
	 (phase7 (fortress-resize-bracketing-delimiters phase6 matching-hashtable))
	 (phase8 (fortress-adjust-intertoken-spacing phase7 matching-hashtable))
	 (phase9 (fortress-supply-indentation phase8))
	 (result (fortify-fortress-tokens phase9)))
    result))

;;; ****************************************************************
;;; ***** (1) Divide the region into a list of tokens.
;;; ****************************************************************

;;; It is required that either the end of the region be the end of the buffer
;;; or the character after the region be a space, tab, newline, or backquote.

(defun fortress-tokens (region-start region-end)
  (let ((old-point-value (point))
	(result '()))
    (goto-char region-start)
    (while (< (point) region-end)
      (let* ((p (point))
	     (c (prog1 (char-after) (forward-char)))
	     (k (cond ((= c ?\s) (fortress-space-token region-end))
		      ((and (<= ?a c) (<= c ?z))
		       (fortress-word-token nil nil))
		      ((and (<= ?A c) (<= c ?Z))
		       (fortress-word-token t nil))
		      ((= c ?_)
		       (fortress-word-token nil nil))
		      ((and (<= ?0 c) (<= c ?9))
		       (fortress-word-token nil t))
		      ((= c ?\n) 'NEWLINE)
		      ((= c ?\,) 'COMMA)
		      ((= c ?\.) (fortress-dot-token))
		      ((= c ?\;) 'SEMICOLON)
		      ((= c ?\:) (fortress-colon-token))
		      ((= c ?\') (fortress-apostrophe-token region-end))
		      ((= c ?\")
		       (setq result (append (fortress-string-tokens region-end) result))
		       nil)
		      ((= c ?\&) 'AMPERSAND)
		      ((= c ?\-) (fortress-minus-token))
		      ((= c ?\=) (cond ((and result
					     (eq (car (car result)) 'OPERATOR))
					'OPERATOR)
				       (t (fortress-equals-token))))
		      ((= c ?\*) (fortress-asterisk-token))
		      ((= c ?\/) (fortress-slash-token))
		      ((= c ?\\) (fortress-backslash-token))
		      ((= c ?\()
		       (cond ((and (char-after)
				   (= (char-after) ?\*))
			      (cond ((and (char-after (+ (point) 1))
					  (= (char-after (+ (point) 1)) ?\)))
				     (fortress-comment-line-token))
				    (t (setq result (append (fortress-comment-tokens region-end) result))
				       nil)))
			     (t (fortress-left-parenthesis-token))))
		      ((= c ?\)) 'RIGHT-PARENTHESIS)
		      ((= c ?\[) (fortress-left-bracket-token))
		      ((= c ?\]) 'RIGHT-BRACKET)
		      ((= c ?\{) (fortress-left-brace-token))
		      ((= c ?\}) 'RIGHT-ENCLOSER)
		      ((= c ?\<) (fortress-less-than-token))
		      ((= c ?\>) (fortress-greater-than-token))
		      ((= c ?\~) (fortress-tilde-token))
		      ((= c ?\|) (fortress-vertical-bar-token))
		      ((= c ?\`) 'UNKNOWN)
		      ((= c ?\+) 'OPERATOR)
		      ((= c ?\!) 'OPERATOR)
		      ((= c ?\@) 'OPERATOR)
		      ((= c ?\#) 'OPERATOR)
		      ((= c ?\$) 'OPERATOR)
		      ((= c ?\%) 'OPERATOR)
		      ((= c ?^) 'CIRCUMFLEX)
		      ((= c ?\?) 'OPERATOR)
		      ((< c 128) 'UNKNOWN)
		      ((fortress-is-letter c)
		       (fortress-word-token (unicode-is-uppercase c) nil))
		      ((unicode-is-connecting-punctuation c)
		       (fortress-word-token nil nil))
		      ((unicode-is-digit c)
		       (fortress-word-token nil t))
		      ((fortress-unicode-operator c) 'OPERATOR)
		      ((or (= c ?\u301A) (= c ?\u27E6)) 'LEFT-WHITE-BRACKET)
		      ((or (= c ?\u301B) (= c ?\u27E7)) 'RIGHT-WHITE-BRACKET)
		      ((fortress-unicode-left-encloser c) 'LEFT-ENCLOSER)
		      ((fortress-unicode-right-encloser c) 'RIGHT-ENCLOSER)
		      ((= c ?\u201C)
		       (setq result (append (fortress-string-tokens region-end) result))
		       nil)
		      ((= c ?\u2018) (fortress-left-single-quotation-mark-token region-end))
		      ((= c ?\u202F) 'DIGIT-GROUP-SEPARATOR)
		      (t 'UNKNOWN))))
	(when k (push (list k (buffer-substring-no-properties p (min region-end (point)))) result))))
    (goto-char old-point-value)
    (reverse result)))

(defun fortress-is-letter (c)
  (or (unicode-is-letter c)
      (gethash c *fortress-honorary-letter-codepoint-hashtable*)))

(defun fortress-unicode-operator (c)
  (gethash c *fortress-operator-codepoint-hashtable*))

(defun fortress-unicode-left-encloser (c)
  (gethash c *fortress-left-encloser-hashtable*))

(defun fortress-unicode-right-encloser (c)
  (gethash c *fortress-right-encloser-hashtable*))

(defun fortress-space-token (region-end)
  (when (posix-looking-at "[ ]+")
    (goto-char (min (match-end 0) region-end)))
  'WHITESPACE)

(defun fortress-word-token (starts-with-uppercase starts-with-digit)
  (backward-char)
  (let ((p (point))
	(uppercase nil)
	(lowercase nil)
	(two-different-uppercase-letters nil)
	(digit nil)
	(prime nil)
	(last-underscore 0)
	(underscore-count 0)
	(nondigit-since-last-underscore nil)
	(digit-since-last-underscore nil)
	(other-connector nil))
    (catch 'foo
      (while t
	(let ((c (or (char-after) ?\s)))
	  (cond ((and (<= ?a c) (<= c ?z))
		 (setq lowercase t)
		 (setq nondigit-since-last-underscore t))
		((and (<= ?A c) (<= c ?Z))
		 (when uppercase
		   (unless (= c uppercase)
		     (setq two-different-uppercase-letters t)))
		 (setq uppercase c)
		 (setq nondigit-since-last-underscore t))
		((= c ?\_)
		 (setq last-underscore (point))
		 (setq underscore-count (+ underscore-count 1))
		 (setq nondigit-since-last-underscore nil)
		 (setq digit-since-last-underscore nil))
		((= c ?\')
		 (setq prime t)
		 (setq nondigit-since-last-underscore t))
		((and (<= ?0 c) (<= c ?9))
		 (setq digit t)
		 (setq digit-since-last-underscore t))
		((< c 128) (throw 'foo nil))
		((fortress-is-letter c)
		 (cond ((unicode-is-uppercase c)
			(when uppercase
			  (unless (= c uppercase)
			    (setq two-different-uppercase-letters t))))
		       (t (setq lowercase t)))
		 (setq nondigit-since-last-underscore t))
		((unicode-is-connecting-punctuation c)
		 (setq other-connector t))
		((unicode-is-prime c)
		 (setq prime t)
		 (setq nondigit-since-last-underscore t))
		((unicode-is-digit c)
		 (setq digit t)
		 (setq digit-since-last-underscore t))
		(t (throw 'foo nil))))
	(forward-char)))
    (cond (starts-with-digit
	   (cond ((and (= underscore-count 1)
		       (or (and digit-since-last-underscore
				(not nondigit-since-last-underscore))
			   (gethash (buffer-substring-no-properties (+ last-underscore 1) (point))
				    *fortress-radix-specifier-hashtable*)))
		  'NUMBER-RADIX)
		 (t 'NUMBER)))
	  ((gethash (buffer-substring-no-properties p (point)) *fortress-keyword-hashtable*)
	   'KEYWORD)
	  ((gethash (buffer-substring-no-properties p (point)) *fortress-identifier-word-hashtable*)
	   'IDENTIFIER)
	  ((and two-different-uppercase-letters
		starts-with-uppercase
		(not lowercase)
		(not digit)
		(not prime)
		nondigit-since-last-underscore
		(not other-connector))
	   (let ((kind (gethash (buffer-substring-no-properties p (point)) *fortress-operator-kind-hashtable*)))
	     (cond ((eq kind 'OPERATOR) 'OPERATOR-WORD)
		   ((eq kind 'BIGOP) 'BIGOP)
		   ((and (= underscore-count 1)
			 (gethash (buffer-substring-no-properties (+ last-underscore 1) (point))
				  *fortress-radix-specifier-hashtable*))
		    'OPERATOR-WORD-RADIX)
		   (t 'OPERATOR-WORD))))
	  ((and (= underscore-count 1)
		(or (and digit-since-last-underscore
			 (not nondigit-since-last-underscore))
		    (gethash (buffer-substring-no-properties (+ last-underscore 1) (point))
			     *fortress-radix-specifier-hashtable*)))
	   'IDENTIFIER-RADIX)
	  (t 'IDENTIFIER))))

(defun fortress-dot-token ()
  (cond ((posix-looking-at "[.]+")
	 (goto-char (match-end 0))
	 'OPERATOR)
	(t 'DOT)))

(defun fortress-colon-token ()
  (cond ((posix-looking-at "[=]")
	 (goto-char (match-end 0))
	 'OPERATOR)
	((posix-looking-at "[:]+")
	 (goto-char (match-end 0))
	 'OPERATOR)
	(t 'COLON)))

(defun fortress-apostrophe-token (region-end)
  (cond ((and (posix-looking-at ".[^']*'")
	      (<= (match-end 0) region-end))
	 (goto-char (match-end 0))
	 'CHARACTER-LITERAL)
	((posix-looking-at ".[-A-Za-z0-9 _]*")
	 ;; Malformed character literal: choose a plausible chunk
	 (goto-char (min (match-end 0) region-end))
	 'CHARACTER-LITERAL)
	(t
	 ;; Malformed character literal
	 'CHARACTER-LITERAL)))

(defun fortress-left-single-quotation-mark-token (region-end)
  (cond ((posix-looking-at ".[^\u2019]*\u2019")
	 (goto-char (match-end 0))
	 'CHARACTER-LITERAL)
	((posix-looking-at ".[-A-Za-z0-9 _]*")
	 ;; Malformed character literal: choose a plausible chunk
	 (goto-char (min (match-end 0) region-end))
	 'CHARACTER-LITERAL)
	(t
	 ;; Malformed character literal
	 'CHARACTER-LITERAL)))

(defun fortress-string-tokens (region-end)
  (let ((p (point))
	(chunk-start (- (point) 1))
	(results nil))
    (catch 'foo
      (while (< (point) region-end)
	(let ((c (char-after)))
	  (cond ((= c ?\n)
		 (when (< chunk-start (point))
		   (push (list (if (null results) 'STRING-START 'STRING-MIDDLE)
			       (buffer-substring-no-properties chunk-start (point)))
			 results))
		 (push '(NEWLINE "\n") results)
		 (setq chunk-start (+ (point) 1)))
		((= c ?\\)
		 (forward-char)
		 (when (and (< (point) region-end)
			    (= (char-after) ?\n))
		   (backward-char)))
		((or (= c ?\") (= c ?\u201D))
		 (forward-char)
		 (when (> (point) region-end)
		   (goto-char region-end))
		 (push (list (if (null results) 'STRING 'STRING-END)
			     (buffer-substring-no-properties chunk-start (point)))
		       results)
		 (throw 'foo nil))))
	(forward-char))
      ;; Unterminated string
      (when (> (point) region-end)
	(goto-char region-end))
      (push (list (if (null results) 'STRING 'STRING-END)
		  (buffer-substring-no-properties chunk-start (point)))
	    results))
    results))

(defun fortress-comment-line-token ()
  (end-of-line)
  (when (= (char-before) ?\r) (backward-char))
  'COMMENT-LINE)

(defun fortress-comment-tokens (region-end)
  (forward-char)
  (let ((p (point))
	(chunk-start (- (point) 2))
	(comment-depth 1)
	(results nil))
    (catch 'foo
      (while (< (point) region-end)
	(let ((c (char-after)))
	  (cond ((= c ?\n)
		 (push (list (if (null results) 'COMMENT-START 'COMMENT-MIDDLE)
			     (buffer-substring-no-properties chunk-start (point)))
		       results)
		 (push '(NEWLINE "\n") results)
		 (setq chunk-start (+ (point) 1)))
		((looking-at "(\\*)")
		 (forward-char)
		 (forward-char))
		((looking-at "(\\*")
		 (forward-char)
		 (setq comment-depth (+ comment-depth 1)))
		((looking-at "\\*)")
		 (forward-char)
		 (setq comment-depth (- comment-depth 1))
		 (when (= comment-depth 0)
		   (forward-char)
		   (when (> (point) region-end)
		     (goto-char region-end))
		   (push (list (if (null results) 'COMMENT 'COMMENT-END)
			       (buffer-substring-no-properties chunk-start (point)))
			 results)
		   (throw 'foo nil)))))
	(forward-char))
      ;; Unterminated comment
      (when (> (point) region-end)
	(goto-char region-end))
      (push (list (if (null results) 'COMMENT 'COMMENT-END)
		  (buffer-substring-no-properties chunk-start (point)))
	    results))
    results))

(defun fortress-minus-token ()
  (cond ((fortress-arrowbody-arrow)
	 (goto-char (match-end 0))
	 'OPERATOR)
	(t 'OPERATOR)))

(defun fortress-equals-token ()
  (cond ((fortress-arrowbody-arrow)
	 (goto-char (match-end 0))
	 'OPERATOR)
	(t 'OPERATOR)))

(defun fortress-asterisk-token ()
  (cond ((posix-looking-at "[*]")
	 (goto-char (match-end 0))
	 'OPERATOR)
	(t 'OPERATOR)))

(defun fortress-slash-token ()
  (cond ((fortress-leftharpoonhead-arrow)
	 (goto-char (match-end 0))
	 'OPERATOR)
	((fortress-right-encloser)	;must follow check for harpoons
	 (goto-char (match-end 0))
	 'RIGHT-ENCLOSER)
	((posix-looking-at "/+")
	 (goto-char (match-end 0))
	 'OPERATOR)
	(t 'OPERATOR)))

(defun fortress-backslash-token ()
  (cond ((fortress-leftharpoonhead-arrow)
	 (goto-char (match-end 0))
	 'OPERATOR)
	((fortress-right-encloser)     ;must follow check for harpoons
	 (let ((kind (cond ((and (= (match-end 0) (+ (point) 1))
				 (= (char-after) ?\]))
			    'RIGHT-WHITE-BRACKET)
			   (t 'RIGHT-ENCLOSER))))
	   (goto-char (match-end 0))
	   kind))
	((posix-looking-at "[\\]+")
	 (goto-char (match-end 0))
	 'OPERATOR)
	(t 'OPERATOR)))

(defun fortress-left-parenthesis-token ()
  (cond ((fortress-left-encloser)
	 (goto-char (match-end 0))
	 'LEFT-ENCLOSER)
	(t 'LEFT-PARENTHESIS)))

(defun fortress-left-bracket-token ()
  (cond ((fortress-left-encloser)
	 (let ((kind (cond ((and (= (match-end 0) (+ (point) 1))
				 (= (char-after) ?\\))
			    'LEFT-WHITE-BRACKET)
			   (t 'LEFT-ENCLOSER))))
	   (goto-char (match-end 0))
	   kind))
	(t 'LEFT-BRACKET)))

(defun fortress-left-brace-token ()
  (cond ((fortress-left-encloser)
	 (goto-char (match-end 0))
	 'LEFT-ENCLOSER)
	(t 'LEFT-ENCLOSER)))

(defun fortress-less-than-token ()
  (cond ((fortress-leftarrowhead-arrow)
	 (goto-char (match-end 0))
	 'OPERATOR)
	((fortress-left-encloser)	;must follow tests for arrows
	 (goto-char (match-end 0))
	 'LEFT-ENCLOSER)
	(t 'OPERATOR)))

(defun fortress-greater-than-token ()
  (cond ((fortress-rightarrowtail-arrow)
	 (goto-char (match-end 0))
	 'OPERATOR)
	((fortress-right-encloser)	;must follow tests for arrows
	 (goto-char (match-end 0))
	 'RIGHT-ENCLOSER)
	(t 'OPERATOR)))

(defun fortress-tilde-token ()
  (cond ((fortress-arrowbody-arrow)
	 (goto-char (match-end 0))
	 'OPERATOR)
	(t 'OPERATOR)))

(defun fortress-vertical-bar-token ()
  (cond ((or (fortress-leftarrowhead-arrow)
	     (fortress-leftharpoonhead-arrow)
	     (fortress-rightarrowtail-arrow))
	 (goto-char (match-end 0))
	 'OPERATOR)
	((fortress-left-encloser)
	 (goto-char (match-end 0))
	 'LEFT-ENCLOSER)
	((fortress-right-encloser)	;must follow tests for arrows
	 (goto-char (match-end 0))
	 'RIGHT-ENCLOSER)
	((posix-looking-at "\\([*.]?|\\)*")
	 (goto-char (match-end 0))
	 'VERTICAL-BAR-TOKEN)
	(t 'VERTICAL-BAR-TOKEN)))

(defun fortress-left-encloser ()
  (prog2 (backward-char)
      (or (posix-looking-at "(\\(/+\\|[\\]+\\)")
	  (posix-looking-at "\\[\\(\\([*.]?/\\)+\\|\\([*.]?[\\]\\)+\\)")
	  (posix-looking-at "{\\(\\([*.]?/\\)+\\|\\([*.]?[\\]\\)+\\)")
	  (posix-looking-at "<\\(\\([*.]?<\\)*\\(\\([*.]?/\\)+\\|\\([*.]?[\\]\\)+\\|\\([*.]?|\\)+\\)\\|\\([*.]?<\\)+\\)")
	  (posix-looking-at "|\\([*.]?|\\)*\\(\\([*.]?/\\)+\\|\\([*.]?[\\]\\)+\\)"))
    (forward-char)))

(defun fortress-right-encloser ()
  (prog2 (backward-char)
      (or (posix-looking-at "\\(/+\\|[\\]+\\))")
	  (posix-looking-at "\\(\\(/[*.]?\\)+\\|\\([\\][*.]?\\)+\\)\\]")
	  (posix-looking-at "\\(\\(/[*.]?\\)+\\|\\([\\][*.]?\\)+\\)}")
	  (posix-looking-at "\\(\\(\\(/[*.]?\\)+\\|\\([\\][*.]?\\)+\\|\\(|[*.]?\\)+\\)\\(>[*.]?\\)*\\|\\(>[*.]?\\)+\\)>")
	  (posix-looking-at "\\(\\(/[*.]?\\)+\\|\\([\\][*.]?\\)+\\)\\(|[*.]?\\)*|"))
    (forward-char)))

(defun fortress-leftarrowhead-arrow ()
  (prog2 (backward-char)
      (or (posix-looking-at
	   ;; LeftArrowHead ArrowBody RightArrowHead
	   "\\(|[*]?\\)*<\\([*]?[|<>]\\)*[*]?\\([-=~]+\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)[*]?\\([|<>][*]?\\)*>\\([*]?|\\)*")
	  (posix-looking-at
	   ;; LeftArrowHead SplitLongArrowBody LeftArrowTail
	   "\\(|[*]?\\)*<\\([*]?[|<>]\\)*[*]?\\([-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)\\(\\([*]?<\\)+\\([*]?|\\)*\\|\\([*]?|\\)+\\)")
	  (posix-looking-at
	   ;; LeftArrowHead SplitLongArrowBody
	   "\\(|[*]?\\)*<\\([*]?[|<>]\\)*[*]?\\([-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)")
	  (posix-looking-at
	   ;; LeftArrowHead ArrowBody LeftArrowTail
	   "\\(|[*]?\\)*<\\([*]?[|<>]\\)*[*]?\\([-=~]+\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)\\(\\([*]?<\\)+\\([*]?|\\)*\\|\\([*]?|\\)+\\)")
	  (posix-looking-at
	   ;; LeftArrowHead ArrowBody
	   "\\(|[*]?\\)*<\\([*]?[|<>]\\)*[*]?\\([-=~]+\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)"))
    (forward-char)))

(defun fortress-leftharpoonhead-arrow ()
  (prog2 (backward-char)
      (posix-looking-at
       ;; LeftHarpoonHead LongArrowBody (RightHarpoonHead | LeftArrowTail)?
       "\\(|[*]?\\)*\\(\\([\\][*]?\\)+\\|\\(/[*]?\\)+\\)\\([-=~][-=~]+\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)\\(\\(\\([*]?[\\]\\)+\\|\\([*]?/\\)+\\)\\([*]?|\\)*\\|\\(\\([*]?<\\)+\\([*]?|\\)*\\|\\([*]?|\\)+\\)\\)?")
    (forward-char)))

(defun fortress-rightarrowtail-arrow ()
  (prog2 (backward-char)
      (or (posix-looking-at
	   ;; RightArrowTail LongArrowBody (RightHarpoonHead | RightArrowHead)?
	   "\\(\\(|[*]?\\)*\\(>[*]?\\)+\\|\\(|[*]?\\)+\\)\\([-=~][-=~]+\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)\\(\\(\\([*]?[\\]\\)+\\|\\([*]?/\\)+\\)\\([*]?|\\)*\\|[*]?\\([|<>][*]?\\)*>\\([*]?|\\)*\\)?")
	  (posix-looking-at
	   ;; RightArrowTail ArrowBody RightArrowHead?
	   "\\(\\(|[*]?\\)*\\(>[*]?\\)+\\|\\(|[*]?\\)+\\)\\([-=~]+\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)\\([*]?\\([|<>][*]?\\)*>\\([*]?|\\)*\\)?"))
    (forward-char)))

(defun fortress-arrowbody-arrow ()
  (prog2 (backward-char)
      (cond ((posix-looking-at "\\([=~][-=~]+\\|[-][-~]\\|[-][-=~]+[=~-]\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)")
	     ;; LongArrowBody (carefully avoid "-=", which is a compound assignment)
	     (posix-looking-at 
	      ;; LongArrowBody (RightArrowHead | RightHarpoonHead | LeftArrowTail)?
	      "\\([-=~][-=~]+\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)\\([*]?\\([|<>][*]?\\)*>\\([*]?|\\)*\\|\\(\\([*]?[\\]\\)+\\|\\([*]?/\\)+\\)\\([*]?|\\)*\\|\\(\\([*]?<\\)+\\([*]?|\\)*\\|\\([*]?|\\)+\\)\\)?"))
	    (t
	     (or (posix-looking-at 
		  ;; ArrowBody RightArrowHead
		  "\\([-=~]+\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)[*]?\\([|<>][*]?\\)*>\\([*]?|\\)*")
		 (posix-looking-at
		  ;; ArrowBody LeftArrowTail
		  "\\([-=~]+\\|[-=~]+\\(/+\\|[\\]+\\||+\\|[*]\\)[-=~]+\\)\\(\\([*]?<\\)+\\([*]?|\\)*\\|\\([*]?|\\)+\\)"))))
    (forward-char)))

;;; ****************************************************************
;;; ***** (2) Perform various "fixups" on the list of tokens.
;;; ****************************************************************

;;; The two kinds of fixups are for numbers and for vertical-bar tokens.

;;; The number tokens fixup gathers together sequences of one or more tokens
;;; to make single number tokens.  In the process, the following token types
;;; are completely eliminated and do not need to be handled downstream:
;;;     NUMBER-RADIX
;;;     IDENTIFIER-RADIX
;;;     OPERATOR-WORD-RADIX

(defun fortress-number-tokens-fixup (tokens)
  (let ((result nil))
    (while tokens
      (let ((tok (pop tokens)))
	(cond ((or (eq (car tok) 'NUMBER-RADIX)
		   (eq (car tok) 'IDENTIFIER-RADIX)
		   (eq (car tok) 'OPERATOR-WORD-RADIX))
	       (push (cons 'NUMBER (cdr tok)) result))
	      ((eq (car tok) 'NUMBER)
	       (let ((new (cadr tok)))
		 (while (and (or (eq (car (car tokens)) 'DOT)
				 (eq (car (car tokens)) 'DIGIT-GROUP-SEPARATOR))
			     (or (eq (car (cadr tokens)) 'NUMBER)
				 (eq (car (cadr tokens)) 'IDENTIFIER)
				 (eq (car (cadr tokens)) 'OPERATOR-WORD)))
		   (setq new (concat new (cadr (pop tokens)) (cadr (pop tokens)))))
		 (when (and (or (eq (car (car tokens)) 'DOT)
				 (eq (car (car tokens)) 'DIGIT-GROUP-SEPARATOR))
			     (or (eq (car (cadr tokens)) 'NUMBER-RADIX)
				 (eq (car (cadr tokens)) 'IDENTIFIER-RADIX)
				 (eq (car (cadr tokens)) 'OPERATOR-WORD-RADIX)))
		   (setq new (concat new (cadr (pop tokens)) (cadr (pop tokens)))))
		 (push (list 'NUMBER new) result)))
	      ((or (eq (car tok) 'IDENTIFIER)
		   (eq (car tok) 'OPERATOR-WORD))
	       (let ((new (cadr tok))
		     (saved-tokens tokens))
		 (while (and (or (eq (car (car tokens)) 'DOT)
				 (eq (car (car tokens)) 'DIGIT-GROUP-SEPARATOR))
			     (or (eq (car (cadr tokens)) 'NUMBER)
				 (eq (car (cadr tokens)) 'IDENTIFIER)
				 (eq (car (cadr tokens)) 'OPERATOR-WORD)))
		   (setq new (concat new (cadr (pop tokens)) (cadr (pop tokens)))))
		 (cond ((and (or (eq (car (car tokens)) 'DOT)
				 (eq (car (car tokens)) 'DIGIT-GROUP-SEPARATOR))
			     (or (eq (car (cadr tokens)) 'NUMBER-RADIX)
				 (eq (car (cadr tokens)) 'IDENTIFIER-RADIX)
				 (eq (car (cadr tokens)) 'OPERATOR-WORD-RADIX)))
			(setq new (concat new (cadr (pop tokens)) (cadr (pop tokens))))
			(push (list 'NUMBER new) result))
		       (t (setq tokens saved-tokens)
			  (push tok result)))))
	      (t (push tok result)))))
    (reverse result)))

;;; The vertical-bar-tokens fixup eliminates the token type VERTICAL-BAR-TOKEN
;;; by changing it to one of LEFT-ENCLOSER, RIGHT-ENCLOSER, or OPERATOR.
;;; It looks that the surronding context to make the decision.

(defun fortress-vertical-bar-tokens-fixup (tokens)
  (let ((result nil))
    ;; The result is accumulated in reverse order.  Therefore (car result)
    ;; is the token, after processing, of course, that preceded the token
    ;; under consideration, and (cadr result) is the token before that.
    (while tokens
      (let ((tok (pop tokens)))
	(cond ((eq (car tok) 'VERTICAL-BAR-TOKEN)
	       (let ((leftspace (or (null result)
				    (eq (car (car result)) 'WHITESPACE)
				    (eq (car (car result)) 'NEWLINE)
				    (eq (car (car result)) 'COMMENT)))
		     (rightspace (or (null tokens)
				     (eq (car (car tokens)) 'WHITESPACE)
				     (eq (car (car tokens)) 'NEWLINE)
				     (eq (car (car tokens)) 'COMMENT))))
		 (let ((leftkind (cond ((null result) 'SEMICOLON)
				       ((not leftspace) (car (car result)))
				       ((null (cdr result)) 'SEMICOLON)
				       (t (car (cadr result)))))
		       (rightkind (cond ((null tokens) 'SEMICOLON)
					((not rightspace) (car (car tokens)))
					((null (cdr tokens)) 'SEMICOLON)
					(t (car (cadr tokens))))))
		   (let ((newkind (cond ((or (eq leftkind 'LEFT-PARENTHESIS)
					     (eq leftkind 'LEFT-BRACKET)
					     (eq leftkind 'LEFT-WHITE-BRACKET)
					     (eq leftkind 'LEFT-ENCLOSER)
					     (eq leftkind 'COMMA)
					     (eq leftkind 'SEMICOLON))
					 (cond ((or (eq rightkind 'RIGHT-PARENTHESIS)
						    (eq rightkind 'RIGHT-BRACKET)
						    (eq rightkind 'RIGHT-WHITE-BRACKET)
						    (eq rightkind 'RIGHT-ENCLOSER)
						    (eq rightkind 'COMMA)
						    (eq rightkind 'SEMICOLON))
						'OPERATOR)
					       (t 'LEFT-ENCLOSER)))
					((or (eq leftkind 'OPERATOR)
					     (eq leftkind 'OPERATOR-WORD))
					 (cond ((or (eq rightkind 'RIGHT-PARENTHESIS)
						    (eq rightkind 'RIGHT-BRACKET)
						    (eq rightkind 'RIGHT-WHITE-BRACKET)
						    (eq rightkind 'RIGHT-ENCLOSER)
						    (eq rightkind 'COMMA)
						    (eq rightkind 'SEMICOLON))
						'OPERATOR)
					       (t 'LEFT-ENCLOSER)))
					((or (eq rightkind 'RIGHT-PARENTHESIS)
					     (eq rightkind 'RIGHT-BRACKET)
					     (eq rightkind 'RIGHT-WHITE-BRACKET)
					     (eq rightkind 'RIGHT-ENCLOSER)
					     (eq rightkind 'COMMA)
					     (eq rightkind 'SEMICOLON))
					 'RIGHT-ENCLOSER)
					((and leftspace (not rightspace))
					 'LEFT-ENCLOSER)
					((and (not leftspace) rightspace)
					 'RIGHT-ENCLOSER)
					(t 'OPERATOR))))
		     (push (cons newkind (cdr tok)) result)))))
	      (t (push tok result)))))
    (reverse result)))

;;; ****************************************************************
;;; ***** (3) Compute an initial rendering of each individual token.
;;; ****************************************************************

(defun fortify-token-list (tokens)
  ;; Later take care of contextual stuff, such as subscripting brackets
  ;; Later take care of stuff that goes between tokens
  (mapcar 'fortify-single-token tokens))

(defun fortify-single-token (token)
  (list (car token) 
	(cadr token)
	(ecase (car token)
	       (AMPERSAND (fortress-render-ampersand (cadr token)))
	       (BIGOP (fortress-render-bigop (cadr token)))
	       (CHARACTER-LITERAL (fortress-render-character-literal (cadr token)))
	       (CIRCUMFLEX (fortress-render-circumflex (cadr token)))
	       (COLON (fortress-render-colon (cadr token)))
	       (COMMA (fortress-render-comma (cadr token)))
	       (COMMENT (fortress-render-comment (cadr token)))
	       (COMMENT-LINE (fortress-render-comment-line (cadr token)))
	       ((COMMENT-START COMMENT-MIDDLE COMMENT-END) "") ;handled in phase (5)
	       (DIGIT-GROUP-SEPARATOR (fortress-render-digit-group-separator (cadr token)))
	       (DOT (fortress-render-dot (cadr token)))
	       (IDENTIFIER (fortress-render-identifier (cadr token)))
	       (KEYWORD (fortress-render-keyword (cadr token)))
	       (LEFT-BRACKET (fortress-render-left-bracket (cadr token)))
	       (LEFT-ENCLOSER (fortress-render-left-encloser (cadr token)))
	       (LEFT-PARENTHESIS (fortress-render-left-parenthesis (cadr token)))
	       (LEFT-WHITE-BRACKET (fortress-render-left-white-bracket (cadr token)))
	       (NEWLINE (fortress-render-newline (cadr token)))
	       (NUMBER (fortress-render-number (cadr token)))
	       (OPERATOR (fortress-render-operator (cadr token)))
	       (OPERATOR-WORD (fortress-render-operator-word (cadr token)))
	       (RIGHT-BRACKET (fortress-render-right-bracket (cadr token)))
	       (RIGHT-ENCLOSER (fortress-render-right-encloser (cadr token)))
	       (RIGHT-PARENTHESIS (fortress-render-right-parenthesis (cadr token)))
	       (RIGHT-WHITE-BRACKET (fortress-render-right-white-bracket (cadr token)))
	       (SEMICOLON (fortress-render-semicolon (cadr token)))
	       (STRING (fortress-render-string (cadr token)))
	       (STRING-END (fortress-render-string-end (cadr token)))
	       (STRING-MIDDLE (fortress-render-string-middle (cadr token)))
	       (STRING-START (fortress-render-string-start (cadr token)))
	       (UNKNOWN (fortress-render-unknown (cadr token)))
	       (WHITESPACE (fortress-render-whitespace (cadr token)))
	       )))

(defun fortress-render-character-literal (str)
  (let ((ends-in-single-quote (and (> (length str) 1)
				   (or (= (elt str (- (length str) 1)) ?\')
				       (= (elt str (- (length str) 1)) ?\u2019)))))
    (let ((contents (substring str 1 (max 1 (- (length str) (if ends-in-single-quote 1 0))))))
      (concat "\\hbox{\\rm\\usefont{T1}{ptm}{m}{n}`"
	      (or (fortress-render-character-contents contents)
		  (if (= (length contents) 0) "\\verythin"
		    (concat "\\STR{" (fortress-render-string-contents contents) "}")))
	      (if ends-in-single-quote "'}" "}")))))

(defun fortress-render-character-contents (str)
  (let ((rendering (or (gethash str *fortress-identifier-word-hashtable*)
		       (gethash str *fortress-operator-hashtable*)
		       (gethash str *fortress-operator-word-hashtable*)
		       (gethash str *fortress-honorary-letter-word-hashtable*)
		       (gethash str *fortress-left-encloser-hashtable*)
		       (gethash str *fortress-right-encloser-hashtable*)
		       (and (string= str "[\\") (fortress-render-left-white-bracket str))
		       (and (string= str "\\]") (fortress-render-right-white-bracket str)))))
    (and rendering (concat "$" rendering "$"))))

(defun fortress-render-digit-group-separator (str) "\\,")

(defun fortress-render-keyword (str)
  (ecase (gethash str *fortress-keyword-hashtable*)
    ((KEYWORD) (concat "\\KWD{" (fortress-tex-keyword-render str) "}"))
    ((IDENTIFIER) (concat "\\KWDVAR{" (fortress-tex-keyword-render str) "}"))))

;;; This code closely follows the rules in Fortress Language Specification
;;; Appendix D: Rendering of Fortress Identifiers.

(defun fortress-render-identifier (str)
  (or (gethash str *fortress-identifier-word-hashtable*)
      (let* ((portions (fortress-identifier-portions str))
	     (sep1 (elt portions 0))
	     (basename (elt portions 1))
	     (sep2 (elt portions 2)))
	(cond ((null (cddr portions))
	       ;; Special case: a single connector, such as "_"
	       (concat "\\VAR{" (fortress-tex-id-render str) "}"))
	      (t (do ((p portions (cddr p)))
		     ((null (cdr p))
		      ;; All portions are non-empty
		      (cond ((and (= (length portions) 3)
				  (not (unicode-is-prime (elt basename 0))))
			     (cond ((and (string= sep1 "")
					 (string= sep2 ""))
				    (fortress-render-identifier-no-underscores-or-primes portions))
				   ((and (or (string= sep1 "") (string= sep1 "_"))
					 (or (string= sep2 "") (string= sep2 "_")))
				    (fortress-render-identifier-simple-fonts portions))
				   (t (fortress-render-identifier-general-case str portions))))
			    (t (fortress-render-identifier-general-case str portions))))
		   (when (= (length (cadr p)) 0)
		     ;; Case (h): empty portion found
		     (return (concat "\\VAR{" (fortify-careful-TeX-concat (mapcar 'fortress-tex-id-render-maybe-greek portions)) "}")))))))))

(defun fortress-render-identifier-no-underscores-or-primes (portions)
  (let* ((basename (elt portions 1))
	 (c (elt basename 0)))
    (cond ((and (>= (length basename) 2)
		(= c (elt basename 1))
		(<= ?A c)
		(<= c ?Z)
		(every 'unicode-is-digit (substring basename 2)))
	   ;; Case (a)
	   (concat "\\mathbb{" (substring str 0 1) "}"
		   (fortress-tex-id-render (substring basename 2))))
	  ((and (>= (length basename) 2)
		(unicode-is-uppercase c))
	   ;; Case (b)
	   (concat "\\TYP{" (fortress-tex-id-render basename) "}"))
	  (t (let* ((pos (position-if 'unicode-is-digit basename))
		    (part1 (and pos (substring basename 0 pos)))
		    (part2 (and pos (substring basename pos))))
	       (cond ((and pos
			   (> pos 0)
			   (every 'fortress-is-letter part1)
			   (every 'unicode-is-digit part2))
		      ;; Case (c)
		      (concat (or (gethash part1 *fortress-identifier-word-hashtable*)
				  (fortress-var part1))
			      (fortress-simple-subscript part2)))
		     (t (let ((trad (gethash basename *fortress-traditional-name-hashtable*)))
			  (cond (trad
				 ;; Case (d)
				 trad)
				(t
				 ;; Case (e)
				 (cond ((= (length basename) 1)
					(fortress-tex-id-render basename))
				       (t (concat "\\VAR{" (fortress-tex-id-render basename) "}")))))))))))))

(defun fortress-render-identifier-simple-fonts (portions)
  (let* ((sep1 (elt portions 0))
	 (basename (elt portions 1))
	 (sep2 (elt portions 2))
	 (c (elt basename 0)))
    (cond ((and (>= (length basename) 2)
		(= c (elt basename 1))
		(<= ?A c)
		(<= c ?Z)
		(every 'unicode-is-digit (substring basename 2)))
	   ;; Case (f)
	   (concat (cond ((string= sep2 "") "\\mathsf{")
			 ((string= sep1 "") "\\mathcal{")
			 (t "\\mathitsf{"))
		   (substring basename 0 1) "}"
		   (fortress-simple-subscript (substring basename 2))))
	  (t (let* ((pos (position-if 'unicode-is-digit basename))
		    (part1 (and pos (substring basename 0 pos)))
		    (part2 (and pos (substring basename pos))))
	       (cond ((and pos
			   (every 'fortress-is-letter part1)
			   (every 'unicode-is-digit part2))
		      ;; Case (g) exception
		      (concat (fortress-render-identifier-case-g sep1 part1 sep2)
			      (fortress-simple-subscript part2)))
		     (t
		      ;; Case (g) general case
		      (fortress-render-identifier-case-g sep1 basename sep2))))))))

(defun fortress-render-identifier-case-g (sep1 basename sep2)
  (cond ((string= sep2 "") (concat "\\mathbf{" (fortress-tex-id-render-maybe-greek basename) "}"))
	((string= sep1 "") (concat "\\mathrm{" (fortress-tex-id-render-maybe-greek basename) "}"))
	(t (concat "\\hbox{\\bf\\emph{" (fortress-tex-id-render-maybe-greek basename) "}}"))))

(defun fortress-any-empty-portion (portions)
  (and (cdr portions)
       (or (= (length (cadr portions)) 0)
	   (fortress-any-empty-portion (cddr portions)))))

(defun fortress-render-identifier-general-case (str portions)
  ;; Note that "portions" are handled a little differently by this
  ;; code than by the specification; an empty portion that precedes
  ;; a leading underscore or follows a trailing underscore is not
  ;; represented in the portions list at all.
  (cond ((fortress-any-empty-portion portions) (fortress-var str))
	(t (let ((face-info (gethash (elt portions 1) *fortress-identifier-face-hashtable*)))
	     (cond ((null face-info)
		    (let* ((principal-portion (elt portions 1))
			   (c (elt principal-portion 0))
			  (other-portions (cddr portions)))
		      (cond ((and (>= (length principal-portion) 2)
				  (= c (elt principal-portion 1))
				  (<= ?A c)
				  (<= c ?Z)
				  (every 'unicode-is-digit (substring principal-portion 2)))
			     (let ((base (fortress-tex-id-render (substring principal-portion 0 1))))
			       (fortress-render-identifier-general-case-loop
				(cond ((string= (car (last portions)) "_")
				       (cond ((string= (first portions) "_")
					      (concat "\\mathitsf{" base "}"))
					     (t (concat "\\mathcal{" base "}"))))
				      (t (cond ((string= (first portions) "_")
						(concat "\\mathsf{" base "}"))
					       (t (concat "\\mathbb{" base "}")))))
				t
				(and (> (length principal-portion) 2)
				     (substring principal-portion 2))
				""
				other-portions)))
			    (t (let* ((pos (position-if 'unicode-is-digit principal-portion))
				      (part1 (and pos (substring principal-portion 0 pos)))
				      (part2 (and pos (substring principal-portion pos))))
				 (cond ((and pos
					     (> pos 0)
					     (every 'fortress-is-letter part1)
					     (every 'unicode-is-digit part2))
					(let ((base (fortress-tex-id-render-maybe-greek (substring principal-portion 0 pos))))
					  (fortress-render-identifier-general-case-loop
					   (cond ((string= (car (last portions)) "_")
						  (cond ((string= (first portions) "_")
							 (concat "\\hbox{\\bf\\emph{" base "}}"))
							(t (concat "\\mathrm{" base "}"))))
						 (t (cond ((string= (first portions) "_")
							   (concat "\\mathbf{" base "}"))
							  ((gethash (substring principal-portion 0 pos)
								    *fortress-identifier-word-hashtable*)
							   base)
							  ((> pos 1)
							   (concat "\\VAR{" base "}"))
							  (t base))))
					   (= pos 1)
					   (substring principal-portion pos)
					   ""
					   other-portions)))
				       (t (let ((base (fortress-tex-id-render-maybe-greek principal-portion)))
					    (fortress-render-identifier-general-case-loop
					     (cond ((string= (car (last portions)) "_")
						    (cond ((string= (first portions) "_")
							   (concat "\\hbox{\\bf\\emph{" base "}}"))
							  (t (concat "\\mathrm{" base "}"))))
						   (t (cond ((string= (first portions) "_")
							     (concat "\\mathbf{" base "}"))
							    ((gethash (substring principal-portion 0 pos)
								      *fortress-identifier-word-hashtable*)
							     base)
							    ((> (length principal-portion) 1)
							     (concat "\\VAR{" base "}"))
							    (t base))))
					     (or (= (length principal-portion) 1)
						 (gethash principal-portion *fortress-identifier-word-hashtable*))
					     ""
					     ""
					     other-portions)))))))))
		   (t (let ((principal-portion (and (> (length portions) 3) (elt portions 3)))
			    (other-portions (cddr (cddr portions))))
			(cond ((null principal-portion) (fortress-var str))
			      (t (let ((base (fortress-tex-id-render-maybe-greek principal-portion))
				       (face (elt face-info
						  (cond ((string= (car (last portions)) "_")
							 (cond ((string= (first portions) "_") 3) (t 1)))
							(t (cond ((string= (first portions) "_") 2) (t 0)))))))
				   
				   (cond (face (fortress-render-identifier-general-case-loop
						(concat face "{" base "}")
						(or (= (length principal-portion) 1)
						    (gethash principal-portion *fortress-identifier-word-hashtable*))
						"" 
						""
						other-portions))
					 (t (fortress-render-identifier-general-case-loop
					     (concat "\\VAR{"
						     (fortress-tex-id-render (elt portions 0))
						     (fortress-tex-id-render (elt portions 1))
						     (fortress-tex-id-render (elt portions 2))
						     base
						     "}")
					     nil
					     "" 
					     ""
					     other-portions)))
				   ))))))))))

(defun fortress-render-identifier-general-case-loop (basevar singletonflag subscript superscript other-portions)
  (cond ((null (cdr other-portions))
	 (concat basevar
		 (fortress-subscript-fixup subscript)
		 (fortress-superscript-fixup superscript)))
	((string= (cadr other-portions) "bar")
	 (fortress-render-identifier-general-case-loop
	  (concat (if singletonflag "\\bar{" "\\overline{") (fortress-ij-fixup singletonflag basevar) "}")
	  singletonflag subscript superscript (cddr other-portions)))
	((string= (cadr other-portions) "vec")
	 (fortress-render-identifier-general-case-loop
	  (concat (if singletonflag "\\vec{" "\\overrightarrow{") (fortress-ij-fixup singletonflag basevar) "}")
	  singletonflag subscript superscript (cddr other-portions)))
	((string= (cadr other-portions) "hat")
	 (fortress-render-identifier-general-case-loop
	  (concat (if singletonflag "\\hat{" "\\widehat{") (fortress-ij-fixup singletonflag basevar) "}")
	  singletonflag subscript superscript (cddr other-portions)))
	((string= (cadr other-portions) "tilde")
	 (fortress-render-identifier-general-case-loop
	  (concat (if singletonflag "\\tilde{" "\\widetilde{") (fortress-ij-fixup singletonflag basevar) "}")
	  singletonflag subscript superscript (cddr other-portions)))
	((string= (cadr other-portions) "check")
	 (fortress-render-identifier-general-case-loop
	  (concat "\\check{" (fortress-ij-fixup singletonflag basevar) "}")
	  singletonflag subscript superscript (cddr other-portions)))
	((string= (cadr other-portions) "acute")
	 (fortress-render-identifier-general-case-loop
	  (concat "\\acute{" (fortress-ij-fixup singletonflag basevar) "}")
	  singletonflag subscript superscript (cddr other-portions)))
	((string= (cadr other-portions) "grave")
	 (fortress-render-identifier-general-case-loop
	  (concat "\\grave{" (fortress-ij-fixup singletonflag basevar) "}")
	  singletonflag subscript superscript (cddr other-portions)))
	((string= (cadr other-portions) "breve")
	 (fortress-render-identifier-general-case-loop
	  (concat "\\breve{" (fortress-ij-fixup singletonflag basevar) "}")
	  singletonflag subscript superscript (cddr other-portions)))
	((string= (cadr other-portions) "dot")
	 (cond ((and (> (length other-portions) 3) (string= (elt other-portions 3) "dot"))
		(cond ((and (> (length other-portions) 5) (string= (elt other-portions 5) "dot"))
		       (cond ((and (> (length other-portions) 7) (string= (elt other-portions 7) "dot"))
			      (fortress-render-identifier-general-case-loop
			       (concat "\\ddddot{" (fortress-ij-fixup singletonflag basevar) "}")
			       singletonflag subscript superscript (cddr (cddr (cddr (cddr other-portions))))))
			     (t (fortress-render-identifier-general-case-loop
				 (concat "\\dddot{" (fortress-ij-fixup singletonflag basevar) "}")
				 singletonflag subscript superscript (cddr (cddr (cddr other-portions)))))))
		      (t (fortress-render-identifier-general-case-loop
			  (concat "\\ddot{" (fortress-ij-fixup singletonflag basevar) "}")
			  singletonflag subscript superscript (cddr (cddr other-portions))))))
	       (t (fortress-render-identifier-general-case-loop
		   (concat "\\dot{" (fortress-ij-fixup singletonflag basevar) "}")
		   singletonflag subscript superscript (cddr other-portions)))))
	((string= (cadr other-portions) "star")
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript (concat superscript "*") (cddr other-portions)))
	((string= (cadr other-portions) "plus")
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript (concat superscript "+") (cddr other-portions)))
	((string= (cadr other-portions) "minus")
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript (concat superscript "-") (cddr other-portions)))
	((string= (cadr other-portions) "splat")
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript (concat superscript "\\#") (cddr other-portions)))
	((string= (cadr other-portions) "prime")
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript (concat superscript "\\prime") (cddr other-portions)))
	((or (string= (cadr other-portions) "'")
	     (string= (cadr other-portions) "\u2032")) ;PRIME
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript (concat superscript "\\prime") (cddr other-portions)))
	((string= (cadr other-portions) "\u2033") ;DOUBLE PRIME
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript (concat superscript "\\prime\\prime") (cddr other-portions)))
	((string= (cadr other-portions) "\u2034") ;TRIPLE PRIME
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript (concat superscript "\\prime\\prime\\prime") (cddr other-portions)))
	((string= (cadr other-portions) "\u2057") ;QUADRUPLE PRIME
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript (concat superscript "\\prime\\prime\\prime\\prime") (cddr other-portions)))
	((and (string= (cadr other-portions) "super") (cdddr other-portions))
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag subscript
	  (fortress-add-s-script superscript (elt other-portions 3))
	  (cddr (cddr other-portions))))
	((and (string= (cadr other-portions) "sub") (cdddr other-portions))
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag
	  (fortress-add-s-script subscript (elt other-portions 3))
	  superscript (cddr (cddr other-portions))))
	((and (every 'unicode-is-uppercase (cadr other-portions))
	      (gethash (cadr other-portions) *fortress-operator-hashtable*))
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag
	  (fortress-add-s-script subscript 
				 (gethash (cadr other-portions) *fortress-operator-hashtable*))
	  superscript (cddr other-portions)))
	((and singletonflag (null (cdddr other-portions)))
	 (fortress-render-identifier-general-case-loop
	  basevar singletonflag
	  (fortress-add-s-script subscript (cadr other-portions))
	  superscript (cddr other-portions)))
	(t (concat basevar
		   (fortress-subscript-fixup subscript)
		   (fortress-superscript-fixup superscript)
		   "\\mathit{"
		   (apply 'concat (mapcar 'fortress-tex-id-render-maybe-greek other-portions))
		   "}"))))

(defun fortress-ij-fixup (singletonflag basevar)
  (cond ((null singletonflag) basevar)
	((= (length basevar) 1)
	 (cond ((= (elt basevar 0) ?i) "\\imath")
	       ((= (elt basevar 0) ?j) "\\jmath")
	       (t basevar)))
	(t (let ((last3 (substring basevar (- (length basevar) 3))))
	     (cond ((string= last3 "{i}")
		    (cond ((string= basevar "\\mathrm{i}") "\\hbox{\\rm\\i}")
			  ((string= basevar "\\mathbf{i}") "\\hbox{\\bf\\i}")
			  (t basevar)))
		   ((string= last3 "{j}")
		    (cond ((string= basevar "\\mathrm{j}") "\\hbox{\\rm\\j}")
			  ((string= basevar "\\mathbf{j}") "\\hbox{\\bf\\j}")
			  (t basevar)))
		   ((string= last3 "i}}")
		    (cond ((string= basevar "\\hbox{\\bf\\emph{i}}") "\\hbox{\\bf\\emph{\\i}}")
			  (t basevar)))
		   ((string= last3 "j}}")
		    (cond ((string= basevar "\\hbox{\\bf\\emph{j}}") "\\hbox{\\bf\\emph{\\j}}")
			  (t basevar)))
		   (t basevar))))))

(defun fortress-subscript-fixup (str)
 (let ((n (length str)))
  (cond ((= n 0) str)
	((= n 1) (concat "_" str))
	(t (concat "_{" str "}")))))

(defun fortress-superscript-fixup (str)
 (let ((n (length str)))
  (cond ((= n 0) str)
	((= n 1) (concat "^" str))
	((string= str "\\#") "^\\#")
	((and (= (mod n 6) 0)
	      (do ((k 0 (+ k 6))
		   (flag t (and flag (string= (substring str k (+ k 6)) "\\prime"))))
		  ((= k n) flag)))
	      (do ((k 0 (+ k 6))
		   (result "" (concat "'" result)))
		  ((= k n) result)))
	(t (concat "^{" str "}")))))
			   
(defun fortress-add-s-script (subscript str)
  (let ((z (cond ((every 'unicode-is-digit str) (concat "(" (fortress-tex-id-render str) ")"))
		 (t (concat "\\mathrm{" (fortress-tex-id-render-maybe-greek str) "}")))))
    (cond ((= (length subscript) 0) z)
	  (t (concat subscript "," z)))))

(defun fortress-var (str)
  (let ((rendering (fortress-tex-id-render str)))
    (cond ((= (length str) 1) rendering)
	  (t (concat "\\VAR{" rendering "}")))))

(defun fortress-simple-subscript (str)
  (cond ((= (length str) 0) "")
	(t (let ((rendering (fortress-tex-id-render str)))
	     (cond ((= (length str) 1) (concat "_" rendering))
		   (t (concat "_{" rendering "}")))))))

;;; The result of splitting an identifier into portions is a list
;;; of odd length that is at least 3.  The n portions are at
;;; odd-numbered positions, and the n+1 separators are at even-numbered
;;; positions.  Each separator will typically be either an underscore
;;; or empty.

(defun fortress-identifier-portions (str)
  (let ((s 0) (result '("")))
    (dotimes (k (length str))
      (let ((c (elt str k)))
	(cond ((= c ?_)
	       (cond ((= k 0) (setq result (list (substring str 0 1))))
		     ((and (= (length (car result)) 0)
			   (= (length (cadr result)) 1)
			   (let ((prevc (elt (cadr result) 0)))
			     (or (= prevc ?') (unicode-is-prime prevc))))
		      (pop result)
		      (push (substring str k (+ k 1)) result))
		     (t (push (substring str s k) result)
			(push (substring str k (+ k 1)) result)))
	       (setq s (+ k 1)))
	      ((and (= c ?')
		    (every '(lambda (z) (= z ?')) (substring str k (- (length str) 1)))
		    (let ((lastc (elt str (- (length str) 1))))
		      (or (= lastc ?') (= lastc ?_))))
	       (when (> k s)
		 (push (substring str s k) result)
		 (push "" result))
	       (push (substring str k (+ k 1)) result)
	       (push "" result)
	       (setq s (+ k 1)))
	      ((<= c #x7f))
	      ((unicode-is-prime c)
	       (when (> k s)
		 (push (substring str s k) result)
		 (push "" result))
	       (push (substring str k (+ k 1)) result)
	       (push "" result)
	       (setq s (+ k 1))))))
    (when (> (length str) s)
      (push (substring str s) result)
      (push "" result))
    ;; Implement the ad-hoc underscore elimination rule for Greek letters.
    (when (and (> (length result) 4)
	       (string= (car result) "_")
	       (string= (caddr result) "_")
	       (gethash (cadr result) *fortress-identifier-word-hashtable*))
      (rplaca (cddr result) ""))
    (reverse result)))

(defun fortress-tex-id-render (str)
  (cond ((every '(lambda (c) (and (<= c #x7f) (not (= c ?_)))) str) str)
	(t (fortify-careful-TeX-concat
	    (mapcar '(lambda (c) (if (<= c #x7f)
				     (if (= c ?_) "{\\tt\\_\\verythin}" (string c))
				   (or (gethash c *fortress-identifier-codepoint-hashtable*)
				       (gethash c *fortress-honorary-letter-codepoint-hashtable*)
				       (gethash c *fortress-control-character-hashtable*)
				       (fortress-render-unknown-character c))))
		    str)))))

(defun fortress-tex-id-render-maybe-greek (str)
  (or (gethash str *fortress-identifier-word-hashtable*)
      (fortress-tex-id-render str)))

(defun fortress-tex-keyword-render (str)
  (cond ((every '(lambda (c) (and (<= c #x7f) (not (= c ?_)))) str) str)
	(t (fortify-careful-TeX-concat
	    (mapcar '(lambda (c) (if (<= c #x7f)
				     (if (= c ?_) "\\_" (string c))
				   (or (gethash c *fortress-identifier-codepoint-hashtable*)
				       (gethash c *fortress-honorary-letter-codepoint-hashtable*)
				       (gethash c *fortress-control-character-hashtable*)
				       (fortress-render-unknown-character c))))
		    str)))))

(defun fortress-render-number (str)
  (let ((k (position ?\_ str)))
    (cond ((null k)
	   (cond ((every '(lambda (c) (find c "0123456789.")) str) str)
		 ((every '(lambda (c) (find c "0123456789'.")) str)
		  (concat "\\mathord{"
			  (fortress-render-number-contents str)
			  "}"))
		 (t (concat "\\mathord{\\mathtt{"
			    (fortress-render-number-contents str)
			    "}}"))))
	  (t (let ((num (substring str 0 k))
		   (radix (substring str (+ k 1) (length str))))
	       (cond ((gethash radix *fortress-radix-specifier-hashtable*)
		      (concat "\\mathtt{"
			      (fortress-render-number-contents num)
			      "}_{\\,\\hbox{\\small\\sc "
			      radix
			      "}}"))
		     (t (concat "\\mathtt{"
				(fortress-render-number-contents num)
				"}_{"
				radix
				"}"))))))))

(defun fortress-render-number-contents (str)
  (let ((result ""))
    (dotimes (k (length str))
      (let ((c (elt str k)))
	(setq result
	      (concat result
		      (cond ((= c ?\') "\\,")
			    ((= c ?\u202F) "\\,")
			    (t (substring str k (+ k 1))))))))
    result))

(defun fortress-render-operator-word (str)
  (or (gethash str *fortress-operator-word-hashtable*)
      (gethash str *fortress-honorary-letter-word-hashtable*)
      (fortress-render-operator-word-having-prefix str "COMPREHENSIVE_PREFIX_" "\\comprehensiveprefix{" "}")
      (fortress-render-operator-word-having-prefix str "COMPREHENSIVE_SUFFIX_" "\\comprehensivesuffix{" "}")
      (fortress-render-operator-word-having-prefix str "EXCLUSIVE_PREFIX_" "\\exclusiveprefix{" "}")
      (fortress-render-operator-word-having-prefix str "EXCLUSIVE_SUFFIX_" "\\exclusivesuffix{" "}")
      (fortress-render-operator-word-having-prefix str "PREFIX_" "\\inclusiveprefix{" "}")
      (fortress-render-operator-word-having-prefix str "SUFFIX_" "\\inclusivesuffix{" "}")
      (concat "\\OPR{" (fortress-render-string-contents str) "}")))

(defun fortress-render-operator-word-having-prefix (str prefix before after)
  (and (> (length str) (length prefix))
       (string= (substring str 0 (length prefix)) prefix)
       (concat "\\mathbin{" before (fortress-render-operator-word (substring str (length prefix))) after "}")))

(defun fortress-render-operator (str)
  (or (cond ((= (length str) 1)
	     (gethash (elt str 0) *fortress-operator-codepoint-hashtable*))
	    (t (gethash str *fortress-operator-hashtable*)))
      (and (every '(lambda (c) (= c ?\.)) str)
	   (concat "\\mathinner{" (reduce 'concat (make-list (length str) "\\ldotp")) "}"))
      (concat "\\OPR{" (fortress-render-string-contents str) "}")))

(defun fortress-render-bigop (str)
  (or (cond ((= (length str) 1)
	     (gethash (elt str 0) *fortress-operator-codepoint-hashtable*))
	    (t (gethash str *fortress-operator-word-hashtable*)))
      (concat "\\OPR{" (fortress-render-string-contents str) "}")))

(defun fortress-render-left-parenthesis (str) str)

(defun fortress-render-right-parenthesis (str) str)

(defun fortress-render-left-bracket (str) str)

(defun fortress-render-right-bracket (str) str)

(defun fortress-render-left-encloser (str)
  (or (gethash str *fortress-left-encloser-hashtable*)
      (fortress-render-string-contents str)))

(defun fortress-render-right-encloser (str)
  (or (gethash str *fortress-right-encloser-hashtable*)
      (fortress-render-string-contents str)))

(defun fortress-render-left-white-bracket (str) "\\llbracket")

(defun fortress-render-right-white-bracket (str) "\\rrbracket")

(defun fortress-render-colon (str) "\\COLONOP")

(defun fortress-render-semicolon (str) str)

(defun fortress-render-comma (str) str)

(defun fortress-render-dot (str) str)

(defun fortress-render-circumflex (str)
  (concat "\\OPR{" (fortress-render-string-contents str) "}"))

(defun fortress-render-ampersand (str) 
  (concat "\\OPR{" (fortress-render-string-contents str) "}"))

(defun fortress-render-string (str)
  (let ((ends-in-double-quote (and (> (length str) 1)
				   (or (= (elt str (- (length str) 1)) ?\")
				       (= (elt str (- (length str) 1)) ?\u201D)))))
    (let ((contents (substring str 1 (max 1 (- (length str) (if ends-in-double-quote 1 0))))))
      (concat "\\hbox{\\rm\\usefont{T1}{ptm}{m}{n}``"
	      (if (= (length contents) 0) "\\verythin"
		(concat "\\STR{" (fortress-render-string-contents contents) "}"))
	      (if ends-in-double-quote "''}" "}")))))

(defun fortress-render-string-start (str) (fortress-render-string str))

(defun fortress-render-string-middle (str)
  (concat "\\hbox{\\rm"
	  (if (= (length str) 0) ""
	    (concat "\\STR{" (fortress-render-string-contents str) "}"))
	  "}"))

(defun fortress-render-string-end (str)
  (let ((ends-in-double-quote (and (> (length str) 1)
				   (or (= (elt str (- (length str) 1)) ?\")
				       (= (elt str (- (length str) 1)) ?\u201D)))))
    (let ((contents (substring str 0 (max 0 (- (length str) (if ends-in-double-quote 1 0))))))
      (concat "\\hbox{\\rm"
	      (if (= (length contents) 0) ""
		(concat "\\STR{" (fortress-render-string-contents contents) "}"))
	      (if ends-in-double-quote "''}" "}")))))

(defun fortress-render-unknown (str)
  (if (and (= (length str) 1) (= (elt str 0) ?\r))
      ""
    (concat "\\underline{" (fortress-render-string-contents str) "}")))

;;; The result of this function is suitable for \tt environments.

(defun fortress-render-string-contents (str)
  (let ((result ""))
    (dotimes (k (length str))
      (let ((c (elt str k)))
	(setq result
	      (concat result
		      (cond ((= c ?\s) "~")
			    ((= c ?\\) "{\\char'134}")
			    ((= c ?\{) "{\\char'173}")
			    ((= c ?\}) "{\\char'175}")
			    ((= c ?\|) "{\\char'174}")
			    ((= c ?\#) "{\\char'43}")
			    ((= c ?\$) "{\\char'44}")
			    ((= c ?\%) "{\\char'45}")
			    ((= c ?\&) "{\\char'46}")
			    ((= c ?\') "{\\char'47}")
			    ((= c ?\-) "{-}")
			    ((= c ?^) "{\\char'136}")
			    ((= c ?\`) "{\\char'140}")
			    ((= c ?\~) "{\\char'176}")
			    ((= c ?\_) "{\\char'137}")
			    ((and (> c #x20) (< c #x7f))
			     (substring str k (+ k 1)))
			    (t (concat "{$"
				       (or (gethash c *fortress-operator-codepoint-hashtable*)
					   (gethash c *fortress-honorary-letter-codepoint-hashtable*)
					   (gethash c *fortress-identifier-codepoint-hashtable*)
					   (gethash c *fortress-control-character-hashtable*)
					   (fortress-render-unknown-character c))
				       "$}")))))))
    result))

;;; The result of this function is suitable for \rm, \it, \bf environments.

(defun fortress-render-text (str)
  (let ((result ""))
    (dotimes (k (length str))
      (let ((c (elt str k)))
	(setq result
	      (concat result
		      (cond ((= c ?\s) "~")
			    ((= c ?\\) "{$\\backslash$}")
			    ((= c ?\{) "{$\\{$}")
			    ((= c ?\}) "{$\\}}")
			    ((= c ?\|) "{$|$}")
			    ((= c ?\#) "\\#")
			    ((= c ?\$) "\\$")
			    ((= c ?\%) "\\%")
			    ((= c ?\&) "\\&")
			    ((= c ?\') "{'}")
			    ((= c ?^) "{\\char'136}")
			    ((= c ?\`) "{`}")
			    ((= c ?\~) "{\\char'176}")
			    ((= c ?\_) "{\\_}")
			    ((and (> c #x20) (< c #x7f))
			     (substring str k (+ k 1)))
			    (t (concat "{$"
				       (or (gethash c *fortress-operator-codepoint-hashtable*)
					   (gethash c *fortress-honorary-letter-codepoint-hashtable*)
					   (gethash c *fortress-identifier-codepoint-hashtable*)
					   (gethash c *fortress-control-character-hashtable*)
					   (fortress-render-unknown-character c))
				       "}")))))))
    result))

(defun fortress-render-unknown-character (c)
  (concat "\\FortressUnknownCharacter{U+" (format "%04X" c) "}"))

(defun fortress-render-newline (str) " \\\\\n")

(defun fortress-render-whitespace (str) str)
 
(defun fortress-render-comment (str)
  (let ((startpos (position-if-not '(lambda (x) (= x ?\*)) str :start 1))
	(endpos (+ 1 (position-if-not '(lambda (x) (= x ?\*)) str :end  (- (length str) 1) :from-end t))))
    (cond ((> startpos endpos)
	   ;; Must be a comment containing nothing but asterisks!
	   (concat "\\hbox{\\tt" str "}"))
	  (t (concat "\\fortressonelinecomment{"
		     (substring str 0 startpos)
		     "}{"
		     (fortress-render-wiki-creole-line (substring str startpos endpos))
		     "}{"
		     (substring str endpos)
		     "}")))))

;;; Multiline comments are processed by a later phase.

(defun fortress-render-comment-start (str) str)

(defun fortress-render-comment-middle (str) str)

(defun fortress-render-comment-end (str) str)

(defun fortress-render-comment-line (str)
  (concat "\\*{"
	  (fortress-render-wiki-creole-line (substring str 3))
	  "}"))


;;; ***** Processing of Wiki Creole for comments

;;; A fontstate is a stack of triples (type start end)
;;; where each "type" is one of BOLD ITALIC MONOSPACE QUOTE
;;; and "start" and "end" are TeX strings that establish
;;; and conclude that type.  The QUOTE type is used to
;;; handle double quotes.

(defun fortress-render-wiki-creole-line (str)
  (multiple-value-bind (processed-line newstate ends-with-tilde)
      (fortress-render-wiki-creole-line-and-state str '() nil nil nil)
    ;; Discard newstate and ends-with-tilde
    processed-line))

;;; Returns three values: the processed line, the updated fontstate, and whether the line
;;; ended with a "~" that is presumed to quote the following newline.
;;; If table-p is false, the processed line is returned as a single string;
;;; If table-p is true, the processed line is returned as an odd-length list;
;;; the even-numbered items (starting from 0) are possibly empty strings of "|" characters,
;;; and the odd-numbered items are 2-lists of the rendered table cell contents and its type.
;;; Table cell types are:
;;;    BLANK    consisting solely of spaces
;;;    SEP      consisting solely of a nonzero number of "-" characters
;;;    SEPSEP   consisting solely of a nonzero number of "=" characters
;;;    HEADING  first nonblank character is "=", and contains characters other than "="
;;;    NORMAL   nothing special

(defun fortress-render-wiki-creole-line-and-state (str fontstate multiline-p description-p table-p)
  (let ((result "")
	(table-result '())
	(ends-with-tilde nil)
	(blank t)
	(sep t)
	(sepsep t)
	(heading nil)
	(n (length str))
	(k 0))
    (while (< k n)
      (let ((c (elt str k))
	    (d (if (< (+ k 1) n) (elt str (+ k 1)) 0)))
	(cond ((= c ?\|))
	      ((= c ?\s) (setq sep nil) (setq sepsep nil))
	      ((= c ?\-) (setq blank nil) (setq sepsep nil))
	      ((= c ?\=) (when blank (setq heading t)) (setq sep nil) (setq blank nil))
	      (t (setq blank nil) (setq sep nil) (setq sepsep nil)))
	(let ((moretext (cond ((and (= c ?\*) (= d ?\*))
			       (setq k (+ k 2))
			       (cond ((eq (caar fontstate) 'BOLD) (caddr (pop fontstate)))
				     (t (push (fortress-add-wiki-fontstate 'BOLD '() fontstate) fontstate)
					(cadr (car fontstate)))))
			      ((and (= c ?\/) (= d ?\/))
			       (setq k (+ k 2))
			       (cond ((eq (caar fontstate) 'ITALIC) (caddr (pop fontstate)))
				     (t (push (fortress-add-wiki-fontstate 'ITALIC '() fontstate) fontstate)
					(cadr (car fontstate)))))
			      ((and (= c ?\#) (= d ?\#))
			       (setq k (+ k 2))
			       (cond ((eq (caar fontstate) 'MONOSPACE) (caddr (pop fontstate)))
				     (t (push (fortress-add-wiki-fontstate 'MONOSPACE '() fontstate) fontstate)
					(cadr (car fontstate)))))
			      ((= c ?\")
			       (setq k (+ k 1))
			       (cond ((eq (caar fontstate) 'QUOTE) (caddr (pop fontstate)))
				     (t (push (fortress-add-wiki-fontstate 'QUOTE '() fontstate) fontstate)
					(cadr (car fontstate)))))
			      ((and (= c ?\{)
				    (= d ?\{)
				    (< (+ k 2) n)
				    (= (elt str (+ k 2)) ?\{)
				    (search "}}}" str :start2 k))
			       (let* ((start (+ k 3))
				      (pos (search "}}}" str :start2 start))
				      (next (or (position-if '(lambda (c) (not (= c ?\}))) str :start pos) (length str))))
				 (setq k next)
				 (concat "\\hbox{\\tt " (fortress-render-string-contents (substring str start (- next 3))) "}")))
			      ((and (= c ?\{)
				    (= d ?\{)
				    (search "}}" str :start2 k))
			       (let* ((m (search "}}" str :start2 k))
				      (filename (substring str (+ k 2) m))
				      (z (cond ((every '(lambda (c) (find c "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ./-_"))
						       filename)
						(cond ((and multiline-p
							    (= k (position-if-not '(lambda (c) (= c ?\s)) str))
							    (= (+ m 1) (position-if-not '(lambda (c) (= c ?\s)) str :from-end t)))
						       (concat "\\FortressParagraphImage{" filename "}"))
						      (t (concat "\\FortressInlineImage{" filename "}"))))
					       (t (concat "\\hbox{\tt " (fortress-render-string-contents (substring str k (+ m 2))) "}")))))
				 (setq k (+ m 2))
				 z))
			      ((and (= c ?\\) (= d ?\\) multiline-p)
			       (setq k (+ k 2))
			       "\\hfil\\break ")
			      ((= c ?\`)
			       (let ((oldk k))
				 (while (and (< k n) (= (elt str k) ?\`))
				   (setq k (+ k 1)))
				 (let* ((bq (- k oldk))
					(pos (do ((p (search (substring str oldk k) str :start2 k)
						     (let ((q (position-if-not '(lambda (z) (= z ?\`)) str
									       :start (+ p bq))))
						       (and q (search (substring str oldk k) str :start2 q)))))
						 ((or (null p)
						      (= (+ p bq) n)
						      (not (= (elt str (+ p bq)) ?\`)))
						  p))))
				   (setq k (if pos (+ pos bq) n))
				   (fortress-recursive-fortress-render
				    ;; Carefully include backquote(s) in the arg
				    (substring str (+ oldk bq) k)))))
			      ((= c ?\\) (setq k (+ k 1)) "{\\tt\\char'134}")
			      ((= c ?\{) (setq k (+ k 1)) "\\{")
			      ((= c ?\}) (setq k (+ k 1)) "\\}")
			      ((= c ?\#) (setq k (+ k 1)) "\\#")
			      ((= c ?\$) (setq k (+ k 1)) "\\$")
			      ((= c ?\%) (setq k (+ k 1)) "\\%")
			      ((= c ?\&) (setq k (+ k 1)) "\\&")
			      ((= c ?\:)
			       (cond (description-p
				      (let ((oldk k))
					(while (and (< k n) (= (elt str k) ?\:))
					  (setq k (+ k 1)))
					(setq description-p nil)
					(setq result (fortress-trim-string-right result))
					(concat "}{" (number-to-string (- k oldk)) "}")))
				     (t (setq k (+ k 1)) ":")))
			      ((= c ?\') (setq k (+ k 1)) (if (= d ?\') "{'}" "'"))
			      ((= c ?^) (setq k (+ k 1)) "{\\char'136}")
			      ((= c ?\_) (setq k (+ k 1)) "\\_")
			      ((= c ?\~)
			       (setq k (+ k 1))
			       (cond ((= k n) (setq ends-with-tilde t) "")
				     ((or (unicode-is-letter (elt str k))
					  (unicode-is-digit (elt str k)))
				      "~")
				     ((= (elt str k) ?\s)
				      (setq k (+ k 1))
				      "~")
				     (t (setq k (+ k 1))
					;; Add braces to defeat later character-stripping operation for, e.g., headings
					(concat "{" (fortress-render-text (substring str (- k 1) k)) "}"))))
			      ((= c ?\|)
			       (cond (table-p
				      (when (> k 0) 
					(unless table-result (push "" table-result))
					(push (cond (blank (list result 'BLANK))
						    (sep (list result 'SEP))
						    (sepsep (list result 'SEPSEP))
						    (heading (list (concat (make-string (position-if-not '(lambda (c) (= c ?\s)) result) ?\s)
									   "{\\bf "
									   (fortress-trim-string (fortress-trim-string result) ?\=)
									   "}"
									   (make-string (- (length result)
											   (+ (position-if-not '(lambda (c) (= c ?\s)) result :from-end t) 1)) ?\s))
								   'HEADING))
						    (t (list result 'NORMAL)))
					      table-result))
				      (let ((oldk k))
					(while (and (< k n) (= (elt str k) ?\|))
					  (setq k (+ k 1)))
					(push (substring str oldk k) table-result))
				      (setq blank t)
				      (setq sep t)
				      (setq sepsep t)
				      (setq heading nil)
				      ;; Cause a reset of the "result" variable
				      nil)
				     (t (setq k (+ k 1)) "{$|$}")))
			      ((and (>= c #x20) (< c #x7f))
			       (setq k (+ k 1))
			       (substring str (- k 1) k))
			      (t (setq k (+ k 1))
				 (let ((z (or (gethash c *fortress-operator-codepoint-hashtable*)
					      (gethash c *fortress-honorary-letter-codepoint-hashtable*)
					      (gethash c *fortress-identifier-codepoint-hashtable*))))
				   (if z (concat "\\(" z "\\)")
				     (or (gethash c *fortress-control-character-hashtable*)
					 (fortress-render-unknown-character c))))))))
	  (setq result (and moretext (concat result moretext))))))
    (values (cond (table-p
		   (reverse (cond ((> (length result) 0)
				   (cons "" (cons (cond (blank (list result 'BLANK))
							(sep (list result 'SEP))
							(sepsep (list result 'SEPSEP))
							(heading (list (concat (make-string (position-if-not '(lambda (c) (= c ?\s)) result) ?\s)
									       "{\\bf "
									       (fortress-trim-string (fortress-trim-string result) ?\=)
									       "}"
									       (make-string (- (length result)
											       (+ (position-if-not '(lambda (c) (= c ?\s)) result :from-end t) 1)) ?\s))
								       'HEADING))
							(t (list result 'NORMAL)))
						  table-result)))
				  (t table-result))))
		  (description-p (concat (fortress-trim-string-right result) "}{1}"))
		  (t result))
	    fontstate
	    ends-with-tilde)))

(defun fortress-add-wiki-fontstate (newfont extradata fontstate)
  (cons newfont
	(append (ecase (fortress-combine-wiki-fonts (cons newfont (mapcar 'car fontstate)))
		  (BOLD '("{\\bf{" "}}"))
		  (ITALIC '("\\emph{" "}"))
		  (BOLD-ITALIC '("{\\bf\\emph{" "}}"))
		  (MONOSPACE '("{\\tt{" "}}"))
		  (QUOTE '("{``}" "{''}"))
		  (QUOTE-MONOSPACE '("{\\char'42}" "{\\char'42}"))
		  )
		extradata)))
(ecase 'foo ((foo) 3))

(defun fortress-combine-wiki-fonts (fontlist)
  (let* ((rev (reverse fontlist)))
    (do ((f (cdr rev) (cdr f))
	 (s (car rev)
	    (ecase (car f)
	      (BOLD (ecase s
		      (BOLD s)
		      (ITALIC 'BOLD-ITALIC)
		      (BOLD-ITALIC s)
		      (MONOSPACE (car f))
		      (QUOTE (car f))
		      (QUOTE-BOLD (car f))
		      (QUOTE-ITALIC 'BOLD-ITALIC)
		      (QUOTE-BOLD-ITALIC 'BOLD-ITALIC)
		      (QUOTE-MONOSPACE (car f))))
	      (ITALIC (ecase s
			(BOLD 'BOLD-ITALIC)
			(ITALIC s)
			(BOLD-ITALIC s)
			(MONOSPACE (car f))
			(QUOTE (car f))
			(QUOTE-BOLD 'BOLD-ITALIC)
			(QUOTE-ITALIC (car f))
			(QUOTE-BOLD-ITALIC 'BOLD-ITALIC)
			(QUOTE-MONOSPACE (car f))))
	      (MONOSPACE (car f))
	      (QUOTE (ecase s
		       (BOLD 'QUOTE-BOLD)
		       (ITALIC 'QUOTE-ITALIC)
		       (BOLD-ITALIC 'QUOTE-BOLD-ITALIC)
		       (MONOSPACE 'QUOTE-MONOSPACE)
		       (QUOTE s)
		       (QUOTE-BOLD s)
		       (QUOTE-ITALIC s)
		       (QUOTE-BOLD-ITALIC s)
		       (QUOTE-MONOSPACE s))))))
	((null f) s))))

(defun fortress-recursive-fortress-render (str)
  ;; The str must end in a backquote, and the str must occur somewhere in
  ;; the region delimited by *fortify-region-start* and *fortify-region-end*.
  ;; If we fail, we simply hand back the string with the trailing backquotes removed.
  (goto-char *fortify-region-start*)
  (let ((epos (+ 1 (or (position-if '(lambda (c) (not (= c ?\`))) str :from-end t) -1))))
    (cond ((let ((case-fold-search nil)) (search-forward str *fortify-region-end* t))
	   (newfortify-region (- (point) (length str)) (- (point) (- (length str) epos))))
	  (t (substring str 0 epos)))))

;;; ****************************************************************
;;; ***** (4) Do a lightweight, error-correcting parse that matches
;;; *****     left enclosers with right enclosers and also matches keywords.
;;; ****************************************************************

;;; We do an inside-out match.  Here are the pairs that we try to match:
;;;   ( )  [ ]  { }  <| |>  [\ \] and so on
;;;   do end
;;;   do also
;;;   if end
;;;   label end
;;;   case end
;;;   typecase end
;;;   try end
;;; We assume that extra opens are far more likely than extra closes.
;;; We assume we have resynchronized if we can match two consecutive pairs
;;; or if we can match two keywords.  If we can't, we assume the less recent
;;; closer is unmatched and discard it.
;;; We could try to be a lot more clever than this, but this is probably enough.
;;; It works on correct code, and should be fairly reasonable on incorrect code.

;;; The result of the "parse" is a hash table that matches left tokens to
;;; tokens and vice versa.

(defun fortify-light-parse (tokens)
  (let ((result (make-hash-table :test 'eq))
	(stack '())
	(unmatchedthis nil)
	(unmatchedprev nil))
    (dolist (x tokens)
      (ecase (car x)
	((KEYWORD)
	 (cond ((or (string= (cadr x) "do")
		    (string= (cadr x) "if")
		    (string= (cadr x) "label")
		    (string= (cadr x) "case")
		    (string= (cadr x) "typecase")
		    (string= (cadr x) "try"))
		(setq unmatchedprev nil)
		(setq unmatchedthis nil)
		(push x stack))
	       ((or (string= (cadr x) "end")
		    (string= (cadr x) "also"))
		(setq unmatchedprev unmatchedthis)
		(setq unmatchedthis x))))
	((LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS LEFT-WHITE-BRACKET)
	 (setq unmatchedprev nil)
	 (setq unmatchedthis nil)
	 (push x stack))
	((RIGHT-BRACKET RIGHT-ENCLOSER RIGHT-PARENTHESIS RIGHT-WHITE-BRACKET)
	 (setq unmatchedprev unmatchedthis)
	 (setq unmatchedthis x))
	((AMPERSAND BIGOP CHARACTER-LITERAL CIRCUMFLEX COLON COMMA COMMENT
		    COMMENT-END COMMENT-LINE COMMENT-MIDDLE COMMENT-START
		    DIGIT-GROUP-SEPARATOR DOT IDENTIFIER NEWLINE NUMBER OPERATOR
		    OPERATOR-WORD SEMICOLON STRING STRING-END STRING-MIDDLE
		    STRING-START UNKNOWN WHITESPACE)))
      ;; At this point, try to resolve any outstanding closes.
      (when unmatchedthis
	(cond (unmatchedprev
	       ;; We're out of synch.  Search for a match.
	       (do ((s stack (cdr s)))
		   ((null (cdr s))
		    ;; Found no match; leave unmatched items outstanding
		    )
		 (when (and (fortify-parse-match (car s) unmatchedprev)
			    (fortify-parse-match (cadr s) unmatchedthis))
		   ;; We found a match.  Resynchronize.
		   (puthash (car s) unmatchedprev result)
		   (puthash unmatchedprev (car s) result)
		   (puthash (cadr s) unmatchedthis result)
		   (puthash unmatchedthis (cadr s) result)
		   (setq stack (cddr s))
		   (setq unmatchedprev nil)
		   (setq unmatchedthis nil)
		   (return))))
	      ((fortify-parse-match (car stack) unmatchedthis)
	       ;; Hurray!  A normal match.
	       (puthash (car stack) unmatchedthis result)
	       (puthash unmatchedthis (car stack) result)
	       (pop stack)
	       (setq unmatchedthis nil))
	      ((and (eq (car x) 'KEYWORD)
		    (not (eq (car (car stack)) 'KEYWORD)))
	       ;; We are out of synch, and we have a keyword trying to
	       ;; match a non-keyword.  If we can match the keyword higher
	       ;; up on the stack, we will go with it.
	       (do ((s stack (cdr s)))
		   ((null (cdr s))
		    ;; Found no match; leave unmatched item outstanding
		    )
		 (when (fortify-parse-match (car s) unmatchedthis)
		   ;; We found a match.  Resynchronize.
		   (puthash (car s) unmatchedthis result)
		   (puthash unmatchedthis (car s) result)
		   (setq stack (cdr s))
		   (setq unmatchedprev nil)
		   (setq unmatchedthis nil)
		   (return)))))))
    result))

(defun fortify-parse-match (left right)
  (let ((leftkind (car left))
	(rightkind (car right)))
    (or (and (eq leftkind 'LEFT-PARENTHESIS) (eq rightkind 'RIGHT-PARENTHESIS))
	(and (eq leftkind 'LEFT-BRACKET) (eq rightkind 'RIGHT-BRACKET))
	(and (eq leftkind 'LEFT-WHITE-BRACKET) (eq rightkind 'RIGHT-WHITE-BRACKET))
	(and (eq leftkind 'LEFT-ENCLOSER)
	     (eq rightkind 'RIGHT-ENCLOSER)
	     (fortify-encloser-match (cadr left) (cadr right)))
	(and (eq leftkind 'KEYWORD)
	     (eq rightkind 'KEYWORD)
	     (fortify-keyword-encloser-match (cadr left) (cadr right))))))

(defun fortify-encloser-match (leftname rightname)
  (or (string= (gethash leftname *fortress-encloser-match-hashtable*)  rightname)
      (string= leftname
	       (apply 'string
		      (sublis (if (= (elt leftname 0) ?\<)
				  '((?\] . ?\[) (?\) . ?\() (?\> . ?\<) (?\} . ?\{) (?\/ . ?\\) (?\\ . ?\/))
				'((?\] . ?\[) (?\) . ?\() (?\> . ?\<) (?\} . ?\{)))
			      (reverse (string-to-list rightname)))))))
	     
(defun fortify-keyword-encloser-match (leftname rightname)
  (or (string= rightname "end")
      (and (string= rightname "also")
	   (string= leftname "do"))))


(defun show-hashtable (x)
   (maphash '(lambda (k v) (princ (format "%s -> %s\n" k v))) x)
   x)

;;; ****************************************************************
;;; ***** (5) Handle certain idioms that may span multiple lines.
;;; ****************************************************************

;;; For now, just handle multiline comments as if they were single-line comments.

(defun fortress-multiline-idioms (tokens *fortress-matching-hashtable*)
  (fortress-align-line-comments
   (fortress-multiline-comment-idiom-new
    (fortress-matrix-idiom tokens))))

(defun fortress-multiline-comment-idiom (tokens)
  (dolist (x tokens)
    (let ((str (cadr x)))
      (case (car x)
	((COMMENT-START)
	 (rplacd (cdr x)
		 (list (let ((startpos (position-if-not '(lambda (c) (= c ?\*)) str :start 1))
			     (endpos (length str)))
			 (cond ((or (null startpos) (>= startpos endpos))
				;; Must be a comment containing nothing but asterisks!
				(concat "\\hbox{\\tt" str "}"))
			       (t (concat "\\hbox{\\tt"
					  (substring str 0 startpos)
					  "}\\hbox{"
					  (fortress-render-wiki-creole-line (substring str startpos endpos))
					  "}")))))))
	((COMMENT-MIDDLE)
	 (rplacd (cdr x) (list (concat "\\hbox{{\\tt~~}" (fortress-render-wiki-creole-line (fortress-trim-string str)) "}"))))
	((COMMENT-END)
	 (rplacd (cdr x)
		 (list (let ((startpos 0)
			     (endpos (let ((epos (position-if-not '(lambda (c) (= c ?\*)) str :end  (- (length str) 1) :from-end t)))
				       (and epos (+ 1 epos)))))
			 (cond ((or (null endpos) (>= startpos endpos))
				;; Must be a comment containing nothing but asterisks!
				(concat "\\hbox{\\tt~" str "}"))
			       (t (concat "\\hbox{{\\tt~}"
					  (fortress-render-wiki-creole-line (fortress-trim-string-left (substring str startpos endpos)))
					  "}\\hbox{\\tt"
					  (substring str endpos)
					  "}"))))))))))
  tokens)


(defun fortress-trim-string (str &optional optchar)
  (let ((trimchar (or optchar ?\s)))
    (substring str
	       (or (position-if '(lambda (c) (not (= c trimchar))) str) 0)
	       (+ 1 (or (position-if '(lambda (c) (not (= c trimchar))) str :from-end t) -1)))))

(defun fortress-trim-string-left (str &optional optchar)
  (let ((trimchar (or optchar ?\s)))
    (substring str
	       (or (position-if '(lambda (c) (not (= c trimchar))) str) 0))))

(defun fortress-trim-string-right (str &optional optchar)
  (let ((trimchar (or optchar ?\s)))
    (substring str
	       0
	       (+ 1 (or (position-if '(lambda (c) (not (= c trimchar))) str :from-end t) -1)))))

(defun fortress-multiline-comment-idiom-new (tokens)
  (do ((toks tokens (cdr toks))
       (indent 0 (if (eq (car (car toks)) 'NEWLINE) 0 (+ indent (length (cadr (car toks)))))))
      ((null toks))
    (when (eq (car (car toks)) 'COMMENT-START)
      (do ((z (cdr toks) (cdr z))
	   (lines (list (substring (cadr (car toks)) 2))
		  (if (eq (car (car z)) 'COMMENT-MIDDLE) (cons (cadr (car z)) lines) lines)))
	  ((null z)
	   (fortress-process-one-multiline-comment toks indent (reverse lines) t))
	(when (eq (car (car z)) 'COMMENT-END)
	  (return (fortress-process-one-multiline-comment toks
						  indent
						  (reverse (cons (substring (cadr (car z))
									    0
									    (- (length (cadr (car z))) 2))
								 lines))
						  nil))))))
  tokens)

(defun fortress-leftmost-nonblank (str)
  (let ((nonblank (position-if '(lambda (c) (not (= c ?\s))) str)))
    (if nonblank (elt str nonblank) ?\s)))

(defun fortress-rightmost-nonblank (str)
  (let ((nonblank (position-if '(lambda (c) (not (= c ?\s))) str :from-end t)))
    (if nonblank (elt str nonblank) ?\s)))


;;; The steps of processing one multi-line comment:
;;; (1) Find out characteristics of top, bottom, left, and right sides.
;;; (2) Strip off leading and trailing asterisks as appropriate.
;;; (3) Process each line, looking for:
;;;     (a) Paragraph-indent commands *, #, ;, >, etc.
;;;     (b) Verbatim commands {{{
;;;     (c) Code-block commands `, etc.
;;;     (d) Table commands |
;;;     (e) Horizontal rule commands ----
;;;     and then also performing intraline wiki processing.
;;; (4) Put the rendered lines back into the token list and rerender newlines.
;;;
;;; Remember, the first line has already had the "(*" stripped off,
;;; and the last line (if any) has already had the "*)" stripped off.

(defun fortress-process-one-multiline-comment (tokens initial-indent lines partial)
  (let ((first-line (car lines))
	(middle-lines (if partial (cdr lines) (reverse (cdr (reverse (cdr lines))))))
	(last-line (and (not partial) (car (last lines)))))
    (let* ((first-trimmed (fortress-trim-string-right first-line))
	   (last-trimmed (and last-line (fortress-trim-string-left last-line)))
	   (top-nonstar (position-if '(lambda (c) (not (= c ?\*))) first-trimmed))
	   (top-mid-space (position ?\s first-trimmed))
	   (top-backslash (and top-nonstar
			       (= top-nonstar (- (length first-trimmed) 1))
			       (= (elt first-line top-nonstar) ?\\)))
	   (bottom-nonstar (and last-trimmed
				(position-if '(lambda (c) (not (= c ?\*))) last-trimmed
					     :from-end t)))
	   (bottom-mid-space (and last-trimmed
				  (position ?\s last-trimmed :from-end t)))
	   (bottom-backslash  (and bottom-nonstar
				   (= bottom-nonstar 0)
				   (= (elt last-trimmed bottom-nonstar) ?\\))))
      (let* ((top-text (and top-mid-space
			    (substring first-trimmed (+ top-mid-space 1))))
	     (top-rule (and (> (length first-trimmed) 2)
			    (or (not top-nonstar) top-backslash)))
	     (top-tag (and (not top-rule)
			   (or (not top-mid-space)
			       (> top-mid-space 0))
			   (if top-mid-space (substring first-trimmed 0 top-mid-space) first-trimmed)))			     
	     (bottom-text (and bottom-mid-space
			       (substring last-trimmed 0 bottom-mid-space)))
	     (bottom-rule (and (> (length last-trimmed) 2)
			       (or (not bottom-nonstar) bottom-backslash)))
	     (bottom-tag (and (not bottom-rule)
			      (or (not bottom-mid-space)
				  (< bottom-mid-space (- (length last-trimmed) 1)))
			      (if bottom-mid-space (substring last-trimmed (+ bottom-mid-space 1)) last-trimmed)))
	     (bottom-left (and last-line (not (> (or (position-if '(lambda (c) (not (= c ?\s))) last-line) 0)
						 initial-indent))))
	     (left-flush (or (and bottom-backslash
				  (< (position ?\\ last-line)
				     (+ initial-indent 1)))
			     (some '(lambda (ln) (find-if '(lambda (c) (not (= c ?\s))) ln
							  :end (min (length ln) (+ initial-indent 2))))
				   middle-lines)))
	     (left-asterisks (and middle-lines (every '(lambda (ln) (= (fortress-leftmost-nonblank ln) ?\*)) middle-lines)))
	     (left-rule (or left-asterisks bottom-backslash))
	     (right-flush (or (and last-line
				   top-backslash
				   (> (+ initial-indent (position ?\\ first-line :from-end t))
				      (+ (length last-line) 1)))
			      (some '(lambda (ln) (find-if '(lambda (c) (not (= c ?\s))) ln
							   :start (min (length ln) (+ (length last-line) 1))))
				    middle-lines)))
	     (right-asterisks (and middle-lines (every '(lambda (ln) (= (fortress-rightmost-nonblank ln) ?\*)) middle-lines)))
	     (right-rule (or right-asterisks top-backslash)))
	(let ((starting-boilerplate
	       (concat (cond (top-tag (concat (cond (left-flush
						     (cond (right-flush "\\FortressTaggedBeginFlushComment")
							   (t "\\FortressTaggedBeginFlushLeftComment")))
						    (t (cond (right-flush "\\FortressTaggedBeginFlushRightComment")
							     (t "\\FortressTaggedBeginComment"))))
					      "{" top-tag "}"))
			     (t (cond (left-flush
				       (cond (right-flush "\\FortressBeginFlushComment")
					     (t "\\FortressBeginFlushLeftComment")))
				      (t (cond (right-flush "\\FortressBeginFlushRightComment")
					       (t "\\FortressBeginComment"))))))
		       (if top-rule (if right-rule "\\toprightcommentline" "\\topcommentline") "")))
	      (ending-boilerplate
	       (concat (if bottom-rule (if left-rule "\\bottomleftcommentline" "\\bottomcommentline") "")
		       (if left-rule (if right-rule "\\leftrightrule" "\\leftrule") (if right-rule "\\rightrule" ""))
		       (cond (bottom-tag 
			      (cond (bottom-left (concat " \\FortressTaggedEndCommentLeft{" bottom-tag "}"))
				    (t (concat " \\FortressTaggedEndComment{" bottom-tag "}"))))
			     (bottom-left "\\FortressEndCommentLeft")
			     (t "\\FortressEndComment")))))
	  (let ((processed-lines (fortress-multiline-comment-wiki-render
				  (append (list (or top-text ""))
					  (fortress-strip-multiline-comment-asterisks middle-lines
										      left-asterisks
										      right-asterisks)
					  (and last-line (list (or bottom-text "")))))))
	    (let ((pl processed-lines))
	      (do ((toks tokens (cdr toks)))
		  ((null toks))
		(ecase (car (car toks))
		  ((COMMENT-START)
		   (rplaca (cddr (car toks)) (concat starting-boilerplate (if top-mid-space " " "") (pop pl))))
		  ((COMMENT-MIDDLE)
		   (rplaca (cddr (car toks)) (pop pl)))
		  ((COMMENT-END)
		   (rplaca (cddr (car toks)) (concat (pop pl) (if bottom-mid-space " " "") ending-boilerplate))
		   (return))
		  ((NEWLINE) (rplaca (cddr (car toks)) "\n")))))))))))

(defun fortress-leftmost-nonblank (str)
  (let ((pos (position-if '(lambda (c) (not (= c ?\s))) str)))
    (if pos (elt str pos) ?\s)))

(defun fortress-rightmost-nonblank (str)
  (let ((pos (position-if '(lambda (c) (not (= c ?\s))) str :from-end t)))
    (if pos (elt str pos) ?\s)))

(defun fortress-strip-multiline-comment-asterisks (lines left right)
  (mapcar '(lambda (line)
	     (when left (setq line (substring line (+ 1 (position ?\* line)))))
	     (when right (setq line (substring line 0 (position ?\* line :from-end t))))
	     line)
	  lines))

(defun fortress-multiline-comment-wiki-render (lines)
  (do ((lns lines (cdr lns))
       (result '())
       (wikistate '())
       (table '())
       (table-indent 0)
       (hrule-last nil)
       (indented-par-last nil)
       (continue-previous-line nil)
       (par-in-progress t) ;We begin a comment in TeX horizontal mode.
       (curindent 0)
       (par-kinds-and-counters (list 'DUMMY))) ;entry is a pair (kind counter)
      ((null lns)
       (when table
	 (setq result (append (reverse (fortress-multiline-table (reverse table) table-indent)) result))
	 (setq par-in-progress nil)
	 (setq table '()))
       ;;complete last par
       (reverse result))
    (let* ((raw-line (car lns))
	   (line (fortress-trim-string raw-line)))
      (cond ((= (length line) 0)
	     (when table
	       (setq result (append (reverse (fortress-multiline-table (reverse table) table-indent)) result))
	       (setq table '()))
	     (setq continue-previous-line nil)
	     (setq par-in-progress nil)
	     (setq hrule-last nil)
	     (setq curindent 0)
	     (push (if (or (eq lns lines) (null (cdr lns))) "" "\\\\") result))
	    (t (let ((pos (position-if '(lambda (c) (not (= c (elt line 0)))) line)))
		 (unless (and (not continue-previous-line)
			      (cond ((or (= (elt line 0) ?\|)
					 (and (= (elt line 0) ?\>)
					      (let ((pos1 (position-if-not '(lambda (c) (= c ?\>)) line)))
						(and pos1
						     (= (elt line pos1) ?\s)
						     (let ((pos2 (position-if-not '(lambda (c) (= c ?\s)) line :start pos1)))
						       (and pos2 (= (elt line pos2) ?\|)))))))
				     (unless table (setq table-indent (position-if-not '(lambda (c) (= c ?\>)) line)))
				     (multiple-value-bind (processed-line newstate ends-with-tilde)
					 (fortress-render-wiki-creole-line-and-state (substring line (position ?\| line)) '() t nil t)
				       (cond ((and table continue-previous-line)
					      (let ((lastline (pop table)))
						(push (append (reverse (rest (reverse lastline))) processed-line) table)))
					     (t (push processed-line table)))
				       (setq wikistate newstate)
				       (setq continue-previous-line ends-with-tilde)
				       (setq curindent 0))
				     t)
				    (t (when table
					 (setq result (append (reverse (fortress-multiline-table (reverse table) table-indent)) result))
					 (setq table '()))
				       (cond ((= (elt line 0) ?\=)
					      (let* ((stuff (substring line (or pos (length line))))
						     (rpos (position-if '(lambda (c) (not (= c ?\=))) stuff :from-end t))
						     (heading (if rpos (substring stuff 0 (+ rpos 1)) stuff)))
						(multiple-value-bind (processed-line newstate ends-with-tilde)
						    (fortress-render-wiki-creole-line-and-state heading '() nil nil nil)
						  (setq hrule-last nil)
						  (setq continue-previous-line nil)
						  (setq indented-par-last nil)
						  (setq par-in-progress nil)
						  (setq curindent 0)
						  (setq par-kinds-and-counters (list 'DUMMY))
						  (push (concat "\\lind{0}{\\bf " processed-line "}") result)))
					      t)
					     ((and (= (elt line 0) ?\-)
						   (not pos)
						   (> (length line) 3))
					      (push (if hrule-last "\\hrule \\\\" "\\\\ \\\\ \\hrule \\\\") result)
					      (setq hrule-last t)
					      t)
					     ((and (= (elt line 0) ?\{)
						   (not pos) 
						   (= (length line) 3))
					      (let ((begin-indent (position ?\{ raw-line)))
						(push "" result)
						(setq lns (cdr lns))
						(do ((prefix (concat "\\lind{" (number-to-string (or curindent 0)) "}")
							     "\\hfil\\break\\null"))
						    ((or (null lns)
							 (and (string= (fortress-trim-string (car lns)) "}}}")
							      (not (> (position ?\} (car lns)) begin-indent)))))
						  (push (concat prefix
								"{\\tt "
								(fortress-render-string-contents
								 (fortress-trim-string-right
								  (substring (car lns) 
									     (if (string= (fortress-trim-string (car lns)) "}}}")
										 (+ begin-indent 1)
									       (min begin-indent
										    (or (position-if-not '(lambda (c) (= c ?\s)) (car lns))
											(length (car lns))))))))
								"}")
							result) 
						  (setq lns (cdr lns)))
						(push (concat (pop result) " \\\\") result)
						(setq hrule-last nil)
						(setq continue-previous-line nil)
						(setq indented-par-last nil)
						(setq par-in-progress nil)
						(when lns (push "" result)))
					      t)
					;		       ((and (= (elt line 0) ?\`) (not pos))
					;                       (setq continue-previous-line nil)
					;			(let ((fcode "") (linecount 0))
					;			  (setq lns (cdr lns))
					;			  (while (and lns (not (string= (car lns) line)))
					;			    (setq fcode (concat fcode (car lns) "\n"))
					;			    (setq linecount (+ linecount 1))
					;			    (setq lns (cdr lns)))
					;			  ;; Okay, we have the complete code in hand; now fortify it
					;			  t))
					     ((and (find (elt line 0) ">*#;")
						   (or (null pos) (= (elt line pos) ?\s))
						   (or (not (find (elt line 0) "*#"))
						       indented-par-last
						       (and pos (= pos 1))))
					      (unless pos (setq pos (length line)))
					      (when (> (length (cdr par-kinds-and-counters)) pos)
						(rplacd (nthcdr pos par-kinds-and-counters) '()))
					      (while (< (length (cdr par-kinds-and-counters)) pos)
						(rplacd (last par-kinds-and-counters) (list (list (elt line 0) 0))))
					      (unless (= (elt line 0) ?\>)
						(let ((lastentry (car (last par-kinds-and-counters))))
						  (setf (second lastentry) (+ 1 (second lastentry)))))
					      (setq hrule-last nil)
					      (let* ((pnum (number-to-string pos))
						     (depth (do ((z (cdr par-kinds-and-counters) (cdr z))
								 (prevkind -1 (first (car z)))
								 (d 1 (if (= (first (car z)) prevkind) (+ d 1) 1)))
								((null z) (number-to-string d))))
						     (line-prefix
						      (case (elt line 0)
							((?\>)
							 (concat "\\lind{" pnum "}"))
							((?\*)
							 (concat "\\item{" pnum "}{" depth "}"))
							((?\#)
							 (concat "\\enum{" pnum "}{" depth "}{" (number-to-string (second (car (last par-kinds-and-counters)))) "}"))
							((?\;)
							 (setq pos (+ pos 1))
							 ;; Colon processing in fortress-render-wiki-creole-line-and-state
							 ;; will insert the matching "}" for this case.
							 (concat "\\desc{" pnum "}{")))))
						(multiple-value-bind (processed-line newstate ends-with-tilde)
						    (fortress-render-wiki-creole-line-and-state (substring line pos) '() t (= (elt line 0) ?\;) nil)
						  (setq wikistate newstate)
						  (setq continue-previous-line ends-with-tilde)
						  (setq indented-par-last t)
						  (setq par-in-progress t)
						  (setq curindent pos)
						  (push (concat line-prefix processed-line) result)))
					      t)
					     (t nil)))))
		   ;; The default case: just process the line as ordinary Wiki material.
		   (cond (continue-previous-line
			  (cond (table
				 (multiple-value-bind (processed-line newstate ends-with-tilde)
				     (fortress-render-wiki-creole-line-and-state line wikistate t nil t)
				   (setq wikistate newstate)
				   (setq continue-previous-line ends-with-tilde)
				   (push (fortress-glue-two-table-lines (pop table) processed-line) table)
				   (push (list "%") table)))
				(t (multiple-value-bind (processed-line newstate ends-with-tilde)
				       (fortress-render-wiki-creole-line-and-state line wikistate t nil nil)
				     (setq wikistate newstate)
				     (setq continue-previous-line ends-with-tilde)
				     (push (concat (pop result) "%") result)
				     (push processed-line result)))))
			 (t (when table
			      (setq result (append (reverse (fortress-multiline-table (reverse table) table-indent)) result))
			      (setq table '()))
			    (multiple-value-bind (processed-line newstate ends-with-tilde)
				(fortress-render-wiki-creole-line-and-state line wikistate t nil nil)
			      (setq wikistate newstate)
			      (setq hrule-last nil)
			      (setq continue-previous-line ends-with-tilde)
			      (unless par-in-progress
				(setq indented-par-last nil)
				(setq par-kinds-and-counters (list 'DUMMY)))
			      (push (if par-in-progress processed-line (concat "\\lind{0} " processed-line)) result)
			      (setq par-in-progress t)))))))))))

(defun fortress-glue-two-table-lines (line1 line2)
  (let ((revline1 (reverse line1)))
    (cond ((or (> (length (first revline1)) 0)
	       (> (length (first line2)) 0))
	   (append (reverse (rest revline1))
		   (cons (concat (first revline1) (first line2))
			 (rest line2))))
	  (t (append (rest (rest revline1))
		     (cons (let ((item1 (second revline1))
				 (item2 (second line2)))
			     (list (concat (first item1) (first item2))
				   (cond ((eq (second item1) 'HEADING) 'HEADING)
					 ((eq (second item1) (second item2)) (second item1))
					 (t 'NORMAL))))
			   (rest (rest line2))))))))

;;; The basic rules for tables are:
;;; (1) A table line that is not a continuation line must begin with "|".
;;; (2) Every row in a table must have the same number of "|" characters
;;;     as parts of separators.  If necessary, rows are padded on the right
;;;     with extra "|" characters to enforce this invariant.
;;; (3) Each maximal sequence of "|" characters serves as a cell separator.
;;;     (To get an empty cell, use one or more spaces.)  The general idea is
;;;     that n consecutive "|" characters is rendered as n-1 vertical lines
;;;     separating the cells.
;;; (4) The first cell separators on all the lines of a table must have the
;;;     same number of "|" characters.  If necessary, the first cell separator
;;;     of a line will be auotmatically split into two pieces, and a space
;;;     inserted at the split (which will result in an empty cell), so as
;;;     to enforce this requirement.
;;; (5) To cause a single entry to span two or more table columns, just
;;;     make the cells entries for the extra columns to be spanned empty.
;;;     (This causes two or more cell separator sequences to look like
;;;     a single separator sequence.  Undoing this requires a very
;;;     interesting algorithm that works from right to left.)
;;; (6) A cell is //blank// if it consists entirely of space characters.
;;;     A cell is //right-justified// if it has no spaces on the right and at least
;;;     one space to the left, or one space to the right and at least two spaces
;;;     to the left.  A cell is //left-justified// if it has no spaces on the left
;;;     and at least one space to the right, or one space to the left and at least
;;;     two spaces to the right.  A cell is //centered// if it has at least two
;;;     spaces on each side.  Otherwise (no space on each side, or exactly one
;;;     space on each side), it is //neutral//.  Neutral cells are converted to
;;;     left-justified, right-justified, or centered by examining all other
;;;     cells that begin in the same column and span the same number of columns;
;;;     neutral cells are converted to the same type as the latest (lowest)
;;;     non-neutral, non-blank cell in that set that precedes all neutral cells,
;;;     but if the first non-blank cell of the set is neutral, then all neutral cells
;;;     in the set are made centered.  (The idea behind neutral cells is that you can specify
;;;     the justification for each column injust  the column headings or the first row
;;;     of data cells, and then just use no space, or one space, next to each pipe
;;;     in all other rows of the table.)
;;; (7) If every cell in a row is either all blank or all "-" characters,
;;;     then it is not really a table row, but a set of horizontal lines
;;;     spanning the indicated columns.
;;; (8) If every cell in a row is all "=" characters, it represents a double
;;;     line spanning the entire width of the table.

(defun fortress-multiline-table (table-lines table-indent)
  (let* ((pipe-counts (mapcar '(lambda (line) (do ((z line (cddr z))
						   (n 0 (+ n (length (car z)))))
						  ((null (cdr z)) (+ n (length (car z))))))
			      table-lines))
	 (max-pipe-count (reduce 'max pipe-counts))
	 (row-types (mapcar '(lambda (line)
			       (cond ((string= (first line) "%") 'CONTINUATION)
				     ((every '(lambda (item) (or (stringp item) (eq (second item) 'SEPSEP))) line)
				      'HLINEHLINE)
				     ((every '(lambda (item) (or (stringp item) (eq (second item) 'SEP))) line)
				      'HLINE)
				     ((every '(lambda (item) (or (stringp item) (eq (second item) 'BLANK))) line)
				      'NORMAL)
				     ((every '(lambda (item) (or (stringp item) (eq (second item) 'SEP) (eq (second item) 'BLANK))) line)
				      'CLINE)
				     (t 'NORMAL)))
			    table-lines))
	 (min-initial-pipe-count (reduce 'min (mapcar '(lambda (line) (length (first line))) table-lines)))
	 (reversed-padded-lines
	  (mapcar* '(lambda (line pc)
		      (let* ((front-normalized-line
			      (if (= (length (first line)) min-initial-pipe-count)
				  line
				(list* (substring (first line) 0 min-initial-pipe-count)
				       '(" " BLANK)
				       (substring (first line) min-initial-pipe-count)
				       (rest line))))
			     (rev (reverse front-normalized-line)))
			(cons (concat (first rev) (make-string (- max-pipe-count pc) ?\|)) (rest rev))))
		   table-lines
		   pipe-counts)))
    (do ((rpl (mapcar 'cdr reversed-padded-lines)
	      (let ((minpipes (reduce 'min pipes)))
		(mapcar* '(lambda (p xrev)
			    (if (> p minpipes) xrev (cddr xrev))) pipes rpl)))
	 (col-from-right 0 (- col-from-right 1))
	 (pipes (mapcar '(lambda (xrev) (length (car xrev))) reversed-padded-lines)
		(let ((minpipes (reduce 'min pipes)))
		  (mapcar* '(lambda (p xrev) (if (> p minpipes) (- p minpipes) (+ (- p minpipes) (length (cadr xrev)))))
			   pipes rpl)))
	 (spans (make-list (length table-lines) 1)
		(let ((minpipes (reduce 'min pipes)))
		  (mapcar* '(lambda (span p) (if (> p minpipes) (+ span 1) 1))
			   spans pipes)))
	 (most-header-seps '() (cons (make-string (max 0 (- (reduce 'min pipes) 1)) ?\|) most-header-seps))
	 (rows (make-list (length table-lines) '())
	       (let ((minpipes (reduce 'min pipes)))
		 (mapcar* '(lambda (p xrev rtype span cells)
			     (if (> p minpipes) cells (cons (fortress-analyze-table-cell rtype col-from-right span (first (car xrev))) cells)))
			  pipes rpl row-types spans rows))))
	((every 'null rpl)
	 (assert (every '(lambda (x) (= x (car pipes))) pipes))
	 (let* ((ncols (- col-from-right))
		(header-seps (cons (if (> min-initial-pipe-count 1) (make-string (- min-initial-pipe-count 1) ?\|) "@{}") most-header-seps))
		(semi-final-rows (fortress-convert-neutral-table-cells row-types rows))
		(best-column-types (fortress-best-column-types row-types semi-final-rows ncols))
		(almost-final
		 (mapcar* '(lambda (rtype row)
			     (ecase rtype
			       ((CONTINUATION) "%")
			       ((HLINEHLINE) "\\hline\\hline")
			       ((HLINE) "\\hline")
			       ((CLINE)
				(mapconcat '(lambda (cell)
					      (cond (cell (let ((col (+ (first cell) ncols)))
							    (concat "\\cline{" (number-to-string col) "-"
								    (number-to-string (+ col (- (second cell) 1))) "}")))
						    (t "")))
					   row
					   ""))
			       ((NORMAL)
				(concat (mapconcat '(lambda (cell-data)
						      (fortress-render-normal-table-cell cell-data header-seps best-column-types ncols))
						   row
						   " & ")
					" \\\\"))))
			  row-types
			  semi-final-rows)))
	   (cons (concat "\\FortressTable{"
			 (number-to-string table-indent)
			 "}{"
			 (do ((ctypes best-column-types (rest ctypes))
			      (hseps (rest header-seps) (rest hseps))
			      (header (first header-seps)
				      (concat header
					      (ecase (first ctypes)
						((LEFT-JUSTIFIED) "l")
						((RIGHT-JUSTIFIED) "r")
						((CENTERED) "c"))
					      (first hseps))))
			     ((null ctypes) header))
			 "}\n"
			 (car almost-final))
		 (let ((rev-cdr-almost-final (reverse (cdr almost-final))))
		   (reverse (cons (concat (car rev-cdr-almost-final) "\n\\FortressEndTable")
				  (cdr rev-cdr-almost-final))))))))))

(defun fortress-analyze-table-cell (rtype col-from-right span str)
  (ecase rtype
    ((HLINEHLINE HLINE CONTINUATION) nil)
    ((CLINE) (and (= (elt str 0) ?\-) (list col-from-right span)))
    ((NORMAL)
     (let ((lpad (position-if-not '(lambda (c) (= c ?\s)) str)))
       (append (cond ((null lpad) `(BLANK ""))
		     (t (let* ((rpad (- (length str) (+ 1 (position-if-not '(lambda (c) (= c ?\s)) str :from-end t))))
			       (trimmed (substring str lpad (- (length str) rpad))))
			  (list (cond ((and (< lpad 2) (> rpad lpad)) 'LEFT-JUSTIFIED)
				      ((and (< rpad 2) (> lpad rpad)) 'RIGHT-JUSTIFIED)
				      ((and (< lpad 2) (= rpad lpad)) 'NEUTRAL)
				      (t 'CENTERED))
				trimmed))))
	       (list col-from-right span))))))

(defun fortress-convert-neutral-table-cells (row-types rows)
  (let ((ht (make-hash-table :test 'equal)))
    (mapcar '(lambda (rtype-and-row)
	       (let ((rtype (first rtype-and-row))
		     (row (second rtype-and-row)))
		 (ecase rtype
		   ((NORMAL)
		    (mapc '(lambda (cell-data)
			     (ecase (first cell-data)
			       ((BLANK))
			       ((NEUTRAL)
				(let ((z (gethash (list (third cell-data) (fourth cell-data)) ht)))
				  (when (or (null z) (null (first z)))
				    (puthash (list (third cell-data) (fourth cell-data)) (list t (if z (second z) 'CENTERED)) ht))))
			       ((LEFT-JUSTIFIED RIGHT-JUSTIFIED CENTERED)
				(let ((z (gethash (list (third cell-data) (fourth cell-data)) ht)))
				  (unless (and z (first z))
				    (puthash (list (third cell-data) (fourth cell-data)) (list nil (first cell-data)) ht))))))
			  row))
		   ((HLINEHLINE HLINE CLINE CONTINUATION)))))
	    (mapcar* 'list row-types rows))
    (mapcar '(lambda (rtype-and-row)
	       (let ((rtype (first rtype-and-row))
		     (row (second rtype-and-row)))
		 (ecase rtype
		   ((NORMAL)
		    (mapcar '(lambda (cell-data)
			       (if (eq (first cell-data) 'NEUTRAL)
				   (cons (second (gethash (list (third cell-data) (fourth cell-data)) ht))
					 (cdr cell-data))
				 cell-data))
			    row))
		   ((HLINEHLINE HLINE CLINE CONTINUATION) row))))
	    (mapcar* 'list row-types rows))))

(defun fortress-best-column-types (row-types rows ncols)
  (let ((left (make-vector ncols 0))
	(right (make-vector ncols 0))
	(center (make-vector ncols 0)))
    (mapc '(lambda (rtype-and-row)
	     (let ((rtype (first rtype-and-row))
		   (row (second rtype-and-row)))
	       (ecase rtype
		 ((NORMAL)
		  (mapc '(lambda (cell-data)
			   (let ((col-minus-one (- (+ (third cell-data) ncols) 1)))
			     (ecase (first cell-data)
			       ((BLANK))
			       ((LEFT-JUSTIFIED) (incf (elt left col-minus-one)))
			       ((RIGHT-JUSTIFIED) (incf (elt right col-minus-one)))
			       ((CENTERED) (incf (elt center col-minus-one))))))
			row))
		 ((HLINEHLINE HLINE CLINE CONTINUATION)))))
	  (mapcar* 'list row-types rows))
    (let ((result '()))
      (dotimes (j ncols)
	(let ((m (max (elt left j) (elt right j) (elt center j))))
	  (push (cond ((= (elt center j) m) 'CENTERED)
		      ((= (elt left j) m) 'LEFT-JUSTIFIED)
		      (t 'RIGHT-JUSTIFIED))
		result)))
      (reverse result))))

(defun fortress-render-normal-table-cell (cell-data header-seps best-column-types ncols)
  (let ((kind (first cell-data))
	(str (second cell-data))
	(col (+ (third cell-data) ncols))
	(span (fourth cell-data)))
    (cond ((and (= span 1)
		(or (eq kind 'BLANK)
		    (eq kind (elt best-column-types (- col 1)))))
	   str)
	  (t (concat "\\multicolumn{"
		     (number-to-string span)
		     "}{"
		     (if (= col 1) (elt header-seps 0) "")
		     (ecase kind
		       ((LEFT-JUSTIFIED) "l")
		       ((RIGHT-JUSTIFIED) "r")
		       ((CENTERED BLANK) "c"))
		     (elt header-seps (+ col (- span 1)))
		     "}{"
		     (fortress-trim-string str)
		     "}")))))

;;; We consider a group of lines to have alignable line comments if:
;;;  (a) The group has no empty lines.
;;;  (b) The group has no multiline comments.
;;;  (c) All the line comments have the same horizontal position.

(defun fortress-align-line-comments (tokens)
  (do ((toks tokens (cdr toks))
       (group-start nil)
       (group-line-comment-indent nil)
       (most-recent-matching-comment nil)
       (curline tokens)
       (indent 0))
      ((null toks)
       (fortress-install-line-comment-alignment group-start most-recent-matching-comment))
    (case (car (car toks))
      ((NEWLINE)
       (setq curline (cdr toks))
       (when (and (cdr toks) (eq (car (cadr toks)) 'NEWLINE))
	 (fortress-install-line-comment-alignment group-start most-recent-matching-comment)
	 (setq group-start nil)))
      ((COMMENT-START)
       (fortress-install-line-comment-alignment group-start most-recent-matching-comment)
       (setq group-start nil))
      ((COMMENT-LINE)
       (cond ((null group-start)
	      (setq group-start curline)
	      (setq group-line-comment-indent indent)
	      (setq most-recent-matching-comment nil))
	     ((= indent group-line-comment-indent)
	      (setq most-recent-matching-comment toks))
	     (t (fortress-install-line-comment-alignment group-start most-recent-matching-comment)
		(setq group-start curline)
		(setq group-line-comment-indent indent)
		(setq most-recent-matching-comment nil)))))
    (setq indent (if (eq (car (car toks)) 'NEWLINE) 0 (+ indent (length (cadr (car toks)))))))
  tokens)
		  
(defun fortress-install-line-comment-alignment (group-start most-recent-matching-comment)
  (when (and group-start most-recent-matching-comment)
    (let ((start (car group-start)))
      (rplaca group-start
	      (list 'COMMENT-ALIGN-START "" "\\fortressbegincommentalignblock\n"))
      (rplacd group-start
	      (cons start (cdr group-start)))
      (rplacd most-recent-matching-comment
	      (cons (list 'COMMENT-ALIGN-END "" " \\\\\n\\fortressendcommentalignblock")
		    (cdr most-recent-matching-comment)))
      (when (and (cddr most-recent-matching-comment)
		 (eq (car (caddr most-recent-matching-comment)) 'NEWLINE))
	(rplaca (cddr (caddr most-recent-matching-comment)) "\n")))))

;;; We can produce nice matrix notation for an expression in brackets
;;; that satisfies these restrictions:
;;;
;;; The left bracket must be preceded by whitespace.
;;; The contents include no comment.
;;; The contents include no unenclosed generator arrow or comma.
;;; There are not two consecutive unenclosed semicolons.
;;;
;;; Matrix elements are separated by unenclosed whitespace.  Rows are
;;; separated by semicolons and newlines, but a semicolon right before
;;; a newline becomes nothing, as does an ampersand before a newline.

(defun fortress-matrix-idiom (tokens)
  (do ((toks tokens (cdr toks)))
      ((null toks))
    (let ((maxcols (fortress-acceptable-matrix-idiom toks)))
      (when maxcols (fortress-process-matrix-idiom toks maxcols))))
  tokens)

;;; Returns nil is not acceptable, and otherwise the number of columns.
;;; For now, a matrix is not acceptable if more than 16 columns.

(defun fortress-acceptable-matrix-idiom (toks)
  (and (eq (car (car toks)) 'WHITESPACE)
       (eq (car (cadr toks)) 'LEFT-BRACKET)
       (let ((end (gethash (cadr toks) *fortress-matching-hashtable*)))
	 (and end
	      (do ((z (cddr toks) (cdr z))
		   (skipto nil)
		   (rowstart t)
		   (cols 0)
		   (maxcols 0))
		  ((or (null z) (eq (car z) end))
		   (and (not (null z)) (> maxcols 0) (< maxcols 17) maxcols))
		(cond ((memq (car (car z)) '(COMMENT COMMENT-LINE COMMENT-START)) (return nil))
		      (skipto (when (eq (car z) skipto) (setq skipto nil)))
		      (t (case (car (car z))
			   ((WHITESPACE)
			    (unless (or rowstart (memq (car (cadr z)) '(NEWLINE SEMICOLON RIGHT-BRACKET)))
			      (setq cols (+ cols 1))))
			   ((NEWLINE)
			    (setq maxcols (max maxcols (+ cols 1)))
			    (setq cols 0))
			   ((SEMICOLON)
			    (when (and (cdr z) (eq (car (caddr z)) 'SEMICOLON))
			      (return nil))
			    (setq maxcols (max maxcols (+ cols 1)))
			    (setq cols 0))
			   ((COMMA) (return nil))
			   ((OPERATOR)
			    (when (or (string= (cadr (car z)) "<-")
				      (string= (cadr (car z)) "\u2190"))
			      (return nil)))
			   ((LEFT-PARENTHESIS LEFT-BRACKET LEFT-ENCLOSER LEFT-WHITE-BRACKET)
			    (setq skipto (gethash (car z) *fortress-matching-hashtable*))))
			 (setq rowstart (not (null (memq (car (car z)) '(SEMICOLON NEWLINE))))))))))))

(defun fortress-process-matrix-idiom (toks maxcols)
  (let ((end (gethash (cadr toks) *fortress-matching-hashtable*)))
    (rplaca (cddr (cadr toks))
	    (concat "\\left[\\begin{array}{" (make-string maxcols ?c) "}"))
    (rplaca (cddr end) "\\end{array}\\right]")
    (do ((z (cddr toks) (cdr z))
	 (skipto nil)
	 (rowstart t))
	((or (null z) (eq (car z) end)) (not (null z)))
      (cond (skipto (when (eq (car z) skipto) (setq skipto nil)))
	    (t (case (car (car z))
		 ((WHITESPACE)
		  (unless (or rowstart (memq (car (cadr z)) '(NEWLINE SEMICOLON RIGHT-BRACKET)))
		    (rplaca (cddr (car z)) "&")))
		 ((NEWLINE)
		  ;; This already has the right rendering, with "\\" in it.
		  ;; But change to token type to SEMICOLON so that the PUSHTABS
		  ;; mechanism will not muck with it.
		  (rplaca (car z) 'SEMICOLON))
		 ((SEMICOLON)
		  (rplaca (cddr (car z))
			  (if (or (eq (car (cadr z)) 'NEWLINE)
				  (and (eq (car (cadr z)) 'WHITESPACE)
				       (eq (car (caddr z)) 'NEWLINE)))
			      "" "\\\\")))
		 ((LEFT-PARENTHESIS LEFT-BRACKET LEFT-ENCLOSER LEFT-WHITE-BRACKET)
		  (setq skipto (gethash (car z) *fortress-matching-hashtable*))))))
      (setq rowstart (not (null (memq (car (car z)) '(SEMICOLON NEWLINE))))))))

;;; ****************************************************************
;;; ***** (6)  Handle certain idioms (such as subscripts) that must fall within a line.
;;; ****************************************************************

(defun fortress-intraline-idioms (tokens *fortress-matching-hashtable*)
  (fortress-process-surds ;Must process surds after processing fractions
   (fortress-process-fractions
    (fortress-process-choose-etc
     (fortress-process-unit-declarations
      (fortress-process-subscripts
       (fortress-process-superscripts
	(fortress-process-opr-and-BIG
	 (fortress-process-colons
	  (fortress-process-compound-assignment tokens))))))))))

;;; Turn a compound assignment (an operator followed by an equals sign)
;;; into a single operator that is a RELATION.

(defun fortress-process-compound-assignment (tokens)
  (do ((toks tokens (cdr toks)))
      ((null toks))
    (when (and (memq (car (car toks)) '(OPERATOR OPERATOR-WORD))
	       (cdr toks)
	       (eq (car (cadr toks)) 'OPERATOR)
	       (string= (cadr (cadr toks)) "="))
      (rplaca toks (list 'RELATION
			 (concat (cadr (car toks)) "=")
			 (concat "\\mathrel{\\mathrel{" (caddr (car toks)) "}=}")))
      (rplacd toks (cddr toks))))
  tokens)

;;; In addition, a colon that follows an operator with no intervening
;;; whitespace is turned into a single operator.
;;; Otherwise, a colon that is not preceded by whitespace or newline is a candidate
;;; for being treated as punctuation rather than an operator.  It is considered
;;; punctuation if it is followed by any of these:
;;;    whitespace
;;;    () or ( )
;;;    any number (possibly zero) of left parentheses and then a type name

(defun fortress-process-colons (tokens)
  (do ((toks tokens (cdr toks)))
      ((null toks))
    (cond ((and (memq (car (first toks)) '(OPERATOR OPERATOR-WORD))
		(cdr toks)
		(eq (car (second toks)) 'COLON))
	   (rplaca (cdr (first toks)) (concat (cadr (first toks)) (cadr (second toks))))
	   (rplaca (cddr (first toks)) (concat "\\SHORTCUT{" (caddr (first toks)) "}"))
	   (rplacd toks (cddr toks)))
	  ((and (not (memq (car (first toks)) '(WHITESPACE NEWLINE)))
		(cdr toks)
		(eq (car (second toks)) 'COLON)
		(or (null (cddr toks))
		    (eq (car (third toks)) 'WHITESPACE)
		    (and (eq (car (third toks)) 'LEFT-PARENTHESIS)
			 (cdddr toks)
			 (or (eq (car (fourth toks)) 'RIGHT-PARENTHESIS)
			     (and (eq (car (fourth toks)) 'RIGHT-PARENTHESIS)
				  (cddddr toks)
				  (eq (car (fifth toks)) 'RIGHT-PARENTHESIS))))
		    (let ((z (find-if '(lambda (a) (not (eq (car a) 'LEFT-PARENTHESIS))) (cddr toks))))
		      (and z
			   (eq (car z) 'IDENTIFIER)
			   (or (and (> (length (caddr z)) 4)
				    (string= (substring (caddr z) 0 5) "\\TYP{"))
			       (and (> (length (caddr z)) 7)
				    (string= (substring (caddr z) 0 8) "\\mathbb{")))))))
	   (rplaca (cddr (second toks)) "\\COLON"))))
  tokens)

;;; Two transformations here:
;;;   (1) Any operator after "opr" or "opr BIG" is made into a TeX mathord.
;;;   (2) "BIG" plus an operator NOT occurring after "opr" is made into a BIGOP token.

(defun fortress-process-opr-and-BIG (tokens)
  (do ((toks tokens (cdr toks))
       (opr-seen nil))
      ((null toks))
    (cond ((memq (car (first toks)) '(OPERATOR OPERATOR-WORD RELATION BIGOP))
	   (when opr-seen
	     (rplacd (cdr (first toks)) (append (list "\\mathord{") (cddr (first toks)) (list "}")))
	     (when (fortress-vertical-lines-operator (cadr (first toks)))
	       (rplacd (last (first toks)) (list "\\,")))))
	  ((and (eq (car (first toks)) 'KEYWORD)
		(string= (cadr (first toks)) "BIG")
		(not opr-seen))
	   (cond ((memq (car (second toks)) '(OPERATOR OPERATOR-WORD RELATION))
		  (rplaca toks (list 'BIGOP
				     (concat (cadr (first toks)) (cadr (second toks)))
				     (fortress-big-operator-tex (second toks))))
		  (rplacd toks (cddr toks)))
		 ((eq (car (second toks)) 'BIGOP)
		  (rplaca (cdr (second toks))
			  (concat (cadr (first toks)) (cadr (second toks))))
		  (rplaca toks (second toks))
		  (rplacd toks (cddr toks)))
		 ((eq (car (second toks)) 'WHITESPACE)
		  (cond ((memq (car (third toks)) '(OPERATOR OPERATOR-WORD RELATION))
			 (rplaca toks (list 'BIGOP
					    (concat (cadr (first toks)) (cadr (second toks)) (cadr (third toks)))
				     (fortress-big-operator-tex (third toks))))
			 (rplacd toks (cdddr toks)))
			((eq (car (second toks)) 'BIGOP)
			 (rplaca (cdr (second toks))
				 (concat (cadr (first toks)) (cadr (second toks)) (cadr (third toks))))
			 (rplaca toks (third toks))
			 (rplacd toks (cdddr toks))))))))
    (cond ((and (eq (car (first toks)) 'KEYWORD)
		(string= (cadr (first toks)) "opr"))
	   (setq opr-seen t))
	  ((not (eq (car (first toks)) 'WHITESPACE))
	   (setq opr-seen nil))))
  tokens)

;;; ??? This could use some refinement

(defun fortress-vertical-lines-operator (str)
  (every '(lambda (c) (= c ?\|)) str))

(defun fortress-big-operator-tex (tok)
  (or (gethash (caddr tok) *fortress-big-operator-hashtable*)
      (cond ((and (eq (car tok) 'OPERATOR-WORD)
		  (> (length (caddr tok)) 4)
		  (string= (substring (caddr tok) 0 5) "\\OPR{"))
	     (concat "\\BIGOPR" (substring (caddr tok) 4)))
	    (t (concat "\\BIGOP{" (caddr tok) "}")))))

;;; We consider three forms of exponent:
;;; (a) Simple name or literal
;;; (b) Parameterized type, that is, name followed by [\...\]
;;; (c) Parenthesized/bracketed expression.
;;; Anything else, we just leave the ^ operator in place.

(defun fortress-process-superscripts (tokens)
  (do ((toks tokens (cdr toks)))
      ((null toks))
    (when (and (eq (car (car toks)) 'CIRCUMFLEX) (cdr toks))
      (case (car (cadr toks))
	((IDENTIFIER)
	 (cond ((and (cddr toks)
		     (eq (car (caddr toks)) 'LEFT-WHITE-BRACKET)
		     (fortress-balanced-expression-no-newlines (cddr toks)))
		(rplaca (cddr (car toks)) "^{")
		(rplacd (last (gethash (caddr toks) *fortress-matching-hashtable*)) (list "}")))
	       (t (rplaca (cddr (car toks)) "^{")
		  (rplacd (last (cadr toks)) (list "}")))))
	((NUMBER STRING CHARACTER-LITERAL)
	 (rplaca (cddr (car toks)) "^{")
	 (rplacd (last (cadr toks)) (list "}")))
	((LEFT-PARENTHESIS)
	 (when (fortress-balanced-expression-no-newlines (cdr toks))
	   (rplaca (cddr (car toks)) "^{")
	   (rplaca (cddr (cadr toks)) "")
	   (rplaca (cddr (gethash (cadr toks) *fortress-matching-hashtable*)) "}")))
	((LEFT-BRACKET LEFT-ENCLOSER)
	 (when (fortress-balanced-expression-no-newlines (cdr toks))
	   (rplaca (cddr (car toks)) "^{")
	   (rplacd (last (gethash (cadr toks) *fortress-matching-hashtable*)) (list "}")))))))
  tokens)

(defun fortress-balanced-expression-no-newlines (toks)
  (and (memq (car (car toks)) '(LEFT-PARENTHESIS LEFT-BRACKET LEFT-ENCLOSER LEFT-WHITE-BRACKET))
       (let ((end (gethash (car toks) *fortress-matching-hashtable*)))
	 (and end
	      (do ((z (cdr toks) (cdr z)))
		  ((or (null z) (eq (car z) end)) t)
		(when (eq (car (car z)) 'NEWLINE)
		  (return nil)))))))

;;; In order to render a true subscript, the subscripting brackets must immediately
;;; follow an identifier with no intervening whitespace.
;;; We consider only subscripts that contain no whitespace, comments, or keywords.
;;; Anything else, we just leave the square brackets in place.

(defun fortress-process-subscripts (tokens)
  (do ((toks tokens (cdr toks))
       (prev nil toks)
       (prevprev nil prev))
      ((null toks))
    (when (eq (first (car toks)) 'LEFT-BRACKET)
      (cond ((fortress-balanced-expression-generator-list-p toks)
	     ;; We have a generator list.  This can become mathematical limits
	     ;; if it follows a BIGOP (and we do allow whitespace in this case).
	     (when (and prev
			(or (eq (first (car prev)) 'BIGOP)
			    (and prevprev
				 (eq (first (car prevprev)) 'BIGOP)
				 (eq (first (car prev)) 'WHITESPACE))))
	       (let ((end (gethash (car toks) *fortress-matching-hashtable*))
		     (items (fortress-balanced-expression-items toks)))
		 ;; If there are m generators, then:
		 ;; (a) The left bracket is rendered as "\\limits_{"
		 ;;    plus m-1 copies of "\\genfrac{}{}{0pt}{1}{".
		 ;; (b) The first comma (if any) is rendered as "}{".
		 ;; (c) Every comma but the first is rendered as "}}{".
		 ;; (d) The right bracket is "}" for one generator and otherwise "}}".
		 (rplaca (cddr (car toks)) "\\limits_{")
		 (do ((items (fortress-balanced-expression-items toks) (cdr items))
		      (first t nil))
		     ((null items))
		   ;; 
		   (unless first
		     (rplacd (last (car toks)) (list "\\genfrac{}{}{0pt}{1}{")))
		   (rplaca (cddr (car (cdr (memq (cadr (car items)) toks))))
			   (if (null (cdr items))
			       (if first "}" "}}")
			     (if first "}{" "}}{")))))))		 
	    ((and (eq (car (car prev)) 'IDENTIFIER)
		  (fortress-balanced-expression-suitable-subscript toks))
	     (let ((end (gethash (car toks) *fortress-matching-hashtable*)))
	       (rplaca (cddr (car toks)) "_{")
	       (rplaca (cddr end) "}"))))))
  tokens)

(defun fortress-balanced-expression-suitable-subscript (toks)
  (and (eq (car (car toks)) 'LEFT-BRACKET)
       (let ((end (gethash (car toks) *fortress-matching-hashtable*)))
	 (and end
	      (do ((z (cdr toks) (cdr z)))
		  ((or (null z) (eq (car z) end)) t)
		(when (memq (car (car z)) '(NEWLINE WHITESPACE DIGIT-GROUP-SEPARATOR
						    COMMENT COMMENT-START COMMENT-LINE KEYWORD))
		  (return nil)))))))

;;; The list of tokens must begin with the left bracket that begins a subscript.
;;; This predicate is true if the subscript begins with a generator expression
;;; (an unenclosed <- is found before an unenclosed comma is encountered).

(defun fortress-balanced-expression-generator-list-p (toks)
  (and (eq (car (car toks)) 'LEFT-BRACKET)
       (let ((end (gethash (car toks) *fortress-matching-hashtable*)))
	 (and end
	      (do ((z (cdr toks) (cdr z))
		   (skipto nil))
		  ((or (null z) (eq (car z) end)) nil)
		(cond (skipto (when (eq (car z) skipto) (setq skipto nil)))
		      (t (case (car (car z))
			   ((COMMA) (return nil))
			   ((OPERATOR)
			    (when (or (string= (cadr (car z)) "<-")
				      (string= (cadr (car z)) "\u2190"))
			      (return t)))
			   ((LEFT-PARENTHESIS LEFT-BRACKET LEFT-ENCLOSER LEFT-WHITE-BRACKET)
			    (setq skipto (gethash (car z) *fortress-matching-hashtable*)))))))))))

;;; The list of tokens must begin with an enclosed expression.
;;; The expression is divided into the parts separated by commas;
;;; the result is a list of start-token/end-token pairs for the parts.

(defun fortress-balanced-expression-items (toks)
  (and (memq (car (car toks)) '(LEFT-PARENTHESIS LEFT-BRACKET LEFT-ENCLOSER LEFT-WHITE-BRACKET))
       (let ((end (gethash (car toks) *fortress-matching-hashtable*)))
	 (and end
	      (do ((z (cdr toks) (cdr z))
		   (start (and (not (eq (cadr toks) end)) (cadr toks)))
		   (result '())
		   (skipto nil))
		  ((or (null z) (eq (car z) end)) (reverse result))
		(when (eq (car z) skipto) (setq skipto nil))
		(when (null skipto)
		  (cond ((eq (cadr z) end)
			 (push (list start (car z)) result))
			((and (eq (car (cadr z)) 'COMMA)
			      (not (eq (caddr z) end)))
			 (push (list start (car z)) result)
			 (setq start (caddr z)))
			((memq (car (car z))
			       '(LEFT-PARENTHESIS LEFT-BRACKET LEFT-ENCLOSER LEFT-WHITE-BRACKET))
			 (setq skipto (gethash (car z) *fortress-matching-hashtable*))))))))))

;;; To make `unit` declarations a bit nicer, we tweak the rendering of whitespace.
;;; This will be in addition to the intertoken spacing added in a later phase.
   
(defun fortress-process-unit-declarations (tokens)
  (do ((toks tokens (cdr toks)))
      ((null toks))
    (when (and (eq (car (car toks)) 'KEYWORD)
	       (string= (cadr (car toks)) "unit")
	       (cdr toks)
	       (eq (car (cadr toks)) 'WHITESPACE))
      (do ((z (cddr toks) (cddr z)))
	  ((or (null z)
	       (null (cdr z))
	       (not (eq (car (car z)) 'IDENTIFIER))
	       (not (eq (car (cadr z)) 'WHITESPACE))))
	(rplacd (last (cadr z)) (list "\\,")))))
  tokens)


;;; The idea here is that we turn an enclosed expression of the form x CHOOSE y
;;; into TeX {x \choose y}, and perhaps similarly for other operators.  In order
;;; for this transformation to be valid, x and y must not contain any relational
;;; operators outside parentheses.

;;; In order to do this, we need to process all CHOOSE expressions that fall within a line.
;;; To do THAT, we keep a stack that is pushed when we see a left encloser and popped
;;; when we see a right encloser.  Each stack entry tracks the latest token that could
;;; not be part of a tight juxtaposition as well as the position of any tight "/".

;;; A stack entry is a 7-tuple of
;;; (left-encloser possible before-left-start-or-nil left-end-or-nil choose-op-or-nil right-start-or-nil right-end-or-nil).

(defun fortress-process-choose-etc (tokens)
  (let ((dummy (cons (list 'DUMMY) tokens)))
    (do ((toks tokens (cdr toks))
	 (prev dummy toks)
	 (stack (list (list nil t nil nil nil nil nil))))
	((null toks))
      (let ((thistok (car toks))
	    (top (first stack)))
	(ecase (car thistok)
	  ((LEFT-PARENTHESIS LEFT-BRACKET LEFT-WHITE-BRACKET LEFT-ENCLOSER)
	   (cond ((null (second top)))
		 ((null (fifth top))
		  (unless (third top)
		    (setf (third top) prev))
		  (setf (fourth top) toks))
		 (t (unless (sixth top)
		      (setf (sixth top) toks))
		    (setf (seventh top) toks)))
	   (when (gethash thistok *fortress-matching-hashtable*)
	     (push (list toks t nil nil nil nil nil) stack)))
	  ((RIGHT-PARENTHESIS RIGHT-BRACKET RIGHT-WHITE-BRACKET RIGHT-ENCLOSER)
	   (when (gethash thistok *fortress-matching-hashtable*)
	     (fortress-maybe-process-one-choose top toks)
	     (pop stack)
	     (let ((top (first stack)))
	       (cond ((null (second top)))
		     ((null (fifth top))
		      (unless (third top)
			(setf (third top) prev))
		      (setf (fourth top) toks))
		     (t (unless (sixth top)
			  (setf (sixth top) toks))
			(setf (seventh top) toks))))))
	  ((NEWLINE)
	   ;; Cancel all outstanding possibilities, because we don't want
	   ;; to use any that has an embedded newline.
	   (dolist (s stack) (setf (second s) nil)))
	  ((WHITESPACE DIGIT-GROUP-SEPARATOR COMMENT COMMENT-LINE COMMENT-START COMMENT-MIDDLE COMMENT-END))
	  ((COMMA SEMICOLON RELATION)
	   ;; Cancel the current possibility
	   (setf (second top) nil))
	  ((OPERATOR OPERATOR-WORD)
	   (cond ((gethash (second thistok) *fortress-choose-op-hashtable*)
		  (cond ((and (second top) (third top) (null (fifth top)))
			 (setf (fifth top) toks))
			(t (setf (second top) nil))))
		 ((null (second top)))
		 ((null (fifth top))
		  (unless (third top)
		    (setf (third top) prev))
		  (setf (fourth top) toks))
		 (t (unless (sixth top)
		      (setf (sixth top) toks))
		    (setf (seventh top) toks))))
	  ((AMPERSAND COLON BIGOP KEYWORD UNKNOWN
		      CHARACTER-LITERAL CIRCUMFLEX COMMENT-ALIGN-START COMMENT-ALIGN-END
		      DOT FRACTION-START FRACTION-END IDENTIFIER NUMBER
		      STRING STRING-START STRING-MIDDLE STRING-END)
	   (cond ((null (second top)))
		 ((null (fifth top))
		  (unless (third top)
		    (setf (third top) prev))
		  (setf (fourth top) toks))
		 (t (unless (sixth top)
		      (setf (sixth top) toks))
		    (setf (seventh top) toks)))))))
    (rest dummy)))

;;; If either operand is surrounded by matching parentheses,
;;; those parentheses are not rendered.  The overall surrounding
;;; parentheses are certainly not rendered.

(defun fortress-maybe-process-one-choose (stack-entry right-encloser)
  (let ((left-encloser (first stack-entry))
	(possible (second stack-entry))
	(before-left-start (third stack-entry))
	(left-end (fourth stack-entry))
	(choose-op (fifth  stack-entry))
	(right-start (sixth stack-entry))
	(right-end (seventh stack-entry)))
    (when (and possible before-left-start left-end choose-op right-start right-end)
      ;; We have a choose-like operator to render, all right.
      (fortress-maybe-suppress-parentheses (first left-encloser) (first right-encloser))
      (fortress-maybe-suppress-parentheses (second before-left-start) (first left-end))
      (fortress-maybe-suppress-parentheses (first right-start) (first right-end))
      (setf (cdr before-left-start) (cons (list 'FRACTION-START "" "{\\textstyle ") (cdr before-left-start)))
      (setf (third (first choose-op)) (concat (gethash (second (first choose-op)) *fortress-choose-op-hashtable*) "\\textstyle"))
      (setf (cdr right-end) (cons (list 'FRACTION-END "" "}") (cdr right-end))))))

;;; The idea here is that a tight fraction xxx/yyy gets turned into LaTeX {xxx \over yyy}.
;;; In order to do this, we need to process all tight juxtapositions that fall within a line.
;;; To do THAT, we keep a stack that is pushed when we see a left encloser and popped
;;; when we see a right encloser.  Each stack entry tracks the latest token that could
;;; not be part of a tight juxtaposition as well as the position of any tight "/".

;;; A stack entry is a triple of (left-encloser juxta-start-or-nil tight-slash-or-nil).

(defun fortress-process-fractions (tokens)
  (let ((dummy (cons (list 'DUMMY) tokens)))
    (do ((toks tokens (cdr toks))
	 (prev dummy toks)
	 (stack (list (list nil nil nil))))
	((null toks)
	 (fortress-maybe-process-one-fraction (second (first stack))
					      (third (first stack))
					      prev))
      (let ((thistok (car toks)))
	(ecase (car thistok)
	  ((LEFT-PARENTHESIS LEFT-BRACKET LEFT-WHITE-BRACKET LEFT-ENCLOSER)
	   (unless (second (first stack))
	     (setf (second (first stack)) prev))
	   (when (gethash thistok *fortress-matching-hashtable*)
	     (push (list thistok nil nil) stack)))
	  ((RIGHT-PARENTHESIS RIGHT-BRACKET RIGHT-WHITE-BRACKET RIGHT-ENCLOSER)
	   (when (gethash thistok *fortress-matching-hashtable*)
	     (fortress-maybe-process-one-fraction (second (first stack))
						  (third (first stack))
						  prev)
	     (pop stack)))
	  ((NEWLINE)
	   (fortress-maybe-process-one-fraction (second (first stack))
						(third (first stack))
						prev)
	   ;; Cancel all outstanding juxtapositions, because we don't want
	   ;; to use any that has an embedded newline.
	   (dolist (s stack) (setf (second s) nil)))
	  ((WHITESPACE DIGIT-GROUP-SEPARATOR COMMENT COMMENT-LINE COMMENT-START COMMENT-MIDDLE COMMENT-END
		       AMPERSAND COLON COMMA OPERATOR-WORD SEMICOLON UNKNOWN)
	   (fortress-maybe-process-one-fraction (second (first stack))
						(third (first stack))
						prev)
	   (setf (second (first stack)) nil)
	   (setf (third (first stack)) nil))
	  ((OPERATOR RELATION)
	   (cond ((string= (second thistok) "/")
		  (when (second (first stack))
		    (setf (third (first stack)) prev)))
		 (t (fortress-maybe-process-one-fraction (second (first stack))
							 (third (first stack))
							 prev)
		    (setf (second (first stack)) nil)
		    (setf (third (first stack)) nil))))
	  ((BIGOP)
	   (fortress-maybe-process-one-fraction (second (first stack))
						(third (first stack))
						prev)
	   (setf (second (first stack)) nil)
	   (setf (third (first stack)) nil))
	  ((KEYWORD)
	   (ecase (gethash (cadr thistok) *fortress-keyword-hashtable*)
	     ((KEYWORD)
	      (fortress-maybe-process-one-fraction (second (first stack))
						   (third (first stack))
						   prev)
	      (setf (second (first stack)) nil)
	      (setf (third (first stack)) nil))
	     ((IDENTIFIER)
	      (unless (second (first stack))
		(setf (second (first stack)) prev)))))
	  ((CHARACTER-LITERAL CIRCUMFLEX COMMENT-ALIGN-START COMMENT-ALIGN-END
			      DOT FRACTION-START FRACTION-END IDENTIFIER NUMBER
			      STRING STRING-START STRING-MIDDLE STRING-END)
	   (unless (second (first stack))
	     (setf (second (first stack)) prev))))))
    (rest dummy)))

;;; If the numerator or denominator is surrounded by matching parentheses,
;;; those parentheses are not rendered.

(defun fortress-maybe-process-one-fraction (left middle right)
  (when (and left
	     middle
	     (not (eq (cdr middle) right)))
    ;; We have a fraction to render, all right.
    (fortress-maybe-suppress-parentheses (second left) (first middle))
    (fortress-maybe-suppress-parentheses (third middle) (first right))
    (setf (cdr left) (cons (list 'FRACTION-START "" "{\\textstyle") (cdr left)))
    (setf (third (second middle)) "\\over\\textstyle")
    (setf (cdr right) (cons (list 'FRACTION-END "" "}") (cdr right)))))


(defun fortress-maybe-suppress-parentheses (leftend rightend)
  (when (and (eq (car leftend) 'LEFT-PARENTHESIS)
	     (eq (car rightend) 'RIGHT-PARENTHESIS)
	     (eq (gethash leftend *fortress-matching-hashtable*) rightend))
    (setf (third leftend) "")
    (setf (third rightend) "")))

;;; This routine must come after fraction processing
;;; and CHOOSE processing because it checks for suppressed parentheses.

(defun fortress-process-surds (tokens)
  (do ((toks tokens (cdr toks)))
      ((null toks))
    (let ((thistok (car toks))
	  (beyond (and (cdr toks)
		       (if (eq (car (cadr toks)) 'WHITESPACE)
			   (cddr toks)
			 (cdr toks)))))
      (when beyond
	(cond ((memq (car thistok) '(OPERATOR OPERATOR-WORD))
	       (let ((item (gethash (cadr (car toks)) *fortress-surd-hashtable*)))
		 (when item
		   (let ((finaltok
			  (case (car (first beyond))
			    ((IDENTIFIER)
			     (cond ((and (cdr beyond)
					 (eq (car (second beyond)) 'LEFT-WHITE-BRACKET)
					 (fortress-balanced-expression-no-newlines (cdr beyond)))
				    (rplacd (cdr (car toks)) (list item "{"))
				    (gethash (cadr beyond) *fortress-matching-hashtable*))
				   (t (rplacd (cdr (car toks)) (list item "{"))
				      (first beyond))))
			    ((NUMBER STRING CHARACTER-LITERAL)
			     (rplacd (cdr (car toks)) (list item "{"))
			     (first beyond))
			    ((LEFT-PARENTHESIS)
			     (when (fortress-balanced-expression-no-newlines beyond)
			       (rplacd (cdr (car toks)) (list item "{"))
			       (rplaca (cddr (first beyond)) "")
			       (let ((rp (gethash (first beyond) *fortress-matching-hashtable*)))
				 (rplaca (cddr rp) "")
				 ;; An additional small touch: if there is no built-up fraction within the
				 ;; argument, then set the argument in text style.  This tends to reduce
				 ;; the size of parentheses needed around the entire surd.
				 (do ((z toks (cdr z)))
				     ((or (null z) (eq (car z) rp))
				      (rplacd (cdr (car toks)) (cons "{\\textstyle" (cddr (car toks))))
				      (rplacd (last rp) (list "}")))
				   (when (and (eq (first (car z)) 'OPERATOR)
					      (string= (third (car z)) "\\over"))
				     (return)))
				 rp)))
			    ((LEFT-BRACKET LEFT-ENCLOSER)
			     (when (fortress-balanced-expression-no-newlines beyond)
			       (rplacd (cdr (car toks)) (list item "{"))
			       (gethash (first beyond) *fortress-matching-hashtable*))))))
		     (when finaltok
		       (rplacd (last finaltok) (list "}"))
		       (let ((finalplace (memq finaltok toks)))
			 (when (and finalplace
				    (cdr finalplace)
				    (memq (car (cadr finalplace))
					  '(RIGHT-PARENTHESIS RIGHT-BRACKET RIGHT-WHITE-BRACKET RIGHT-ENCLOSER))
				    (not (string= (third (cadr finalplace)) "")) ;Watch out for suppressed parentheses
				    )
			   (rplacd (last finaltok) (list "\\,"))))))
		   (when (eq (car (cadr toks)) 'WHITESPACE)
		     (rplaca (cadr toks) 'NOSPACE)))))))))
  tokens)


;;; ****************************************************************
;;; ***** (7) Increase size of certain bracketing delimiters.
;;; ****************************************************************

;;; Here are the rules:
;;; (a) The sizes used are normal, \big, \Big, \bigg (etc.), and variable (\left and \right).
;;;     We encode these as 0, 1, 2, 3 (etc.) and 1000.  Default is 0.
;;; (b) Matching left and right enclosers should always be the same size.
;;; (c) If an enclosing pair also contains a "|" (and is thus a comprehension),
;;;     all three of these matched delimiters are made the same size.
;;; (d) Matched delimiters are always at least as large as any contained
;;;     delimiter that is on the same line as one of the matched delimiters.
;;; (e) A matching pair consisting of vertical bars is always made at least
;;;     one size larger than any contained non-variable-size matched delimiters.
;;; (f) A matching pair that:
;;;     (i) is within a line, and
;;;     (ii) is not within another matching pair within the line, and
;;;     (iii) contains at least one pair of matched delimiters, and
;;;     (iv) contains no matched delimiter larger than size 0
;;;     is made at least size 1.
;;; (g) A matching pair that:
;;;     (i) is within a line, and
;;;     (ii) contains a SQRT or tight fraction or BIG operator or CHOOSE operator
;;;     is given variable size.
;;; (h) A matching pair that:
;;;     (i) is NOT within a line, and
;;;     (ii) contains a SQRT or tight fraction or BIG operator or CHOOSE operator
;;;     is given size at least 2.

(defun fortress-resize-bracketing-delimiters (tokens *fortress-matching-hashtable*)
  (let ((comprehension-matching-hashtable (make-hash-table :test 'eq))
	(bracket-size-hashtable (make-hash-table :test 'eq))
	(bracket-newline-hashtable (make-hash-table :test 'eq))
	(bracket-big-hashtable (make-hash-table :test 'eq)))
    (fortress-initialize-bracket-hashtables tokens
					    comprehension-matching-hashtable
					    bracket-size-hashtable
					    bracket-newline-hashtable
					    bracket-big-hashtable)
    (fortress-compute-bracket-sizes tokens
				    comprehension-matching-hashtable
				    bracket-size-hashtable
				    bracket-newline-hashtable
				    bracket-big-hashtable)
    (fortress-install-bracket-sizes tokens
				    comprehension-matching-hashtable
				    bracket-size-hashtable)
    tokens))

;;; In the first pass we initialize several hashtables.
;;; (a) One matches each "|" comprehension token to its matching left encloser and vice versa.
;;; (b) One holds the size for each delimiter (initially 0).
;;; (c) One says whether a left encloser belongs to a pair that contains a newline.
;;; (d) One says whether a left encloser belongs to a pair that contains a SQRT or tight fraction or BIG operator or CHOOSE operator.

(defun fortress-initialize-bracket-hashtables (tokens comprehension-matching-hashtable
						      bracket-size-hashtable
						      bracket-newline-hashtable
						      bracket-big-hashtable)
  (let ((stack '()))   ;Stack items are (left-encloser possibly-comprehension-p)
    (do ((toks tokens (cdr toks))
	 (prevtoks nil toks))
	((null toks))
      (let ((thistok (car toks)))
	(ecase (first thistok)
	  ((LEFT-PARENTHESIS)
	   (when (and (string= (third thistok) "(")
		      (gethash thistok *fortress-matching-hashtable*))
	     (puthash thistok 0 bracket-size-hashtable)
	     (push (list thistok nil) stack)))
	  ((LEFT-WHITE-BRACKET)
	   (when (gethash thistok *fortress-matching-hashtable*)
	     (puthash thistok 0 bracket-size-hashtable)
	     (push (list thistok nil) stack)))
	  ((LEFT-BRACKET)
	   (when (and (string= (third thistok) "[")
		      (gethash thistok *fortress-matching-hashtable*))
	     (puthash thistok 0 bracket-size-hashtable)
	     (push (list thistok t) stack)))
	  ((LEFT-ENCLOSER)
	   (when (gethash thistok *fortress-matching-hashtable*)
	     (puthash thistok 0 bracket-size-hashtable)
	     (push (list thistok t) stack)))
	  ((RIGHT-PARENTHESIS)
	   (when (and (string= (third thistok) ")")
		      (gethash thistok *fortress-matching-hashtable*))
	     (puthash thistok 0 bracket-size-hashtable)
	     (pop stack)))
	  ((RIGHT-BRACKET)
	   (when (and (string= (third thistok) "]")
		      (gethash thistok *fortress-matching-hashtable*))
	     (puthash thistok 0 bracket-size-hashtable)
	     (pop stack)))
	  ((RIGHT-WHITE-BRACKET RIGHT-ENCLOSER)
	   (when (gethash thistok *fortress-matching-hashtable*)
	     (puthash thistok 0 bracket-size-hashtable)
	     (pop stack)))
	  ((NEWLINE)
	   (dolist (stackitem stack)
	     (puthash (first stackitem) t bracket-newline-hashtable)))
	  ((OPERATOR-WORD)
	   (when (or (gethash (second thistok) *fortress-surd-hashtable*)
		     (gethash (second thistok) *fortress-choose-op-hashtable*))
	     (dolist (stackitem stack)
	       (puthash (first stackitem) t bracket-big-hashtable))))
	  ((OPERATOR)
	   (cond ((string= (second thistok) "/")
		  (when (and (string= (second thistok) "/")
			     (or (null prevtoks)
				 (memq (first (first prevtoks))
				       '(RIGHT-PARENTHESIS RIGHT-BRACKET RIGHT-WHITE-BRACKET RIGHT-ENCLOSER
							   IDENTIFIER NUMBER CHARACTER-LITERAL STRING STRING-END)))
			     (or (null (rest toks))
				 (memq (first (first (rest toks)))
				       '(LEFT-PARENTHESIS LEFT-BRACKET LEFT-WHITE-BRACKET LEFT-ENCLOSER
							  IDENTIFIER NUMBER CHARACTER-LITERAL STRING STRING-START))))
		    (dolist (stackitem stack)
		      (puthash (first stackitem) t bracket-big-hashtable))))
		 ((or (gethash (second thistok) *fortress-surd-hashtable*)
		      (gethash (second thistok) *fortress-choose-op-hashtable*))
		  (dolist (stackitem stack)
		    (puthash (first stackitem) t bracket-big-hashtable)))
		 ((or (string= (second thistok) "<-")
		      (string= (second thistok) "\\u2190"))
		  (when (not (null stack))
		    (setf (second (car stack)) nil)))
		 ((string= (second thistok) "|")
		  (when (not (null stack))
		    ;; Enter the left encloser and vertical bar both ways in the comprehension hashtable.
		    (puthash thistok (first (car stack)) comprehension-matching-hashtable)
		    (puthash (first (car stack)) thistok comprehension-matching-hashtable)
		    (puthash thistok 0 bracket-size-hashtable)
		    (setf (second (car stack)) nil)))))
	  ((BIGOP)
	   (dolist (stackitem stack)
	     (puthash (first stackitem) t bracket-big-hashtable)))
	  ((COMMA SEMICOLON)
	   (when (not (null stack))
	     (setf (second (car stack)) nil)))
	  ((WHITESPACE NOSPACE DIGIT-GROUP-SEPARATOR COMMENT-ALIGN-START COMMENT-ALIGN-END
		       COMMENT COMMENT-LINE COMMENT-START COMMENT-MIDDLE COMMENT-END
		       AMPERSAND COLON RELATION UNKNOWN KEYWORD CHARACTER-LITERAL
		       CIRCUMFLEX DOT IDENTIFIER NUMBER FRACTION-START FRACTION-END
		       STRING STRING-START STRING-MIDDLE STRING-END)))))))


(defun fortress-compute-bracket-sizes (tokens comprehension-matching-hashtable
					      bracket-size-hashtable
					      bracket-newline-hashtable
					      bracket-big-hashtable)
  (let ((stack '())) ;Stack items are (left-encloser max-size-of-contained-enclosers max-size-of-contained-enclosers-before-first-newline max-size-of-contained-enclosers-after-last-newline newline-seen)
    (do ((toks tokens (cdr toks))
	 (prevtoks nil toks))
	((null toks))
      (let ((thistok (car toks)))
	(case (first thistok)
	  ((LEFT-PARENTHESIS LEFT-BRACKET LEFT-WHITE-BRACKET LEFT-ENCLOSER)
	   (when (and (gethash thistok *fortress-matching-hashtable*)
		      (or (not (eq (first thistok) 'LEFT-PARENTHESIS)) (string= (third thistok) "("))
		      (or (not (eq (first thistok) 'LEFT-BRACKET)) (string= (third thistok) "[")))
	     (push (list thistok -1 -1 -1 nil) stack)))
	  ((RIGHT-PARENTHESIS RIGHT-BRACKET RIGHT-WHITE-BRACKET RIGHT-ENCLOSER)
	   (let ((lefttok (gethash thistok *fortress-matching-hashtable*)))
	     (when (and lefttok
			(or (not (eq (first thistok) 'RIGHT-PARENTHESIS)) (string= (third thistok) ")"))
			(or (not (eq (first thistok) 'RIGHT-BRACKET)) (string= (third thistok) "]")))
	       (let ((midtok (gethash lefttok comprehension-matching-hashtable)))
		 ;; Here we implement the resizing policy rules.
		 ;; First figure out how big this delimiter set is going to be.
		 (let ((resultsize (max (gethash thistok bracket-size-hashtable)
					(gethash lefttok bracket-size-hashtable)
					(if midtok (gethash midtok bracket-size-hashtable) 0)))
		       (stackitem (pop stack)))
		   ;; Rule (d)
		   (setq resultsize
			 (max resultsize (third stackitem) (fourth stackitem)))
		   ;; Rule (e)
		   (when (every #'(lambda (c) (= c ?\|)) (second lefttok))
		     (setq resultsize
			   (max resultsize
				(min 1000 (+ (second stackitem) 1)))))
		   ;; Rule (f)
		   (when (and (null (gethash lefttok bracket-newline-hashtable))
			      (or (null stack)
				  (gethash (first (car stack)) bracket-newline-hashtable))
			      (= (second stackitem) 0))
		     (setq resultsize (max resultsize 1)))
		   ;; Rules (g) and (h)
		   (when (gethash lefttok bracket-big-hashtable)
		     (setq resultsize
			   (max resultsize
				(if (gethash lefttok bracket-newline-hashtable) 2 1000))))
		   ;; Now install the result size in all delimiters of the set.
		   (puthash thistok resultsize bracket-size-hashtable)
		   (puthash lefttok resultsize bracket-size-hashtable)
		   (when midtok (puthash midtok resultsize bracket-size-hashtable))
		   ;; Finally, propagate the size of this set to containing sets on the stack.
		   (dolist (outerstackitem stack)
		     (setf (second outerstackitem) (max (second outerstackitem) resultsize))
		     (unless (fifth outerstackitem)
		       (setf (third outerstackitem) (max (third outerstackitem) resultsize)))
		     (setf (fourth outerstackitem) (max (fourth outerstackitem) resultsize))))))))
	  ((NEWLINE)
	   (dolist (stackitem stack)
	     (setf (fourth stackitem) -1)
	     (setf (fifth stackitem) t))))))))

;;; In the last pass we change the rendering of each bracket according to its size.
;;; Size 0 remains unchanged.

(defun fortress-install-bracket-sizes (tokens comprehension-matching-hashtable
					      bracket-size-hashtable)
  (dolist (thistok tokens)
    (cond ((and (gethash thistok *fortress-matching-hashtable*)
		(memq (first thistok)
		      '(LEFT-PARENTHESIS LEFT-WHITE-BRACKET LEFT-BRACKET LEFT-ENCLOSER
					 RIGHT-PARENTHESIS RIGHT-WHITE-BRACKET RIGHT-BRACKET RIGHT-ENCLOSER)))
	   (when (and (or (not (eq (first thistok) 'LEFT-PARENTHESIS)) (string= (third thistok) "("))
		      (or (not (eq (first thistok) 'LEFT-BRACKET)) (string= (third thistok) "["))
		      (or (not (eq (first thistok) 'RIGHT-PARENTHESIS)) (string= (third thistok) ")"))
		      (or (not (eq (first thistok) 'RIGHT-BRACKET)) (string= (third thistok) "]")))
	     (fortress-bracket-size-fixup thistok (gethash thistok bracket-size-hashtable))))
	  (t (let ((left (gethash thistok comprehension-matching-hashtable)))
	       (when left
		 ;; We have a "|" token for a comprehension.  May need to put \left. after the left delimiter.
		 (let ((size (gethash thistok bracket-size-hashtable)))
		   (fortress-bracket-size-fixup thistok size)
		   (when (= size 1000)
		     (rplacd (last left) (list "\\left."))))))))))

(defun fortress-bracket-size-fixup (thistok size)
  (when (not (= size 0))
    (let ((data (gethash (list (first thistok) (third thistok)) *fortress-bracket-resize-hashtable*)))
      (when data
	(setf (third thistok)
	      (if (= size 1000) (car data) (nth (min size (- (length data) 1)) data)))))))

;;; ****************************************************************
;;; ***** (8) Adjust spacing between pairs of tokens.
;;; ****************************************************************

(defun fortress-adjust-intertoken-spacing (tokens *fortress-matching-hashtable*)
  ;; Examine a sliding window of five tokens, adjusting the spacing after the third one.
  (and tokens
       (do ((z tokens (cdr z))
	    (prev1 '(WHITESPACE " " " ") (car z))
	    (prev2 '(SEMICOLON ";" ";") prev1)
	    (result '() (cons (fortress-adjust-one-intertoken-spacing
			       prev2
			       prev1
			       (first z)
			       (second z)
			       (or (third z) '(WHITESPACE " " " ")))
			      result)))
	   ((null (cdr z))
	    (fortress-tweak-post-bracket-spacing (reverse (cons (car z) result)))))))

;;; Here are the TeX math types in which various Fortress elements
;;; are initially rendered:

;;; Ord: CHARACTER-LITERAL COMMENT COMMENT-END COMMENT-LINE COMMENT-MIDDLE COMMENT-START
;;;      DOT IDENTIFIER NUMBER STRING STRING-END STRING-MIDDLE STRING-START UNKNOWN
;;; Op: BIGOP
;;; Bin: AMPERSAND OPERATOR OPERATOR-WORD
;;; Rel: KEYWORD (also OPERATOR and OPERATOR-WORD that is a RELATION)
;;; Open: LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS LEFT-WHITE-BRACKET
;;; Close: RIGHT-BRACKET RIGHT-ENCLOSER RIGHT-PARENTHESIS RIGHT-WHITE-BRACKET
;;; Punct: COLON COMMA SEMICOLON
;;; Inner:
;;; glue: DIGIT-GROUP-SEPARATOR WHITESPACE NEWLINE

;;; The TeX rules do a pretty good job, but in some cases we have to
;;; adjust the spacing, typically for one of three reasons:
;;; (1) We can't put variable names or operator words right next to each other.
;;; (2) TeX has no theory of postfix operators.
;;; (3) TeX puts no space between adjacent relations.

(defun fortress-adjust-one-intertoken-spacing (prev2 prev1 tok0 tok1 tok2)
  (let* ((thiskind (or (and (memq (car tok0) '(OPERATOR OPERATOR-WORD))
			    (gethash (cadr tok0) *fortress-operator-kind-hashtable*))
		       (and (eq (car tok0) 'KEYWORD)
			    (gethash (cadr tok0) *fortress-keyword-hashtable*))
		       (and (memq (car tok0) '(FRACTION-START FRACTION-END COMMENT-ALIGN-START COMMENT-ALIGN-END))
			    (car prev1))
		       (car tok0)))
	 (nexttok (if (eq (car tok1) 'WHITESPACE) tok2 tok1))
	 (nextkind (car nexttok)))
    (cond ((and (eq thiskind 'NUMBER) (eq nextkind 'NUMBER)) `(,@tok0 "\\;"))
	  ((and (memq thiskind '(CHARACTER-LITERAL STRING STRING-END UNKNOWN))
		(memq nextkind '(CHARACTER-LITERAL IDENTIFIER NUMBER STRING STRING-START UNKNOWN)))
	   `(,@tok0 "\\;"))
	  ((and (memq thiskind '(CHARACTER-LITERAL IDENTIFIER NUMBER STRING STRING-END UNKNOWN))
		(memq nextkind '(CHARACTER-LITERAL STRING STRING-START UNKNOWN)))
	   `(,@tok0 "\\;"))
	  ((and (eq (car tok1) 'WHITESPACE)
		(memq thiskind '(CHARACTER-LITERAL STRING STRING-END UNKNOWN))
		(memq nextkind '(LEFT-PARENTHESIS LEFT-BRACKET LEFT-WHITE-BRACKET LEFT-ENCLOSER)))
	   `(,@tok0 "\\;"))
	  ((and (eq (car tok1) 'WHITESPACE)
		(memq thiskind '(RIGHT-PARENTHESIS RIGHT-BRACKET RIGHT-WHITE-BRACKET RIGHT-ENCLOSER))
		(memq nextkind '(CHARACTER-LITERAL STRING STRING-START UNKNOWN)))
	   `(,@tok0 "\\;"))
	  ((and (or (memq thiskind '(IDENTIFIER NUMBER))
		    (and (eq (car tok1) 'WHITESPACE)
			 (memq thiskind '(RIGHT-PARENTHESIS RIGHT-BRACKET RIGHT-WHITE-BRACKET RIGHT-ENCLOSER))))
		(or (memq nextkind '(IDENTIFIER NUMBER))
		    (and (eq (car tok1) 'WHITESPACE)
			 (memq nextkind '(LEFT-PARENTHESIS LEFT-BRACKET LEFT-WHITE-BRACKET LEFT-ENCLOSER)))))
	   `(,@tok0 "\\,"))
	  ((and (memq thiskind '(CHARACTER-LITERAL COMMENT COMMENT-END IDENTIFIER NUMBER STRING STRING-END UNKNOWN))
		(memq nextkind '(COMMENT COMMENT-START)))
	   `(,@tok0 "\\fortresscommentsep"))
	  ((and (memq thiskind '(COMMENT COMMENT-END))
		(memq nextkind '(CHARACTER-LITERAL COMMENT COMMENT-START IDENTIFIER NUMBER STRING STRING-END UNKNOWN)))
	   `(,@tok0 "\\fortresscommentsep"))
	  ((and (eq nextkind 'COMMENT-LINE)
		(not (memq thiskind '(WHITESPACE NEWLINE))))
	   `(,@tok0 "\\fortresscommentsep"))
	  ((eq thiskind 'KEYWORD)
	   (cond ((and (or (string= (cadr tok0) "opr")
			   (string= (cadr tok0) "BIG"))
		       (memq nextkind '(OPERATOR OPERATOR-WORD RELATION BIGOP LEFT-BRACKET LEFT-ENCLOSER KEYWORD)))
		  `(,@tok0 "\\,"))
		 ((eq nextkind 'KEYWORD)
		  `(,@tok0 "\\;\\;"))
		 ((memq nextkind '(OPERATOR OPERATOR-WORD RELATION)) `(,@tok0 "\\;"))
		 (t tok0)))
	  ((and (memq thiskind '(OPERATOR OPERATOR-WORD RELATION)) (eq nextkind 'KEYWORD)) `(,@tok0 "\\;"))
	  ((memq thiskind '(OPERATOR OPERATOR-WORD RELATION))
	   (fortress-intertoken-postop-check prev2 prev1 tok0 tok1 tok2))
	  ((and (eq thiskind 'WHITESPACE)
		(or (and (memq (car prev1) '(LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS LEFT-WHITE-BRACKET))
			 (not (string= (third prev1) ""))) ;Watch out for suppressed parentheses here
		    (and (memq (car tok1) '(RIGHT-BRACKET RIGHT-ENCLOSER RIGHT-PARENTHESIS RIGHT-WHITE-BRACKET))
			 (not (string= (third tok1) ""))) ;Watch out for suppressed parentheses here
		    ))
	   (cond ((and (null (cdddr tok0))
		       (string= (second tok0) " ")
		       (string= (third tok0) " "))
		  '(WHITESPACE " " "\\,"))
		 (t `(,@tok0 "\\,"))))
	  ((and (eq thiskind 'WHITESPACE)
		(eq (car prev1) 'COMMA)
		(eq (car tok1) 'NUMBER)
		(> (length (cadr tok0)) 1))
	   `(WHITESPACE ,(cadr tok0) ,(concat " " (reduce 'concat (make-list (- (length (cadr tok0)) 1) "\\digitblank")))))
	  ((and (memq thiskind '(LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS LEFT-WHITE-BRACKET))
		(memq (car tok1) '(RIGHT-BRACKET RIGHT-ENCLOSER RIGHT-PARENTHESIS RIGHT-WHITE-BRACKET)))
	   `(,@tok0 "\\ultrathin"))
	  ;; More fixups go here
	  (t tok0))))

(defun fortress-intertoken-postop-check (prev2 prev1 tok0 tok1 tok2)
  (let* ((prevwhite (memq (car prev1) '(WHITESPACE NEWLINE DIGIT-GROUP-SEPARATOR)))
	 (nextwhite (memq (car tok1) '(WHITESPACE NEWLINE DIGIT-GROUP-SEPARATOR)))
	 (prevtok (if prevwhite prev2 prev1))
	 (nexttok (if nextwhite tok2 tok1)))
    (ecase (car prevtok)
      ((COMMENT COMMENT-START COMMENT-LINE COMMENT-MIDDLE COMMENT-END
		DOT IDENTIFIER NUMBER STRING-MIDDLE STRING-START UNKNOWN
		KEYWORD)
       (ecase (car nexttok)
	 ((CHARACTER-LITERAL COMMENT COMMENT-START COMMENT-MIDDLE COMMENT-END
			     DOT IDENTIFIER NUMBER STRING STRING-END STRING-MIDDLE STRING-START UNKNOWN
			     OPERATOR OPERATOR-WORD RELATION BIGOP COLON AMPERSAND
			     LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS LEFT-WHITE-BRACKET KEYWORD)
	  (cond ((and (not prevwhite) nextwhite)
		 ;; We have a postfix operator.
		 (cond ((eq (car tok0) 'OPERATOR-WORD)
			`(,(car tok0) ,(cadr tok0) "\\:\\mathord{" ,@(cddr tok0) ,(if (eq (car tok1) 'NEWLINE) "}" "}\\;")))
		       (t `(,(car tok0) ,(cadr tok0) "\\mathord{" ,@(cddr tok0) ,(if (eq (car tok1) 'NEWLINE) "}" "}\\:")))))
		(t tok0)))
	 ((RIGHT-BRACKET RIGHT-ENCLOSER RIGHT-PARENTHESIS RIGHT-WHITE-BRACKET COMMA SEMICOLON COMMENT-LINE
			 WHITESPACE NOSPACE NEWLINE DIGIT-GROUP-SEPARATOR COMMENT-ALIGN-START COMMENT-ALIGN-END
			 FRACTION-START FRACTION-END)
	  tok0)))
      ((CHARACTER-LITERAL STRING STRING-END RIGHT-BRACKET RIGHT-ENCLOSER RIGHT-PARENTHESIS RIGHT-WHITE-BRACKET)
       (ecase (car nexttok)
	 ((CHARACTER-LITERAL COMMENT COMMENT-START COMMENT-MIDDLE COMMENT-END
			     DOT IDENTIFIER NUMBER STRING STRING-END STRING-MIDDLE STRING-START UNKNOWN
			     OPERATOR OPERATOR-WORD RELATION BIGOP COLON AMPERSAND
			     LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS LEFT-WHITE-BRACKET KEYWORD)
	  (cond ((and (not prevwhite) nextwhite)
		 ;; We have a postfix operator.
		 `(,(car tok0) ,(cadr tok0) "\\mathord{" ,@(cddr tok0) ,(if (eq (car tok1) 'NEWLINE) "}" "}\\:")))
		(t tok0)))
	 ((RIGHT-BRACKET RIGHT-ENCLOSER RIGHT-PARENTHESIS RIGHT-WHITE-BRACKET COMMA SEMICOLON COMMENT-LINE
			 WHITESPACE NOSPACE NEWLINE DIGIT-GROUP-SEPARATOR COMMENT-ALIGN-START COMMENT-ALIGN-END
			 FRACTION-START FRACTION-END)
	  tok0)))
      ((COMMA SEMICOLON LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS LEFT-WHITE-BRACKET
	      AMPERSAND OPERATOR OPERATOR-WORD BIGOP COLON)
       (ecase (car nexttok)
	 ((IDENTIFIER NUMBER)
	  (if (and (eq (car tok0) 'OPERATOR-WORD) (not (eq (car tok1) 'NEWLINE))) `(,@tok0 "\\:") tok0))
	 ((COMMENT COMMENT-START COMMENT-LINE COMMENT-MIDDLE COMMENT-END
		DOT STRING-END STRING-MIDDLE UNKNOWN KEYWORD)
	  (if (eq (car tok1) 'NEWLINE) tok0 `(,@tok0 "\\:")))
	 ((CHARACTER-LITERAL STRING STRING-START LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS LEFT-WHITE-BRACKET
			     OPERATOR OPERATOR-WORD RELATION BIGOP AMPERSAND
			     RIGHT-BRACKET RIGHT-ENCLOSER RIGHT-PARENTHESIS RIGHT-WHITE-BRACKET COLON
			     WHITESPACE NOSPACE NEWLINE DIGIT-GROUP-SEPARATOR COMMA SEMICOLON
			     COMMENT-ALIGN-START COMMENT-ALIGN-END FRACTION-START FRACTION-END)
	  tok0)))
      ((RELATION WHITESPACE NOSPACE NEWLINE COMMENT-ALIGN-START COMMENT-ALIGN-END FRACTION-START FRACTION-END)
       tok0))))

;;; Two cases that cannot be handled with a finite window:
;;;   (a) a left encloser followed by type parameters in white brackets followed by whitespace
;;;   (b) a left encloser followed by whitespace followed by a number; need to check matching right encloser

(defun fortress-tweak-post-bracket-spacing (tokens)
  (do ((toks tokens (cdr toks)))
      ((null toks))
    (when (and (memq (car (car toks)) '(LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS))
	       (cdr toks))
      (cond ((eq (car (cadr toks)) 'LEFT-WHITE-BRACKET)
	     (let* ((r (gethash (cadr toks) *fortress-matching-hashtable*))
		    (z (and r (memq r (cddr toks)))))
	       (when (and z
			  (cdr z)
			  (eq (car (cadr z)) 'WHITESPACE)
			  (every '(lambda (c) (= c ?\s)) (caddr (cadr z)))
			  (null (cdddr (cadr z))))
		 (rplaca (cddr (cadr z)) "\\,"))))
	    ((and (eq (car (cadr toks)) 'WHITESPACE)
		  (cddr toks)
		  (eq (car (caddr toks)) 'NUMBER))
	     (let ((r (gethash (car toks) *fortress-matching-hashtable*)))
	       (when r
		 (do ((z (cdr toks) (cdr z)))
		     ((null z))
		   (when (and (cdr z)
			      (eq (cadr z) r))
		     (cond ((not (eq (car (car z)) 'WHITESPACE))
			    (rplaca (cddr (cadr toks))
				    (reduce 'concat
					    (make-list (length (cadr (cadr toks)))
						       "\\digitblank"))))
			   ((= (length (cadr (car z))) 1)
			    (rplaca (cddr (cadr toks))
				    (concat "\\,"
					    (reduce 'concat
						    (make-list (- (length (cadr (cadr toks))) 1)
							       "\\digitblank"))))))))))))))
  tokens)

;;; ****************************************************************
;;; ***** (9) Insert PUSHTABS, POPTABS, and TAB "tokens" as directed
;;; *****     by indentation and aligment.
;;; ****************************************************************

(defun fortress-supply-indentation (tokens)
  (if (null (assq 'NEWLINE tokens))
      tokens
    (let* ((tokens-copy (copy-list tokens))
	   (toks tokens-copy)
	   (prevline nil)
	   (indent-stack (cond ((eq (car (car toks)) 'WHITESPACE)
				(rplaca toks (list (car (car toks))
						   (cadr (car toks))
						   "{\\tt "
						   (make-string (length (cadr (car toks))) ?\~)
						   "}"))
				(rplacd toks
					(cons (list 'PUSHTABS "" "\\+")
					      (cdr toks)))
				(list toks '((DOT ".")))) ;Dummy DOT entry has zero indentation
			       (t (list toks)))))
      (while (setq toks (member-if '(lambda (x) (eq (car x) 'NEWLINE)) (cdr toks)))
	;; Invariant: indent-stack is nonempty
	;; Invariant: indentations in the stack are strictly monotonically decreasing
	;; Invariant: points-for-start-of-line-data in the stack are monotonically decreasing
	;; Invariant: the first token in "toks" is a NEWLINE; we're examining the line *after* it
	(cond ((and (not (eq (car (cadr toks)) 'NEWLINE))
		    (or (not (eq (car (cadr toks)) 'WHITESPACE))
			(not (eq (car (caddr toks)) 'NEWLINE)))
		    (not (memq (car (cadr toks)) '(COMMENT-MIDDLE COMMENT-END))))
	       ;; Line is nonblank, and not the middle or end of a comment.
	       (let ((k (fortress-indentation-of (cdr toks))))
		 (let ((decrements ""))
		   (while (< k (fortress-indentation-of (car indent-stack)))
		     (setq decrements (concat "\\-" decrements))
		     (pop indent-stack))
		   (when (> (length decrements) 0)
		     (let ((nl (car toks)))
		       (rplaca toks (list 'POPTABS "" decrements))
		       (rplacd toks (cons nl (cdr toks)))
		       (setq toks (cdr toks)))))
		 ;; Invariant: indent-stack is nonempty
		 (cond ((> k (fortress-indentation-of (car indent-stack)))
			(do ((line (car indent-stack) (cdr line))
			     (prevtok nil line)
			     (n 0 (+ n (length (cadr (car line))))))
			    ((or (null line)
				 (eq (car (car line)) 'NEWLINE)
				 (> n k))
			     ;; This line has to establish its own indentation
			     (let ((ind (fortress-indentation-of (car indent-stack))))
			       (cond ((eq (car (cadr toks)) 'WHITESPACE)
				      (fortress-install-pushtabs toks ind))
				     ((and (eq (car (cadr toks)) 'COMMENT-ALIGN-START)
					   (eq (car (caddr toks)) 'WHITESPACE))
				      (fortress-install-pushtabs (cdr toks) ind)))))
			  (when (and (= n k)
				     prevtok
				     (memq (car (car prevtok))
					   '(WHITESPACE LEFT-PARENTHESIS LEFT-BRACKET LEFT-ENCLOSER LEFT-WHITE-BRACKET))
				     ;; This last test makes "for" loops look good even with four-space indent increments.
				     (or (not (or (and (eq (car (car (car indent-stack))) 'KEYWORD)
						       (string= (cadr (car (car indent-stack))) "for"))
						  (and (eq (car (car (car indent-stack))) 'WHITESPACE)
						       (eq (car (cadr (car indent-stack))) 'KEYWORD)
						       (string= (cadr (cadr (car indent-stack))) "for"))))
					 (fortress-line-ends-with-comma (cdr prevline))))
			    ;; We have a good place to align to
			    (rplacd prevtok
				    (cons (list 'PUSHTABS "" "\\+")
					  (cdr prevtok)))
			    (return)))
			(push (cdr toks) indent-stack))
		       (t (pop indent-stack)
			  (push (cdr toks) indent-stack))))))
	(setq prevline toks))
      (let ((decrements ""))
	(while (not (null (cdr indent-stack)))
	  (setq decrements (concat "\\-" decrements))
	  (pop indent-stack))
	(when (> (length decrements) 0)
	  (let ((pt (list 'POPTABS "" decrements)))
	    (cond ((null (cdr prevline))
		   (rplacd prevline (cons pt (cdr prevline))))
		  (t (rplacd (last prevline) (list pt)))))))
      ;; Here's a fixup to move POPTABS before any COMMENT-ALIGN-END
      (do ((toks tokens-copy (cdr toks)))
	  ((null (cddr toks)))
	(when (and (eq (car (car toks)) 'COMMENT-ALIGN-END)
		   (eq (car (cadr toks)) 'POPTABS))
	  (rotatef (car toks) (cadr toks))))
      tokens-copy)))

(defun fortress-install-pushtabs (toks ind)
  ;; (cadr toks) must be a WHITESPACE token.
  (rplaca (cdr toks)
	  (list (car (cadr toks))
		(cadr (cadr toks))
		(make-string ind ?\s)
		(fortress-code-indent (- (length (cadr (cadr toks))) ind))))
  (rplacd (cdr toks)
	  (cons (list 'PUSHTABS "" "\\+")
		(cddr toks))))


(defun fortress-indentation-of (toks)
  (cond ((eq (car (car toks)) 'WHITESPACE)
	 (length (cadr (car toks))))
	((and (eq (car (car toks)) 'COMMENT-ALIGN-START)
	      (eq (car (cadr toks)) 'WHITESPACE))
	 (length (cadr (cadr toks))))
	(t 0)))

(defun fortress-code-indent (n)
  (cond ((= n 0) "")
	((= n 1) "\\1")
	(t (do ((k n (- k 2))
		(result "" (concat result "\\2")))
	       ((< k 4) (concat result (if (= k 3) "\\3 " "\\2")))))))

(defun fortress-line-ends-with-comma (toks)
  (do ((z toks (cdr z))
       (comma-seen nil))
      ((or (null z) (eq (car (car z)) 'NEWLINE)))
    (ecase (car (car z))
      ((COMMA) (setq comma-seen t))
      ((AMPERSAND BIGOP CHARACTER-LITERAL CIRCUMFLEX COLON DIGIT-GROUP-SEPARATOR DOT
		  IDENTIFIER KEYWORD LEFT-BRACKET LEFT-ENCLOSER LEFT-PARENTHESIS NUMBER
		  OPERATOR OPERATOR-WORD RIGHT-BRACKET RIGHT-ENCLOSER RIGHT-PARENTHESIS
		  SEMICOLON STRING STRING-END STRING-MIDDLE STRING-START UNKNOWN)
       (setq comma-seen nil))
      ((WHITESPACE NOSPACE COMMENT COMMENT-END COMMENT-LINE COMMENT-MIDDLE COMMENT-START)))))

;;; ****************************************************************
;;; ***** (10) Put it all back into the buffer as one big string.
;;; ****************************************************************

(defun fortify-fortress-tokens (tokens)
  (cond ((assq 'NEWLINE tokens)
	 (fortify-fortress-block tokens))
	((and tokens
	      (null (cdr tokens))
	      (null (cdddr (car tokens))))
	 (let ((str (third (car tokens))))
	   (cond ((and (= (length str) 1) (unicode-is-letter (elt str 0)))
		  (concat "\\VAR{" str "}"))
		 (t (let ((str5 (substring str 0 (min 5 (length str)))))
		      (cond ((and (or (string= str5 "\\VAR{")
				      (string= str5 "\\TYP{")
				      (string= str5 "\\KWD{")
				      (string= str5 "\\OPR{")
				      (string= str5 "\\STR{"))
				  (fortify-single-tex-macro-invocation-p str 5))
			     str)
			    (t (concat "\\EXP{" str "}"))))))))
	(t (concat "\\EXP{"
		   (fortify-careful-TeX-concat
		    (fortify-eliminate-redundant-math-mode-pairs
		     (apply 'append (mapcar 'cddr tokens))))
		   "}"))))

(defun fortify-fortress-block (tokens)
  (fortify-careful-TeX-concat
   (fortify-eliminate-redundant-math-mode-pairs
    (append (list "\\begin{FortressCode}\n")
	    (let ((rev (reverse tokens)))
	      (apply 'append (mapcar 'cddr (reverse (cond ((not (eq (car (car rev)) 'NEWLINE)) rev)
							  ((not (eq (car (cadr rev)) 'NEWLINE)) (cdr rev))
							  (t ;; Avoid leaving a blank line that TeX would treat as \par
							   (rplaca (cddr (car rev)) " \\\\") rev))))))
	    (list "\n\\end{FortressCode}\n")))))

(defun fortify-eliminate-redundant-math-mode-pairs (strs)
  (let ((s strs) (z '()))
    (while s
      (cond ((and (cdr s)
		  (string= (car s) "\\(")
		  (string= (cadr s) "\\)"))
	     (setq s (cddr s)))
	    (t (setq z (cons (car s) z))
	       (setq s (cdr s)))))
    (reverse z)))

(defun fortify-careful-TeX-concat (strs)
  (do ((s (remove "" strs) (cdr s))
       (z '() (cond ((= (length (car s)) 1)
		     (cons (car s) z))
		    (t (let ((c1 (elt (car s) (- (length (car s)) 1)))
			     (c2 (if (null (cdr s)) ?@ (elt (cadr s) 0))))
			 (cond ((and (or (and (<= ?A c1) (<= c1 ?Z)) (and (<= ?a c1) (<= c1 ?z)))
				     (or (and (<= ?A c2) (<= c2 ?Z)) (and (<= ?a c2) (<= c2 ?z))))
				(cons "{}" (cons (car s) z)))
			       (t (cons (car s) z))))))))
      ((null s) (apply 'concat (reverse z)))))

(defun fortify-single-tex-macro-invocation-p (str start)
  (let ((n (length str))
	(result t))
    (do ((k start (+ k 1))
	 (level 1 (let ((c (elt str k)))
		    (cond ((= c ?\{) 
			   (when (= level 0) (setq result nil))
			   (+ level 1))
			  ((= c ?\}) 
			   (when (= level 0) (error "Too many right braces in %s" str))
			   (- level 1))
			  (t (when (= level 0) (setq result nil))
			     level)))))
	((>= k n)
	 (unless (= level 0)
	   (error "Not enough right braces in %s" str))))
    result))



;;; ***** Tables

(defun fortress-initialize-hashtable-items (ht items)
  (dolist (x items) (puthash x t ht)))

(defun fortress-initialize-hashtable-pairs (ht items)
  (dolist (x items) (puthash (car x) (cadr x) ht)))

(defun fortress-initialize-two-hashtables (ht1 ht2 items)
  ;; Each item is (key value1 value2)
  (dolist (x items)
    (puthash (car x) (cadr x) ht1)
    (puthash (car x) (caddr x) ht2)))

(defun fortress-initialize-matched-hashtables (ht1 ht2 ht3 items)
  ;; Each item is a pair of pairs ((key1 value1) (key2 value2))
  ;; Third hashtable maps key1 to key2.
  (dolist (x items)
    (puthash (car (car x)) (cadr (car x)) ht1)
    (puthash (car (cadr x)) (cadr (cadr x)) ht2)
    (puthash (car (car x)) (car (cadr x)) ht3)))

(defun fortress-initialize-two-unicode-hashtables (ht1 ht2 items)
  ;; Each item is (codepoint TeXname Unicode-name other-names ...)
  (dolist (x items)
    (unless (eq (car x) 'none)
      (puthash (car x) (cadr x) ht1))
    (dolist (z (cddr x))
      (puthash z (cadr x) ht2))))

(defun fortress-initialize-two-unicode-hashtables-plus-kind (ht1 ht2 ht3 items)
  ;; Each item is (codepoint TeXname kind Unicode-name other-names ...)
  (dolist (x items)
    (unless (eq (car x) 'none)
      (puthash (car x) (cadr x) ht1)
      (puthash (string (car x)) (caddr x) ht2))
    (dolist (z (cdddr x))
      (puthash z (cadr x) ht3)
      (puthash z (caddr x) ht2))))

(setq *fortress-keyword-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-hashtable-pairs
 *fortress-keyword-hashtable*
 ;; Note that a few entries (such as for "self") are IDENTIFIER rather than KEYWORD.
 ;; FORALL is intentionally omitted (it's handled as an OPERATOR-WORD)
 '(("goto" KEYWORD) ("idiom" KEYWORD) ("public" KEYWORD) ("pure" KEYWORD)
   ("reciprocal" KEYWORD) ("static" KEYWORD) ("BIG" KEYWORD) ("EXCLUSIVE" KEYWORD)
   ("PREFIX" KEYWORD) ("SI_unit" KEYWORD) ("SUFFIX" KEYWORD) ("absorbs" KEYWORD)
   ("abstract" KEYWORD) ("also" KEYWORD) ("api" KEYWORD)
   ("asif" KEYWORD) ("at" KEYWORD) ("atomic" KEYWORD) ("bool" KEYWORD)
   ("case" KEYWORD) ("catch" KEYWORD) ("coerce" KEYWORD) ("coerces" KEYWORD)
   ("component" KEYWORD) ("comprises" KEYWORD) ("default" KEYWORD) ("dim" KEYWORD)
   ("do" KEYWORD) ("elif" KEYWORD) ("else" KEYWORD) ("end" KEYWORD)
   ("ensures" KEYWORD) ("except" KEYWORD) ("excludes" KEYWORD) ("exit" KEYWORD)
   ("export" KEYWORD) ("extends" KEYWORD) ("finally" KEYWORD) ("fn" KEYWORD)
   ("for" KEYWORD) ("forbid" KEYWORD) ("getter" KEYWORD) ("grammar" KEYWORD)
   ("hidden" KEYWORD) ("if" KEYWORD) ("import" KEYWORD) ("in" KEYWORD)
   ("int" KEYWORD) ("invariant" KEYWORD) ("io" KEYWORD) ("label" KEYWORD)
   ("most" KEYWORD) ("nat" KEYWORD) ("native" KEYWORD) ("object" KEYWORD)
   ("of" KEYWORD) ("opr" KEYWORD) ("or" KEYWORD) ("override" KEYWORD)
   ("private" KEYWORD) ("property" KEYWORD) ("provided" KEYWORD) ("requires" KEYWORD)
   ("self" IDENTIFIER) ("settable" KEYWORD) ("setter" KEYWORD) ("spawn" KEYWORD)
   ("syntax" KEYWORD) ("test" KEYWORD) ("then" KEYWORD) ("throw" KEYWORD)
   ("throws" KEYWORD) ("trait" KEYWORD) ("transient" KEYWORD) ("try" KEYWORD)
   ("tryatomic" KEYWORD) ("type" KEYWORD) ("typed" KEYWORD) ("typecase" KEYWORD)
   ("unit" KEYWORD) ("value" KEYWORD) ("var" KEYWORD) ("where" KEYWORD) ("while" KEYWORD)
   ("widens" KEYWORD) ("with" KEYWORD) ("wrapped" KEYWORD)
   ))

(setq *fortress-radix-specifier-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-hashtable-items
 *fortress-radix-specifier-hashtable*
 '("TWO" "THREE" "FOUR" "FIVE" "SIX" "SEVEN" "EIGHT" "NINE" "TEN"
   "ELEVEN" "TWELVE" "THIRTEEN" "FOURTEEN" "FIFTEEN" "SIXTEEN"))

(setq *fortress-surd-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-hashtable-pairs
 *fortress-surd-hashtable*
 '(("\u221A" "\\sqrt")
   ("SQUARE_ROOT" "\\sqrt")
   ("SQRT" "\\sqrt")
   ("\u221B" "\\sqrt[3]")
   ("CUBE_ROOT" "\\sqrt[3]")
   ("CBRT" "\\sqrt[3]")
   ("\u221C" "\\sqrt[4]")
   ("FOURTH_ROOT" "\\sqrt[4]")))


(setq *fortress-choose-op-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-hashtable-pairs
 *fortress-choose-op-hashtable*
 '(("CHOOSE" "\\choose")
   ("CYCLES" "\\atopwithdelims[]")
   ("SUBSETS" "\\atopwithdelims\\{\\}")
   ("EULERIAN" "\\atopwithdelims\\langle\\rangle")))

(setq *fortress-traditional-name-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-hashtable-pairs
 *fortress-traditional-name-hashtable*
 '(("sin" "\\sin")
   ("cos" "\\cos")
   ("tan" "\\tan")
   ("cot" "\\mathop{\\rm cot}\\nolimits")
   ("sec" "\\mathop{\\rm sec}\\nolimits")
   ("csc" "\\mathop{\\rm csc}\\nolimits")
   ("sinh" "\\sinh")
   ("cosh" "\\cosh")
   ("tanh" "\\tanh")
   ("coth" "\\mathop{\\rm coth}\\nolimits")
   ("sech" "\\mathop{\\rm sech}\\nolimits")
   ("csch" "\\mathop{\\rm csch}\\nolimits")
   ("arcsin" "\\arcsin")
   ("arccos" "\\arccos")
   ("arctan" "\\arctan")
   ("arccot" "\\mathop{\\rm arccot}\\nolimits")
   ("arcsec" "\\mathop{\\rm arcsec}\\nolimits")
   ("arccsc" "\\mathop{\\rm arccsc}\\nolimits")
   ("arsinh" "\\mathop{\\rm arsinh}\\nolimits")
   ("arcosh" "\\mathop{\\rm arcosh}\\nolimits")
   ("artanh" "\\mathop{\\rm artanh}\\nolimits")
   ("arcoth" "\\mathop{\\rm arcoth}\\nolimits")
   ("arsech" "\\mathop{\\rm arsech}\\nolimits")
   ("arcsch" "\\mathop{\\rm arcsch}\\nolimits")
   ("arg" "\\arg")
   ("deg" "\\deg")
   ("det" "\\det")
   ("exp" "\\exp")
   ("inf" "\\inf")
   ("sup" "\\sup")
   ("lg" "\\lg")
   ("ln" "\\ln")
   ("log" "\\log")
   ("gcd" "\\gcd")
   ("max" "\\max")
   ("min" "\\min")
   ))

(setq *fortress-identifier-face-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-hashtable-pairs
 *fortress-identifier-face-hashtable*
 '((monospace ("\\mathtt" nil nil nil))
   (script ("\\mathcal" nil nil nil))
   (fraktur (nil nil nil nil))
   (sansserif ("\\mathsf" "\\mathitsf" "\\mathbfsf" "\\mathbisf"))
   ))

(setq *fortress-identifier-codepoint-hashtable* (make-hash-table :test 'equal))
(setq *fortress-identifier-word-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-two-unicode-hashtables
 *fortress-identifier-codepoint-hashtable*
 *fortress-identifier-word-hashtable*
 '(
   ;; Greek letters
   (?\u0391 "\\mathrm{A}" "ALPHA")
   (?\u0392 "\\mathrm{B}" "BETA")
   (?\u0393 "\\Gamma" "GAMMA")
   (?\u0394 "\\Delta" "DELTA")
   (?\u0395 "\\mathrm{E}" "EPSILON")
   (?\u0396 "\\mathrm{Z}" "ZETA")
   (?\u0397 "\\mathrm{H}" "ETA")
   (?\u0398 "\\Theta" "THETA")
   (?\u0399 "\\mathrm{I}" "IOTA")
   (?\u039A "\\mathrm{K}" "KAPPA")
   (?\u039B "\\Lambda" "LAMDA" "LAMBDA")
   (?\u039C "\\mathrm{M}" "MU")
   (?\u039D "\\mathrm{N}""NU")
   (?\u039E "\\Xi" "XI")
   (?\u039F "\\mathrm{O}" "OMICRON")
   (?\u03A0 "\\Pi" "PI")
   (?\u03A1 "\\mathrm{P}" "RHO")
   (?\u03A3 "\\Sigma" "SIGMA")
   (?\u03A4 "\\mathrm{T}" "TAU")
   (?\u03A5 "\\Upsilon" "UPSILON")
   (?\u03A6 "\\Phi" "PHI")
   (?\u03A7 "\\mathrm{X}" "CHI")
   (?\u03A8 "\\Psi" "PSI")
   (?\u03A9 "\\Omega" "OMEGA")
   (?\u03B1 "\\alpha" "alpha")
   (?\u03B2 "\\beta" "beta")
   (?\u03B3 "\\gamma" "gamma")
   (?\u03B4 "\\delta" "delta")
   (?\u03B5 "\\epsilon" "epsilon")
   (?\u03B6 "\\zeta" "zeta")
   (?\u03B7 "\\eta" "eta")
   (?\u03B8 "\\theta" "theta")
   (?\u03B9 "\\iota" "iota")
   (?\u03BA "\\kappa" "kappa")
   (?\u03BB "\\lambda" "lamda" "lambda")
   (?\u03BC "\\mu" "mu")
   (?\u03BD "\\nu" "nu")
   (?\u03BE "\\xi" "xi")
   (?\u03BF "\\omicron" "omicron")
   (?\u03C0 "\\pi" "pi")
   (?\u03C1 "\\rho" "rho")
   (?\u03C3 "\\sigma" "sigma")
   (?\u03C4 "\\tau" "tau")
   (?\u03C5 "\\upsilon" "upsilon")
   (?\u03C6 "\\phi" "phi")
   (?\u03C7 "\\chi" "chi")
   (?\u03C8 "\\psi" "psi")
   (?\u03C9 "\\omega" "omega")
   ;; "micro"
   (?\u005B "\\mu" "micro")
   ))

(setq *fortress-operator-hashtable* (make-hash-table :test 'equal))
(setq *fortress-operator-kind-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-two-hashtables
 *fortress-operator-hashtable*
 *fortress-operator-kind-hashtable*
 '(
   ("..." "\\ldots" OPERATOR)
   ("::" "::" OPERATOR)
   ("::::" "::::" OPERATOR)
   (":=" "\\ASSIGN" RELATION)
   ("|" "\\mid" RELATION)
   ("||" "\\mathrel{\\Vert}" RELATION)
   ("|||" "\\mathrel{\\Vvert}" RELATION)
   ("||||" "\\mathrel{\\VVert}" RELATION)
   ("//" "\\mathrel{/\\!\\!/}" RELATION)
   ("///" "\\mathrel{/\\!\\!/\\!\\!/}" RELATION)
   ("////" "\\mathrel{/\\!\\!/\\!\\!/\\!\\!/}" RELATION)
   ("<-" "\\leftarrow" RELATION)
   ("->" "\\rightarrow" RELATION)
   ("<->" "\\leftrightarrow" RELATION)
   ("|->" "\\mapsto" RELATION)
   ("=>" "\\Rightarrow" RELATION)
   ("<=" "\\leq" RELATION)
   (">=" "\\geq" RELATION)
   ("<=>" "\\Leftrightarrow" RELATION)
   ("=/=" "\\neq" RELATION)
   ("~>" "\\leadsto" RELATION)
   ("===" "\\sequiv" RELATION)
   ("<-/-" "\\nleftarrow" RELATION)
   ("-/->" "\\nrightarrow" RELATION)
   ))

(setq *fortress-big-operator-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-hashtable-pairs
 *fortress-big-operator-hashtable*
 '(("\\wedge" "\\bigwedge")
   ("\\vee" "\\bigvee")
   ("\\cap" "\\bigcap")
   ("\\cup" "\\bigcup")
   ("\\odot" "\\bigodot")
   ("\\oplus" "\\bigoplus")
   ("\\otimes" "\\bigotimes")
   ("\\uplus" "\\biguplus")
   ))

(setq *fortress-honorary-letter-codepoint-hashtable* (make-hash-table :test 'equal))
(setq *fortress-honorary-letter-word-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-two-unicode-hashtables
 *fortress-honorary-letter-codepoint-hashtable*
 *fortress-honorary-letter-word-hashtable*
 '((?\u2205 "\\emptyset" "EMPTYSET")
   (?\u221E "\\infty" "INFINITY" "INF")
   (?\u22A4 "\\top" "DOWN_TACK" "TOP")
   (?\u22A5 "\\bot" "UP_TACK" "BOTTOM")
   ))

(setq *fortress-control-character-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-hashtable-pairs
 *fortress-control-character-hashtable*
 '((?\u0000 "\\FortressUnknownCharacter{NUL}")
   (?\u0009 "\\FortressUnknownCharacter{TAB}")
   (?\u001B "\\FortressUnknownCharacter{ESC}")
   (?\u007F "\\FortressUnknownCharacter{DEL}")
   ))

(setq *fortress-operator-codepoint-hashtable* (make-hash-table :test 'equal))
(setq *fortress-operator-word-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-two-unicode-hashtables-plus-kind
 *fortress-operator-codepoint-hashtable*
 *fortress-operator-kind-hashtable*
 *fortress-operator-word-hashtable*
 '((?\u002A "*" OPERATOR "ASTERISK")
   (?\u00B7 "\\cdot" OPERATOR "MIDDLE_DOT" "DOT")
   (?\u00D7 "\\times" OPERATOR "MULTIPLICATION_SIGN" "TIMES" "BY")
   (?\u2217 "\\ast" OPERATOR "ASTERISK_OPERATOR")
   (?\u228D "\\FortressUnknownCharacter{MULTISET MULTIPLICATION}" OPERATOR "MULTISET_MULTIPLICATION")
   (?\u2297 "\\otimes" OPERATOR "CIRCLED_TIMES" "OTIMES")
   (?\u2299 "\\odot" OPERATOR "CIRCLED_DOT_OPERATOR" "ODOT")
   (?\u229B "\\circledast" OPERATOR "CIRCLED_ASTERISK_OPERATOR" "CIRCLEDAST")
   (?\u22A0 "\\boxtimes" OPERATOR "SQUARED_TIMES" "BOXTIMES")
   (?\u22A1 "\\boxdot" OPERATOR "SQUARED_DOT_OPERATOR" "BOXDOT")
   (?\u22C5 "\\cdot" OPERATOR "DOT_OPERATOR")
   (?\u29C6 "\\FortressUnknownCharacter{SQUARED ASTERISK}" OPERATOR "SQUARED_ASTERISK" "BOXAST")
   (?\u29D4 "\\FortressUnknownCharacter{TIMES WITH LEFT HALF BLACK}" OPERATOR "TIMES_WITH_LEFT_HALF_BLACK")
   (?\u29D5 "\\FortressUnknownCharacter{TIMES WITH RIGHT HALF BLACK}" OPERATOR "TIMES_WITH_RIGHT_HALF_BLACK")
   (?\u2A2F "\\times" OPERATOR "VECTOR_OR_CROSS_PRODUCT" "CROSS")
   (?\u2A30 "\\FortressUnknownCharacter{MULTIPLICATION SIGN WITH DOT ABOVE}" OPERATOR "MULTIPLICATION_SIGN_WITH_DOT_ABOVE" "DOTTIMES")
   (?\u2A31 "\\FortressUnknownCharacter{MULTIPLICATION SIGN WITH UNDERBAR}" OPERATOR "MULTIPLICATION_SIGN_WITH_UNDERBAR")
   (?\u2A34 "\\FortressUnknownCharacter{MULTIPLICATION SIGN IN LEFT HALF CIRCLE}" OPERATOR "MULTIPLICATION_SIGN_IN_LEFT_HALF_CIRCLE")
   (?\u2A35 "\\FortressUnknownCharacter{MULTIPLICATION SIGN IN RIGHT HALF CIRCLE}" OPERATOR "MULTIPLICATION_SIGN_IN_RIGHT_HALF_CIRCLE")
   (?\u2A36 "\\FortressUnknownCharacter{CIRCLED MULTIPLICATION SIGN WITH CIRCUMFLEX ACCENT}" OPERATOR "CIRCLED_MULTIPLICATION_SIGN_WITH_CIRCUMFLEX_ACCENT")
   (?\u2A37 "\\FortressUnknownCharacter{MULTIPLICATION SIGN IN DOUBLE CIRCLE}" OPERATOR "MULTIPLICATION_SIGN_IN_DOUBLE_CIRCLE")
   (?\u2A3B "\\FortressUnknownCharacter{MULTIPLICATION SIGN IN TRIANGLE}" OPERATOR "MULTIPLICATION_SIGN_IN_TRIANGLE" "TRITIMES")
   (?\u002F "/" OPERATOR "SOLIDUS")
   (?\u00F7 "\\div" OPERATOR "DIVISION_SIGN" "DIV")
   (?\u2215 "/" OPERATOR "DIVISION_SLASH")
   (?\u2298 "\\oslash" OPERATOR "CIRCLED_DIVISION_SLASH" "OSLASH")
   (?\u29B8 "\\FortressUnknownCharacter{CIRCLED REVERSE SOLIDUS}" OPERATOR "CIRCLED_REVERSE_SOLIDUS")
   (?\u29BC "\\FortressUnknownCharacter{CIRCLED ANTICLOCKWISE ROTATED DIVISION SIGN}" OPERATOR "CIRCLED_ANTICLOCKWISE_ROTATED_DIVISION_SIGN")
   (?\u29C4 "\\FortressUnknownCharacter{SQUARED RISING DIAGONAL SLASH}" OPERATOR "SQUARED_RISING_DIAGONAL_SLASH" "BOXSLASH")
   (?\u29F5 "\\backslash" OPERATOR "REVERSE_SOLIDUS_OPERATOR")
   (?\u29F8 "\\bigl/" OPERATOR "BIG_SOLIDUS")
   (?\u29F9 "\\bigl\\backslash" OPERATOR "BIG_REVERSE_SOLIDUS")
   (?\u2A38 "\\FortressUnknownCharacter{CIRCLED DIVISION SIGN}" OPERATOR "CIRCLED_DIVISION_SIGN" "ODIV")
   (?\u2AFD "//" OPERATOR "DOUBLE_SOLIDUS_OPERATOR")
   (?\u2AFB "\\FortressUnknownCharacter{TRIPLE SOLIDUS BINARY RELATION}" OPERATOR "TRIPLE_SOLIDUS_BINARY_RELATION")
   (?\u002B "+" OPERATOR "PLUS_SIGN")
   (?\u002D "-" OPERATOR "HYPHEN_MINUS")
   (?\u2212 "-" OPERATOR "MINUS_SIGN")
   (?\u00B7 "\\cdot" OPERATOR "MIDDLE_DOT" "DOT")
   (?\u00D7 "\\times" OPERATOR "MULTIPLICATION_SIGN" "TIMES" "BY")
   (?\u00F7 "\\div" OPERATOR "DIVISION_SIGN" "DIV")
   (?\u2215 "/" OPERATOR "DIVISION_SLASH")
   (?\u2217 "\\ast" OPERATOR "ASTERISK_OPERATOR")
   (?\u22C5 "\\cdot" OPERATOR "DOT_OPERATOR")
   (?\u2A2F "\\times" OPERATOR "VECTOR_OR_CROSS_PRODUCT" "CROSS")
   (?\u2214 "\\dotplus" OPERATOR "DOT_PLUS" "DOTPLUS")
   (?\u2238 "\\dotminus" OPERATOR "DOT_MINUS" "DOTMINUS")
   (?\u2A30 "\\dottimes" OPERATOR "MULTIPLICATION_SIGN_WITH_DOT_ABOVE" "DOTTIMES")
   (?\u2A25 "\\FortressUnknownCharacter{PLUS SIGN WITH DOT BELOW}" OPERATOR "PLUS_SIGN_WITH_DOT_BELOW")
   (?\u2A2A "\\FortressUnknownCharacter{MINUS SIGN WITH DOT BELOW}" OPERATOR "MINUS_SIGN_WITH_DOT_BELOW")
   (?\u2A39 "\\FortressUnknownCharacter{PLUS SIGN IN TRIANGLE}" OPERATOR "PLUS_SIGN_IN_TRIANGLE" "TRIPLUS")
   (?\u2A3A "\\FortressUnknownCharacter{MINUS SIGN IN TRIANGLE}" OPERATOR "MINUS_SIGN_IN_TRIANGLE" "TRIMINUS")
   (?\u2A3B "\\FortressUnknownCharacter{MULTIPLICATION SIGN IN TRIANGLE}" OPERATOR "MULTIPLICATION_SIGN_IN_TRIANGLE" "TRITIMES")
   (?\u2295 "\\oplus" OPERATOR "CIRCLED_PLUS" "OPLUS")
   (?\u2296 "\\ominus" OPERATOR "CIRCLED_MINUS" "OMINUS")
   (?\u2297 "\\otimes" OPERATOR "CIRCLED_TIMES" "OTIMES")
   (?\u2298 "\\oslash" OPERATOR "CIRCLED_DIVISION_SLASH" "OSLASH")
   (?\u2299 "\\odot" OPERATOR "CIRCLED_DOT_OPERATOR" "ODOT")
   (?\u229B "\\circledast" OPERATOR "CIRCLED_ASTERISK_OPERATOR" "CIRCLEDAST")
   (?\u2A38 "\\FortressUnknownCharacter{CIRCLED DIVISION SIGN}" OPERATOR "CIRCLED_DIVISION_SIGN" "ODIV")
   (?\u229E "\\boxplus" OPERATOR "SQUARED_PLUS" "BOXPLUS")
   (?\u229F "\\boxminus" OPERATOR "SQUARED_MINUS" "BOXMINUS")
   (?\u22A0 "\\boxtimes" OPERATOR "SQUARED_TIMES" "BOXTIMES")
   (?\u22A1 "\\boxdot" OPERATOR "SQUARED_DOT_OPERATOR" "BOXDOT")
   (?\u29C4 "\\boxslash" OPERATOR "SQUARED_RISING_DIAGONAL_SLASH" "BOXSLASH")
   (?\u29C6 "\\FortressUnknownCharacter{SQUARED ASTERISK}" OPERATOR "SQUARED_ASTERISK" "BOXAST")
   (?\u00B1 "\\pm" OPERATOR "PLUS_MINUS_SIGN")
   (?\u2213 "\\mp" OPERATOR "MINUS_OR_PLUS_SIGN")
   (?\u2242 "\\FortressUnknownCharacter{MINUS TILDE}" OPERATOR "MINUS_TILDE")
   (?\u2A22 "\\overset{\\circ}{+}" OPERATOR "PLUS_SIGN_WITH_SMALL_CIRCLE_ABOVE")
   (?\u2A23 "\\Hat{+}" OPERATOR "PLUS_SIGN_WITH_CIRCUMFLEX_ACCENT_ABOVE")
   (?\u2A24 "\\overset{\\sim}{+}" OPERATOR "PLUS_SIGN_WITH_TILDE_ABOVE")
   (?\u2A26 "\\underset{\\sim}{+}" OPERATOR "PLUS_SIGN_WITH_TILDE_BELOW")
   (?\u2A27 "\\hbox{$+$}_2" OPERATOR "PLUS_SIGN_WITH_SUBSCRIPT_TWO")
   (?\u2A28 "\\FortressUnknownCharacter{PLUS SIGN WITH BLACK TRIANGLE}" OPERATOR "PLUS_SIGN_WITH_BLACK_TRIANGLE")
   (?\u2A29 "\\overset{,}{-}" OPERATOR "MINUS_SIGN_WITH_COMMA_ABOVE")
   (?\u2A2B "\\FortressUnknownCharacter{MINUS SIGN WITH FALLING DOTS}" OPERATOR "MINUS_SIGN_WITH_FALLING_DOTS")
   (?\u2A2C "\\FortressUnknownCharacter{MINUS SIGN WITH RISING DOTS}" OPERATOR "MINUS_SIGN_WITH_RISING_DOTS")
   (?\u2A2D "\\FortressUnknownCharacter{PLUS SIGN IN LEFT HALF CIRCLE}" OPERATOR "PLUS_SIGN_IN_LEFT_HALF_CIRCLE")
   (?\u2A2E "\\FortressUnknownCharacter{PLUS SIGN IN RIGHT HALF CIRCLE}" OPERATOR "PLUS_SIGN_IN_RIGHT_HALF_CIRCLE")
   (?\u2229 "\\cap" OPERATOR "INTERSECTION" "CAP" "INTERSECT")
   (?\u22D2 "\\Cap" OPERATOR "DOUBLE_INTERSECTION" "CAPCAP")
   (?\u2A40 "\\FortressUnknownCharacter{INTERSECTION WITH DOT}" OPERATOR "INTERSECTION_WITH_DOT")
   (?\u2A43 "\\overline{\\cap}" OPERATOR "INTERSECTION_WITH_OVERBAR")
   (?\u2A44 "\\FortressUnknownCharacter{INTERSECTION WITH LOGICAL AND}" OPERATOR "INTERSECTION_WITH_LOGICAL_AND")
   (?\u2A4B "\\FortressUnknownCharacter{INTERSECTION BESIDE AND JOINED WITH INTERSECTION}" OPERATOR "INTERSECTION_BESIDE_AND_JOINED_WITH_INTERSECTION")
   (?\u2A4D "\\FortressUnknownCharacter{CLOSED INTERSECTION WITH SERIFS}" OPERATOR "CLOSED_INTERSECTION_WITH_SERIFS")
   (?\u2ADB "\\FortressUnknownCharacter{TRANSVERSAL INTERSECTION}" OPERATOR "TRANSVERSAL_INTERSECTION")
   (?\u222A "\\cup" OPERATOR "UNION" "CUP" "UNION")
   (?\u228E "\\uplus" OPERATOR "MULTISET_UNION" "UPLUS")
   (?\u22D3 "\\Cup" OPERATOR "DOUBLE_UNION" "CUPCUP")
   (?\u2A41 "\\FortressUnknownCharacter{UNION WITH MINUS SIGN}" OPERATOR "UNION_WITH_MINUS_SIGN")
   (?\u2A42 "\\overline{\\cup}" OPERATOR "UNION_WITH_OVERBAR")
   (?\u2A45 "\\FortressUnknownCharacter{UNION WITH LOGICAL OR}" OPERATOR "UNION_WITH_LOGICAL_OR")
   (?\u2A4A "\\FortressUnknownCharacter{UNION BESIDE AND JOINED WITH UNION}" OPERATOR "UNION_BESIDE_AND_JOINED_WITH_UNION")
   (?\u2A4C "\\FortressUnknownCharacter{CLOSED UNION WITH SERIFS}" OPERATOR "CLOSED_UNION_WITH_SERIFS")
   (?\u2A50 "\\FortressUnknownCharacter{CLOSED UNION WITH SERIFS AND SMASH PRODUCT}" OPERATOR "CLOSED_UNION_WITH_SERIFS_AND_SMASH_PRODUCT")
   (?\u2216 "\\setminus" OPERATOR "SET_MINUS" "SETMINUS")
   (?\u2293 "\\sqcap" OPERATOR "SQUARE_CAP" "SQCAP")
   (?\u2A4E "\\FortressUnknownCharacter{DOUBLE SQUARE INTERSECTION}" OPERATOR "DOUBLE_SQUARE_INTERSECTION" "SQCAPCAP")
   (?\u2294 "\\sqcup" OPERATOR "SQUARE_CUP" "SQCUP")
   (?\u2A4F "\\FortressUnknownCharacter{DOUBLE SQUARE UNION}" OPERATOR "DOUBLE_SQUARE_UNION" "SQCUPCUP")
   (?\u003D "=" RELATION "EQUALS_SIGN" "EQ")
   (?\u007C "\\mid" RELATION "VERTICAL_LINE")
   (?\u2243 "\\simeq" RELATION "ASYMPTOTICALLY_EQUAL_TO" "SIMEQ")
   (?\u2245 "\\cong" RELATION "APPROXIMATELY_EQUAL_TO")
   (?\u2246 "\\FortressUnknownCharacter{APPROXIMATELY BUT NOT ACTUALLY EQUAL TO}" RELATION "APPROXIMATELY_BUT_NOT_ACTUALLY_EQUAL_TO")
   (?\u2248 "\\approx" RELATION "ALMOST_EQUAL_TO" "APPROX")
   (?\u224A "\\approxeq" RELATION "ALMOST_EQUAL_OR_EQUAL_TO" "APPROXEQ")
   (?\u224C "\\FortressUnknownCharacter{ALL EQUAL TO}" RELATION "ALL_EQUAL_TO")
   (?\u224D "\\asymp" RELATION "EQUIVALENT_TO")
   (?\u224E "\\Bumpeq" RELATION "GEOMETRICALLY_EQUIVALENT_TO" "BUMPEQV")
   (?\u2251 "\\doteqdot" RELATION "GEOMETRICALLY_EQUAL_TO" "DOTEQDOT")
   (?\u2252 "\\fallingdotseq" RELATION "APPROXIMATELY_EQUAL_TO_OR_THE_IMAGE_OF")
   (?\u2253 "\\risingdotseq" RELATION "IMAGE_OF_OR_APPROXIMATELY_EQUAL_TO")
   (?\u2256 "\\eqcirc" RELATION "RING_IN_EQUAL_TO" "EQRING")
   (?\u2257 "\\circeq" RELATION "RING_EQUAL_TO" "RINGEQ")
   (?\u225B "\\FortressUnknownCharacter{STAR EQUALS}" RELATION "STAR_EQUALS")
   (?\u225C "\\triangleq" RELATION "DELTA_EQUAL_TO" "EQDEL")
   (?\u225D "\\FortressUnknownCharacter{EQUAL TO BY DEFINITION}" RELATION "EQUAL_TO_BY_DEFINITION" "EQDEF")
   (?\u225F "\\FortressUnknownCharacter{QUESTIONED EQUAL TO}" RELATION "QUESTIONED_EQUAL_TO")
   (?\u2261 "\\equiv" RELATION "IDENTICAL_TO" "EQV" "EQUIV")
   (?\u2263 "\\sequiv" RELATION "STRICTLY_EQUIVALENT_TO" "SEQUIV")
   (none    "\\not\\sequiv" RELATION "NSEQUIV")
   (?\u229C "\\FortressUnknownCharacter{CIRCLED EQUALS}" RELATION "CIRCLED_EQUALS")
   (?\u22CD "\\backsimeq" RELATION "REVERSED_TILDE_EQUALS")
   (?\u22D5 "\\FortressUnknownCharacter{EQUAL AND PARALLEL TO}" RELATION "EQUAL_AND_PARALLEL_TO")
   (?\u29E3 "\\FortressUnknownCharacter{EQUALS SIGN AND SLANTED PARALLEL}" RELATION "EQUALS_SIGN_AND_SLANTED_PARALLEL")
   (?\u29E4 "\\FortressUnknownCharacter{EQUALS SIGN AND SLANTED PARALLEL WITH TILDE ABOVE}" RELATION "EQUALS_SIGN_AND_SLANTED_PARALLEL_WITH_TILDE_ABOVE")
   (?\u29E5 "\\FortressUnknownCharacter{IDENTICAL TO AND SLANTED PARALLEL}" RELATION "IDENTICAL_TO_AND_SLANTED_PARALLEL")
   (?\u2A66 "\\FortressUnknownCharacter{EQUALS SIGN WITH DOT BELOW}" RELATION "EQUALS_SIGN_WITH_DOT_BELOW")
   (?\u2A67 "\\FortressUnknownCharacter{IDENTICAL WITH DOT ABOVE}" RELATION "IDENTICAL_WITH_DOT_ABOVE")
   (?\u2A6C "\\FortressUnknownCharacter{SIMILAR MINUS SIMILAR}" RELATION "SIMILAR_MINUS_SIMILAR")
   (?\u2A6E "\\FortressUnknownCharacter{EQUALS WITH ASTERISK}" RELATION "EQUALS_WITH_ASTERISK")
   (?\u2A6F "\\FortressUnknownCharacter{ALMOST EQUAL TO WITH CIRCUMFLEX ACCENT}" RELATION "ALMOST_EQUAL_TO_WITH_CIRCUMFLEX_ACCENT")
   (?\u2A70 "\\FortressUnknownCharacter{APPROXIMATELY EQUAL OR EQUAL TO}" RELATION "APPROXIMATELY_EQUAL_OR_EQUAL_TO")
   (?\u2A71 "\\FortressUnknownCharacter{EQUALS SIGN ABOVE PLUS SIGN}" RELATION "EQUALS_SIGN_ABOVE_PLUS_SIGN")
   (?\u2A72 "\\FortressUnknownCharacter{PLUS SIGN ABOVE EQUALS SIGN}" RELATION "PLUS_SIGN_ABOVE_EQUALS_SIGN")
   (?\u2A73 "\\FortressUnknownCharacter{EQUALS SIGN ABOVE TILDE OPERATOR}" RELATION "EQUALS_SIGN_ABOVE_TILDE_OPERATOR")
   (?\u2A75 "\\FortressUnknownCharacter{TWO CONSECUTIVE EQUALS SIGNS}" RELATION "TWO_CONSECUTIVE_EQUALS_SIGNS")
   (?\u2A76 "\\FortressUnknownCharacter{THREE CONSECUTIVE EQUALS SIGNS}" RELATION "THREE_CONSECUTIVE_EQUALS_SIGNS")
   (?\u2A77 "\\FortressUnknownCharacter{EQUALS SIGN WITH TWO DOTS ABOVE AND TWO DOTS BELOW}" RELATION "EQUALS_SIGN_WITH_TWO_DOTS_ABOVE_AND_TWO_DOTS_BELOW")
   (?\u2A78 "\\FortressUnknownCharacter{EQUIVALENT WITH FOUR DOTS ABOVE}" RELATION "EQUIVALENT_WITH_FOUR_DOTS_ABOVE")
   (?\u2AAE "\\FortressUnknownCharacter{EQUALS SIGN WITH BUMPY ABOVE}" RELATION "EQUALS_SIGN_WITH_BUMPY_ABOVE")
   (?\uFE66 "\\FortressUnknownCharacter{SMALL EQUALS SIGN}" RELATION "SMALL_EQUALS_SIGN")
   (?\uFF1D "\\FortressUnknownCharacter{FULLWIDTH EQUALS SIGN}" RELATION "FULLWIDTH_EQUALS_SIGN")
   (?\u2244 "\\not\\simeq" RELATION "NOT_ASYMPTOTICALLY_EQUAL_TO" "NSIMEQ")
   (?\u2247 "\\ncong" RELATION "NEITHER_APPROXIMATELY_NOR_ACTUALLY_EQUAL_TO")
   (?\u2249 "\\not\\approx" RELATION "NOT_ALMOST_EQUAL_TO" "NAPPROX")
   (?\u2260 "\\neq" RELATION "NOT_EQUAL_TO" "NE")
   (?\u2262 "\\not\\equiv" RELATION "NOT_IDENTICAL_TO" "NEQV" "NEQUIV")
   (?\u226D "\\not\\asymp" RELATION "NOT_EQUIVALENT_TO")
   (?\u003C "<" RELATION "LESS_THAN_SIGN" "LT")
   (?\u2264 "\\leq" RELATION "LESS_THAN_OR_EQUAL_TO" "LE")
   (?\u2266 "\\leqq" RELATION "LESS_THAN_OVER_EQUAL_TO")
   (?\u2268 "\\lneqq" RELATION "LESS_THAN_BUT_NOT_EQUAL_TO")
   (?\u226A "\\ll" RELATION "MUCH_LESS_THAN" "LLT")
   (?\u2272 "\\lesssim" RELATION "LESS_THAN_OR_EQUIVALENT_TO")
   (?\u22D6 "\\lessdot" RELATION "LESS_THAN_WITH_DOT" "DOTLT")
   (?\u22D8 "\\lll" RELATION "VERY_MUCH_LESS_THAN" "LLLT")
   (?\u22DC "\\FortressUnknownCharacter{EQUAL TO OR LESS THAN}" RELATION "EQUAL_TO_OR_LESS_THAN")
   (?\u22E6 "\\lnsim" RELATION "LESS_THAN_BUT_NOT_EQUIVALENT_TO")
   (?\u29C0 "\\FortressUnknownCharacter{CIRCLED LESS THAN}" RELATION "CIRCLED_LESS_THAN")
   (?\u2A79 "\\FortressUnknownCharacter{LESS THAN WITH CIRCLE INSIDE}" RELATION "LESS_THAN_WITH_CIRCLE_INSIDE")
   (?\u2A7B "\\FortressUnknownCharacter{LESS THAN WITH QUESTION MARK ABOVE}" RELATION "LESS_THAN_WITH_QUESTION_MARK_ABOVE")
   (?\u2A7D "\\FortressUnknownCharacter{LESS THAN OR SLANTED EQUAL TO}" RELATION "LESS_THAN_OR_SLANTED_EQUAL_TO")
   (?\u2A7F "\\FortressUnknownCharacter{LESS THAN OR SLANTED EQUAL TO WITH DOT INSIDE}" RELATION "LESS_THAN_OR_SLANTED_EQUAL_TO_WITH_DOT_INSIDE")
   (?\u2A81 "\\FortressUnknownCharacter{LESS THAN OR SLANTED EQUAL TO WITH DOT ABOVE}" RELATION "LESS_THAN_OR_SLANTED_EQUAL_TO_WITH_DOT_ABOVE")
   (?\u2A83 "\\FortressUnknownCharacter{LESS THAN OR SLANTED EQUAL TO WITH DOT ABOVE RIGHT}" RELATION "LESS_THAN_OR_SLANTED_EQUAL_TO_WITH_DOT_ABOVE_RIGHT")
   (?\u2A85 "\\FortressUnknownCharacter{LESS THAN OR APPROXIMATE}" RELATION "LESS_THAN_OR_APPROXIMATE")
   (?\u2A87 "\\FortressUnknownCharacter{LESS THAN AND SINGLE LINE NOT EQUAL TO}" RELATION "LESS_THAN_AND_SINGLE_LINE_NOT_EQUAL_TO")
   (?\u2A89 "\\FortressUnknownCharacter{LESS THAN AND NOT APPROXIMATE}" RELATION "LESS_THAN_AND_NOT_APPROXIMATE")
   (?\u2A8D "\\FortressUnknownCharacter{LESS THAN ABOVE SIMILAR OR EQUAL}" RELATION "LESS_THAN_ABOVE_SIMILAR_OR_EQUAL")
   (?\u2A95 "\\FortressUnknownCharacter{SLANTED EQUAL TO OR LESS THAN}" RELATION "SLANTED_EQUAL_TO_OR_LESS_THAN")
   (?\u2A97 "\\FortressUnknownCharacter{SLANTED EQUAL TO OR LESS THAN WITH DOT INSIDE}" RELATION "SLANTED_EQUAL_TO_OR_LESS_THAN_WITH_DOT_INSIDE")
   (?\u2A99 "\\FortressUnknownCharacter{DOUBLE LINE EQUAL TO OR LESS THAN}" RELATION "DOUBLE_LINE_EQUAL_TO_OR_LESS_THAN")
   (?\u2A9B "\\FortressUnknownCharacter{DOUBLE LINE SLANTED EQUAL TO OR LESS THAN}" RELATION "DOUBLE_LINE_SLANTED_EQUAL_TO_OR_LESS_THAN")
   (?\u2A9D "\\FortressUnknownCharacter{SIMILAR OR LESS THAN}" RELATION "SIMILAR_OR_LESS_THAN")
   (?\u2A9F "\\FortressUnknownCharacter{SIMILAR ABOVE LESS THAN ABOVE EQUALS SIGN}" RELATION "SIMILAR_ABOVE_LESS_THAN_ABOVE_EQUALS_SIGN")
   (?\u2AA1 "\\FortressUnknownCharacter{DOUBLE NESTED LESS THAN}" RELATION "DOUBLE_NESTED_LESS_THAN")
   (?\u2AA3 "\\FortressUnknownCharacter{DOUBLE NESTED LESS THAN WITH UNDERBAR}" RELATION "DOUBLE_NESTED_LESS_THAN_WITH_UNDERBAR")
   (?\u2AA6 "\\FortressUnknownCharacter{LESS THAN CLOSED BY CURVE}" RELATION "LESS_THAN_CLOSED_BY_CURVE")
   (?\u2AA8 "\\FortressUnknownCharacter{LESS THAN CLOSED BY CURVE ABOVE SLANTED EQUAL}" RELATION "LESS_THAN_CLOSED_BY_CURVE_ABOVE_SLANTED_EQUAL")
   (?\u2AF7 "\\FortressUnknownCharacter{TRIPLE NESTED LESS THAN}" RELATION "TRIPLE_NESTED_LESS_THAN")
   (?\u2AF9 "\\FortressUnknownCharacter{DOUBLE LINE SLANTED LESS THAN OR EQUAL TO}" RELATION "DOUBLE_LINE_SLANTED_LESS_THAN_OR_EQUAL_TO")
   (?\uFE64 "\\FortressUnknownCharacter{SMALL LESS THAN SIGN}" RELATION "SMALL_LESS_THAN_SIGN")
   (?\uFF1C "\\FortressUnknownCharacter{FULLWIDTH LESS THAN SIGN}" RELATION "FULLWIDTH_LESS_THAN_SIGN")
   (?\u003E ">" RELATION "GREATER_THAN_SIGN" "GT")
   (?\u2265 "\\geq" RELATION "GREATER_THAN_OR_EQUAL_TO" "GE")
   (?\u2267 "\\geqq" RELATION "GREATER_THAN_OVER_EQUAL_TO")
   (?\u2269 "\\gneqq" RELATION "GREATER_THAN_BUT_NOT_EQUAL_TO")
   (?\u226B "\\gg" RELATION "MUCH_GREATER_THAN" "GGT")
   (?\u2273 "\\gtrsim" RELATION "GREATER_THAN_OR_EQUIVALENT_TO")
   (?\u22D7 "\\gtrdot" RELATION "GREATER_THAN_WITH_DOT" "DOTGT")
   (?\u22D9 "\\ggg" RELATION "VERY_MUCH_GREATER_THAN" "GGGT")
   (?\u22DD "\\FortressUnknownCharacter{EQUAL TO OR GREATER THAN}" RELATION "EQUAL_TO_OR_GREATER_THAN")
   (?\u22E7 "\\gnsim" RELATION "GREATER_THAN_BUT_NOT_EQUIVALENT_TO")
   (?\u29C1 "\\FortressUnknownCharacter{CIRCLED GREATER THAN}" RELATION "CIRCLED_GREATER_THAN")
   (?\u2A7A "\\FortressUnknownCharacter{GREATER THAN WITH CIRCLE INSIDE}" RELATION "GREATER_THAN_WITH_CIRCLE_INSIDE")
   (?\u2A7C "\\FortressUnknownCharacter{GREATER THAN WITH QUESTION MARK ABOVE}" RELATION "GREATER_THAN_WITH_QUESTION_MARK_ABOVE")
   (?\u2A7E "\\FortressUnknownCharacter{GREATER THAN OR SLANTED EQUAL TO}" RELATION "GREATER_THAN_OR_SLANTED_EQUAL_TO")
   (?\u2A80 "\\FortressUnknownCharacter{GREATER THAN OR SLANTED EQUAL TO WITH DOT INSIDE}" RELATION "GREATER_THAN_OR_SLANTED_EQUAL_TO_WITH_DOT_INSIDE")
   (?\u2A82 "\\FortressUnknownCharacter{GREATER THAN OR SLANTED EQUAL TO WITH DOT ABOVE}" RELATION "GREATER_THAN_OR_SLANTED_EQUAL_TO_WITH_DOT_ABOVE")
   (?\u2A84 "\\FortressUnknownCharacter{GREATER THAN OR SLANTED EQUAL TO WITH DOT ABOVE LEFT}" RELATION "GREATER_THAN_OR_SLANTED_EQUAL_TO_WITH_DOT_ABOVE_LEFT")
   (?\u2A86 "\\FortressUnknownCharacter{GREATER THAN OR APPROXIMATE}" RELATION "GREATER_THAN_OR_APPROXIMATE")
   (?\u2A88 "\\FortressUnknownCharacter{GREATER THAN AND SINGLE LINE NOT EQUAL TO}" RELATION "GREATER_THAN_AND_SINGLE_LINE_NOT_EQUAL_TO")
   (?\u2A8A "\\FortressUnknownCharacter{GREATER THAN AND NOT APPROXIMATE}" RELATION "GREATER_THAN_AND_NOT_APPROXIMATE")
   (?\u2A8E "\\FortressUnknownCharacter{GREATER THAN ABOVE SIMILAR OR EQUAL}" RELATION "GREATER_THAN_ABOVE_SIMILAR_OR_EQUAL")
   (?\u2A96 "\\FortressUnknownCharacter{SLANTED EQUAL TO OR GREATER THAN}" RELATION "SLANTED_EQUAL_TO_OR_GREATER_THAN")
   (?\u2A98 "\\FortressUnknownCharacter{SLANTED EQUAL TO OR GREATER THAN WITH DOT INSIDE}" RELATION "SLANTED_EQUAL_TO_OR_GREATER_THAN_WITH_DOT_INSIDE")
   (?\u2A9A "\\FortressUnknownCharacter{DOUBLE LINE EQUAL TO OR GREATER THAN}" RELATION "DOUBLE_LINE_EQUAL_TO_OR_GREATER_THAN")
   (?\u2A9C "\\FortressUnknownCharacter{DOUBLE LINE SLANTED EQUAL TO OR GREATER THAN}" RELATION "DOUBLE_LINE_SLANTED_EQUAL_TO_OR_GREATER_THAN")
   (?\u2A9E "\\FortressUnknownCharacter{SIMILAR OR GREATER THAN}" RELATION "SIMILAR_OR_GREATER_THAN")
   (?\u2AA0 "\\FortressUnknownCharacter{SIMILAR ABOVE GREATER THAN ABOVE EQUALS SIGN}" RELATION "SIMILAR_ABOVE_GREATER_THAN_ABOVE_EQUALS_SIGN")
   (?\u2AA2 "\\FortressUnknownCharacter{DOUBLE NESTED GREATER THAN}" RELATION "DOUBLE_NESTED_GREATER_THAN")
   (?\u2AA7 "\\FortressUnknownCharacter{GREATER THAN CLOSED BY CURVE}" RELATION "GREATER_THAN_CLOSED_BY_CURVE")
   (?\u2AA9 "\\FortressUnknownCharacter{GREATER THAN CLOSED BY CURVE ABOVE SLANTED EQUAL}" RELATION "GREATER_THAN_CLOSED_BY_CURVE_ABOVE_SLANTED_EQUAL")
   (?\u2AF8 "\\FortressUnknownCharacter{TRIPLE NESTED GREATER THAN}" RELATION "TRIPLE_NESTED_GREATER_THAN")
   (?\u2AFA "\\FortressUnknownCharacter{DOUBLE LINE SLANTED GREATER THAN OR EQUAL TO}" RELATION "DOUBLE_LINE_SLANTED_GREATER_THAN_OR_EQUAL_TO")
   (?\uFE65 "\\FortressUnknownCharacter{SMALL GREATER THAN SIGN}" RELATION "SMALL_GREATER_THAN_SIGN")
   (?\uFF1E "\\FortressUnknownCharacter{FULLWIDTH GREATER THAN SIGN}" RELATION "FULLWIDTH_GREATER_THAN_SIGN")
   (?\u226E "\\nless" RELATION "NOT_LESS_THAN" "NLT")
   (?\u226F "\\ngtr" RELATION "NOT_GREATER_THAN" "NGT")
   (?\u2270 "\\nleq" RELATION "NEITHER_LESS_THAN_NOR_EQUAL_TO" "NLE")
   (?\u2271 "\\ngeq" RELATION "NEITHER_GREATER_THAN_NOR_EQUAL_TO" "NGE")
   (?\u2274 "\\not\\lesssim" RELATION "NEITHER_LESS_THAN_NOR_EQUIVALENT_TO")
   (?\u2275 "\\not\\gtrsim" RELATION "NEITHER_GREATER_THAN_NOR_EQUIVALENT_TO")
   (?\u2276 "\\lessgtr" RELATION "LESS_THAN_OR_GREATER_THAN")
   (?\u2277 "\\gtrless" RELATION "GREATER_THAN_OR_LESS_THAN")
   (?\u2278 "\\FortressUnknownCharacter{NEITHER LESS THAN NOR GREATER THAN}" RELATION "NEITHER_LESS_THAN_NOR_GREATER_THAN")
   (?\u2279 "\\FortressUnknownCharacter{NEITHER GREATER THAN NOR LESS THAN}" RELATION "NEITHER_GREATER_THAN_NOR_LESS_THAN")
   (?\u22DA "\\lesseqgtr" RELATION "LESS_THAN_EQUAL_TO_OR_GREATER_THAN")
   (?\u22DB "\\gtreqless" RELATION "GREATER_THAN_EQUAL_TO_OR_LESS_THAN")
   (?\u2A8B "\\FortressUnknownCharacter{LESS THAN ABOVE DOUBLE LINE EQUAL ABOVE GREATER THAN}" RELATION "LESS_THAN_ABOVE_DOUBLE_LINE_EQUAL_ABOVE_GREATER_THAN")
   (?\u2A8C "\\FortressUnknownCharacter{GREATER THAN ABOVE DOUBLE LINE EQUAL ABOVE LESS THAN}" RELATION "GREATER_THAN_ABOVE_DOUBLE_LINE_EQUAL_ABOVE_LESS_THAN")
   (?\u2A8F "\\FortressUnknownCharacter{LESS THAN ABOVE SIMILAR ABOVE GREATER THAN}" RELATION "LESS_THAN_ABOVE_SIMILAR_ABOVE_GREATER_THAN")
   (?\u2A90 "\\FortressUnknownCharacter{GREATER THAN ABOVE SIMILAR ABOVE LESS THAN}" RELATION "GREATER_THAN_ABOVE_SIMILAR_ABOVE_LESS_THAN")
   (?\u2A91 "\\FortressUnknownCharacter{LESS THAN ABOVE GREATER THAN ABOVE DOUBLE LINE EQUAL}" RELATION "LESS_THAN_ABOVE_GREATER_THAN_ABOVE_DOUBLE_LINE_EQUAL")
   (?\u2A92 "\\FortressUnknownCharacter{GREATER THAN ABOVE LESS THAN ABOVE DOUBLE LINE EQUAL}" RELATION "GREATER_THAN_ABOVE_LESS_THAN_ABOVE_DOUBLE_LINE_EQUAL")
   (?\u2A93 "\\FortressUnknownCharacter{LESS THAN ABOVE SLANTED EQUAL ABOVE GREATER THAN ABOVE SLANTED EQUAL}" RELATION "LESS_THAN_ABOVE_SLANTED_EQUAL_ABOVE_GREATER_THAN_ABOVE_SLANTED_EQUAL")
   (?\u2A94 "\\FortressUnknownCharacter{GREATER THAN ABOVE SLANTED EQUAL ABOVE LESS THAN ABOVE SLANTED EQUAL}" RELATION "GREATER_THAN_ABOVE_SLANTED_EQUAL_ABOVE_LESS_THAN_ABOVE_SLANTED_EQUAL")
   (?\u2AA4 "\\FortressUnknownCharacter{GREATER THAN OVERLAPPING LESS THAN}" RELATION "GREATER_THAN_OVERLAPPING_LESS_THAN")
   (?\u2AA5 "\\FortressUnknownCharacter{GREATER THAN BESIDE LESS THAN}" RELATION "GREATER_THAN_BESIDE_LESS_THAN")
   (?\u0023 "\\mathbin{\\#}" OPERATOR "NUMBER_SIGN")
   (?\u003A ":" OPERATOR "COLON")
   (?\u2237 "\\FortressUnknownCharacter{!PROPORTION}" RELATION "PROPORTION")
   (?\u2282 "\\subset" RELATION "SUBSET_OF" "SUBSET")
   (?\u2286 "\\subseteq" RELATION "SUBSET_OF_OR_EQUAL_TO" "SUBSETEQ")
   (?\u228A "\\subsetneq" RELATION "SUBSET_OF_WITH_NOT_EQUAL_TO" "SUBSETNEQ")
   (?\u22D0 "\\Subset" RELATION "DOUBLE_SUBSET" "SUBSUB")
   (?\u27C3 "\\FortressUnknownCharacter{OPEN SUBSET}" RELATION "OPEN_SUBSET")
   (?\u2ABD "\\FortressUnknownCharacter{SUBSET WITH DOT}" RELATION "SUBSET_WITH_DOT")
   (?\u2ABF "\\FortressUnknownCharacter{SUBSET WITH PLUS SIGN BELOW}" RELATION "SUBSET_WITH_PLUS_SIGN_BELOW")
   (?\u2AC1 "\\FortressUnknownCharacter{SUBSET WITH MULTIPLICATION SIGN BELOW}" RELATION "SUBSET_WITH_MULTIPLICATION_SIGN_BELOW")
   (?\u2AC3 "\\FortressUnknownCharacter{SUBSET OF OR EQUAL TO WITH DOT ABOVE}" RELATION "SUBSET_OF_OR_EQUAL_TO_WITH_DOT_ABOVE")
   (?\u2AC5 "\\FortressUnknownCharacter{SUBSET OF ABOVE EQUALS SIGN}" RELATION "SUBSET_OF_ABOVE_EQUALS_SIGN")
   (?\u2AC7 "\\FortressUnknownCharacter{SUBSET OF ABOVE TILDE OPERATOR}" RELATION "SUBSET_OF_ABOVE_TILDE_OPERATOR")
   (?\u2AC9 "\\FortressUnknownCharacter{SUBSET OF ABOVE ALMOST EQUAL TO}" RELATION "SUBSET_OF_ABOVE_ALMOST_EQUAL_TO")
   (?\u2ACB "\\FortressUnknownCharacter{SUBSET OF ABOVE NOT EQUAL TO}" RELATION "SUBSET_OF_ABOVE_NOT_EQUAL_TO")
   (?\u2ACF "\\FortressUnknownCharacter{CLOSED SUBSET}" RELATION "CLOSED_SUBSET")
   (?\u2AD1 "\\FortressUnknownCharacter{CLOSED SUBSET OR EQUAL TO}" RELATION "CLOSED_SUBSET_OR_EQUAL_TO")
   (?\u2AD5 "\\FortressUnknownCharacter{SUBSET ABOVE SUBSET}" RELATION "SUBSET_ABOVE_SUBSET")
   (?\u2283 "\\supset" RELATION "SUPERSET_OF" "SUPSET")
   (?\u2287 "\\supseteq" RELATION "SUPERSET_OF_OR_EQUAL_TO" "SUPSETEQ")
   (?\u228B "\\supsetneq" RELATION "SUPERSET_OF_WITH_NOT_EQUAL_TO" "SUPSETNEQ")
   (?\u22D1 "\\Supset" RELATION "DOUBLE_SUPERSET" "SUPSUP")
   (?\u27C4 "\\FortressUnknownCharacter{OPEN SUPERSET}" RELATION "OPEN_SUPERSET")
   (?\u2ABE "\\FortressUnknownCharacter{SUPERSET WITH DOT}" RELATION "SUPERSET_WITH_DOT")
   (?\u2AC0 "\\FortressUnknownCharacter{SUPERSET WITH PLUS SIGN BELOW}" RELATION "SUPERSET_WITH_PLUS_SIGN_BELOW")
   (?\u2AC2 "\\FortressUnknownCharacter{SUPERSET WITH MULTIPLICATION SIGN BELOW}" RELATION "SUPERSET_WITH_MULTIPLICATION_SIGN_BELOW")
   (?\u2AC4 "\\FortressUnknownCharacter{SUPERSET OF OR EQUAL TO WITH DOT ABOVE}" RELATION "SUPERSET_OF_OR_EQUAL_TO_WITH_DOT_ABOVE")
   (?\u2AC6 "\\FortressUnknownCharacter{SUPERSET OF ABOVE EQUALS SIGN}" RELATION "SUPERSET_OF_ABOVE_EQUALS_SIGN")
   (?\u2AC8 "\\FortressUnknownCharacter{SUPERSET OF ABOVE TILDE OPERATOR}" RELATION "SUPERSET_OF_ABOVE_TILDE_OPERATOR")
   (?\u2ACA "\\FortressUnknownCharacter{SUPERSET OF ABOVE ALMOST EQUAL TO}" RELATION "SUPERSET_OF_ABOVE_ALMOST_EQUAL_TO")
   (?\u2ACC "\\FortressUnknownCharacter{SUPERSET OF ABOVE NOT EQUAL TO}" RELATION "SUPERSET_OF_ABOVE_NOT_EQUAL_TO")
   (?\u2AD0 "\\FortressUnknownCharacter{CLOSED SUPERSET}" RELATION "CLOSED_SUPERSET")
   (?\u2AD2 "\\FortressUnknownCharacter{CLOSED SUPERSET OR EQUAL TO}" RELATION "CLOSED_SUPERSET_OR_EQUAL_TO")
   (?\u2AD6 "\\FortressUnknownCharacter{SUPERSET ABOVE SUPERSET}" RELATION "SUPERSET_ABOVE_SUPERSET")
   (?\u2284 "\\not\\subset" RELATION "NOT_A_SUBSET_OF" "NSUBSET")
   (?\u2285 "\\not\\supset" RELATION "NOT_A_SUPERSET_OF" "NSUPSET")
   (?\u2288 "\\nsubseteq" RELATION "NEITHER_A_SUBSET_OF_NOR_EQUAL_TO" "NSUBSETEQ")
   (?\u2289 "\\nsupseteq" RELATION "NEITHER_A_SUPERSET_OF_NOR_EQUAL_TO" "NSUPSETEQ")
   (?\u2AD3 "\\FortressUnknownCharacter{SUBSET ABOVE SUPERSET}" RELATION "SUBSET_ABOVE_SUPERSET")
   (?\u2AD4 "\\FortressUnknownCharacter{SUPERSET ABOVE SUBSET}" RELATION "SUPERSET_ABOVE_SUBSET")
   (?\u2AD7 "\\FortressUnknownCharacter{SUPERSET BESIDE SUBSET}" RELATION "SUPERSET_BESIDE_SUBSET")
   (?\u2AD8 "\\FortressUnknownCharacter{SUPERSET BESIDE AND JOINED BY DASH WITH SUBSET}" RELATION "SUPERSET_BESIDE_AND_JOINED_BY_DASH_WITH_SUBSET")
   (?\u228F "\\sqsubset" RELATION "SQUARE_IMAGE_OF" "SQSUBSET")
   (?\u2291 "\\sqsubseteq" RELATION "SQUARE_IMAGE_OF_OR_EQUAL_TO" "SQSUBSETEQ")
   (?\u22E4 "\\FortressUnknownCharacter{SQUARE IMAGE OF OR NOT EQUAL TO}" RELATION "SQUARE_IMAGE_OF_OR_NOT_EQUAL_TO")
   (?\u2290 "\\sqsupset" RELATION "SQUARE_ORIGINAL_OF" "SQSUPSET")
   (?\u2292 "\\sqsupseteq" RELATION "SQUARE_ORIGINAL_OF_OR_EQUAL_TO" "SQSUPSETEQ")
   (?\u22E5 "\\FortressUnknownCharacter{SQUARE ORIGINAL OF OR NOT EQUAL TO}" RELATION "SQUARE_ORIGINAL_OF_OR_NOT_EQUAL_TO")
   (none    "\\not\\sqsubset" RELATION "NOT_SQUARE_IMAGE_OF" "NSQSUBSET")
   (?\u22E2 "\\not\\sqsubseteq" RELATION "NOT_SQUARE_IMAGE_OF_OR_EQUAL_TO" "NSQSUBSETEQ")
   (none    "\\not\\sqsupset" RELATION "NOT_SQUARE_ORIGINAL_OF" "NSQSUPSET")
   (?\u22E3 "\\not\\sqsupseteq" RELATION "NOT_SQUARE_ORIGINAL_OF_OR_EQUAL_TO" "NSQSUPSETEQ")
   (?\u227A "\\prec" RELATION "PRECEDES" "PREC")
   (?\u227C "\\preccurlyeq" RELATION "PRECEDES_OR_EQUAL_TO" "PRECEQ")
   (?\u227E "\\precsim" RELATION "PRECEDES_OR_EQUIVALENT_TO" "PRECSIM")
   (?\u22B0 "\\FortressUnknownCharacter{PRECEDES UNDER RELATION}" RELATION "PRECEDES_UNDER_RELATION")
   (?\u22DE "\\curlyeqprec" RELATION "EQUAL_TO_OR_PRECEDES" "EQPREC")
   (?\u22E8 "\\precnsim" RELATION "PRECEDES_BUT_NOT_EQUIVALENT_TO" "PRECNSIM")
   (?\u2AAF "\\FortressUnknownCharacter{PRECEDES ABOVE SINGLE LINE EQUALS SIGN}" RELATION "PRECEDES_ABOVE_SINGLE_LINE_EQUALS_SIGN")
   (?\u2AB1 "\\FortressUnknownCharacter{PRECEDES ABOVE SINGLE LINE NOT EQUAL TO}" RELATION "PRECEDES_ABOVE_SINGLE_LINE_NOT_EQUAL_TO")
   (?\u2AB3 "\\FortressUnknownCharacter{PRECEDES ABOVE EQUALS SIGN}" RELATION "PRECEDES_ABOVE_EQUALS_SIGN")
   (?\u2AB5 "\\FortressUnknownCharacter{PRECEDES ABOVE NOT EQUAL TO}" RELATION "PRECEDES_ABOVE_NOT_EQUAL_TO")
   (?\u2AB7 "\\FortressUnknownCharacter{PRECEDES ABOVE ALMOST EQUAL TO}" RELATION "PRECEDES_ABOVE_ALMOST_EQUAL_TO")
   (?\u2AB9 "\\FortressUnknownCharacter{PRECEDES ABOVE NOT ALMOST EQUAL TO}" RELATION "PRECEDES_ABOVE_NOT_ALMOST_EQUAL_TO")
   (?\u2ABB "\\FortressUnknownCharacter{DOUBLE PRECEDES}" RELATION "DOUBLE_PRECEDES")
   (?\u227B "\\succ" RELATION "SUCCEEDS" "SUCC")
   (?\u227D "\\succcurlyeq" RELATION "SUCCEEDS_OR_EQUAL_TO" "SUCCEQ")
   (?\u227F "\\succsim" RELATION "SUCCEEDS_OR_EQUIVALENT_TO" "SUCCSIM")
   (?\u22B1 "\\FortressUnknownCharacter{SUCCEEDS UNDER RELATION}" RELATION "SUCCEEDS_UNDER_RELATION")
   (?\u22DF "\\curlyeqsucc" RELATION "EQUAL_TO_OR_SUCCEEDS" "EQSUCC")
   (?\u22E9 "\\succnsim" RELATION "SUCCEEDS_BUT_NOT_EQUIVALENT_TO" "SUCCNSIM")
   (?\u2AB0 "\\FortressUnknownCharacter{SUCCEEDS ABOVE SINGLE LINE EQUALS SIGN}" RELATION "SUCCEEDS_ABOVE_SINGLE_LINE_EQUALS_SIGN")
   (?\u2AB2 "\\FortressUnknownCharacter{SUCCEEDS ABOVE SINGLE LINE NOT EQUAL TO}" RELATION "SUCCEEDS_ABOVE_SINGLE_LINE_NOT_EQUAL_TO")
   (?\u2AB4 "\\FortressUnknownCharacter{SUCCEEDS ABOVE EQUALS SIGN}" RELATION "SUCCEEDS_ABOVE_EQUALS_SIGN")
   (?\u2AB6 "\\FortressUnknownCharacter{SUCCEEDS ABOVE NOT EQUAL TO}" RELATION "SUCCEEDS_ABOVE_NOT_EQUAL_TO")
   (?\u2AB8 "\\FortressUnknownCharacter{SUCCEEDS ABOVE ALMOST EQUAL TO}" RELATION "SUCCEEDS_ABOVE_ALMOST_EQUAL_TO")
   (?\u2ABA "\\FortressUnknownCharacter{SUCCEEDS ABOVE NOT ALMOST EQUAL TO}" RELATION "SUCCEEDS_ABOVE_NOT_ALMOST_EQUAL_TO")
   (?\u2ABC "\\FortressUnknownCharacter{DOUBLE SUCCEEDS}" RELATION "DOUBLE_SUCCEEDS")
   (?\u2280 "\\nprec" RELATION "DOES_NOT_PRECEDE" "NPREC")
   (?\u2281 "\\nsucc" RELATION "DOES_NOT_SUCCEED" "NSUCC")
   (?\u22E0 "\\not\\preccurlyeq" RELATION "DOES_NOT_PRECEDE_OR_EQUAL" "NPRECEQ")
   (?\u22E1 "\\not\\succcurlyeq" RELATION "DOES_NOT_SUCCEED_OR_EQUAL" "NSUCCEQ")
   (?\u22B2 "\\lhd" RELATION "NORMAL_SUBGROUP_OF")
   (?\u22B4 "\\unlhd" RELATION "NORMAL_SUBGROUP_OF_OR_EQUAL_TO")
   (?\u22B3 "\\rhd" RELATION "CONTAINS_AS_NORMAL_SUBGROUP")
   (?\u22B5 "\\unrhd" RELATION "CONTAINS_AS_NORMAL_SUBGROUP_OR_EQUAL_TO")
   (?\u22EA "\\ntriangleleft" RELATION "NOT_NORMAL_SUBGROUP_OF")
   (?\u22EB "\\ntriangleright" RELATION "DOES_NOT_CONTAIN_AS_NORMAL_SUBGROUP")
   (?\u22EC "\\ntrianglelefteq" RELATION "NOT_NORMAL_SUBGROUP_OF_OR_EQUAL_TO")
   (?\u22ED "\\ntrianglerighteq" RELATION "DOES_NOT_CONTAIN_AS_NORMAL_SUBGROUP_OR_EQUAL")
   (?\u2AAA "{<\\!\\llap{$-$}}" RELATION "SMALLER_THAN" "SMALLER")
   (?\u2AAC "{\\leq\\!\\llap{\\raisebox{.15ex}[0cm][0cm]{$-$}}}" RELATION "SMALLER_THAN_OR_EQUAL_TO" "SMALLEREQ")
   (?\u2AAB "{\\rlap{$-$}\\!>}" RELATION "LARGER_THAN" "LARGER")
   (?\u2AAD "{\\rlap{\\raisebox{.15ex}[0cm][0cm]{$-$}}\\!\\geq}" RELATION "LARGER_THAN_OR_EQUAL_TO" "LARGEREQ")
   (?\u2208 "\\in" RELATION "ELEMENT_OF" "IN")
   (?\u2209 "\\notin" RELATION "NOT_AN_ELEMENT_OF" "NOTIN")
   (?\u220A "\\hbox{\\footnotesize$\\in$}" RELATION "SMALL_ELEMENT_OF")
   (?\u220B "\\ni" RELATION "CONTAINS_AS_MEMBER" "CONTAINS")
   (?\u220C "\\not\\ni" RELATION "DOES_NOT_CONTAIN_AS_MEMBER" "NCONTAINS" "NOTNI")
   (?\u220D "\\hbox{\\footnotesize$\\ni$}" RELATION "SMALL_CONTAINS_AS_MEMBER")
   (?\u22F2 "\\FortressUnknownCharacter{ELEMENT OF WITH LONG HORIZONTAL STROKE}" RELATION "ELEMENT_OF_WITH_LONG_HORIZONTAL_STROKE")
   (?\u22F3 "\\FortressUnknownCharacter{ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE}" RELATION "ELEMENT_OF_WITH_VERTICAL_BAR_AT_END_OF_HORIZONTAL_STROKE")
   (?\u22F4 "\\FortressUnknownCharacter{SMALL ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE}" RELATION "SMALL_ELEMENT_OF_WITH_VERTICAL_BAR_AT_END_OF_HORIZONTAL_STROKE")
   (?\u22F5 "\\dot{\\in}" RELATION "ELEMENT_OF_WITH_DOT_ABOVE")
   (?\u22F6 "\\overline{\\in}" RELATION "ELEMENT_OF_WITH_OVERBAR")
   (?\u22F7 "\\hbox{\\footnotesize$\\overline{\\in}$}" RELATION "SMALL_ELEMENT_OF_WITH_OVERBAR")
   (?\u22F8 "\\underline{\\in}" RELATION "ELEMENT_OF_WITH_UNDERBAR")
   (?\u22F9 "\\FortressUnknownCharacter{ELEMENT OF WITH TWO HORIZONTAL STROKES}" RELATION "ELEMENT_OF_WITH_TWO_HORIZONTAL_STROKES")
   (?\u22FA "\\FortressUnknownCharacter{CONTAINS WITH LONG HORIZONTAL STROKE}" RELATION "CONTAINS_WITH_LONG_HORIZONTAL_STROKE")
   (?\u22FB "\\FortressUnknownCharacter{CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE}" RELATION "CONTAINS_WITH_VERTICAL_BAR_AT_END_OF_HORIZONTAL_STROKE")
   (?\u22FC "\\FortressUnknownCharacter{SMALL CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE}" RELATION "SMALL_CONTAINS_WITH_VERTICAL_BAR_AT_END_OF_HORIZONTAL_STROKE")
   (?\u22FD "\\overline{\\ni}" RELATION "CONTAINS_WITH_OVERBAR")
   (?\u22FE "\\hbox{\\footnotesize$\\overline{\\ni}$}" RELATION "SMALL_CONTAINS_WITH_OVERBAR")
   (?\u22FF "\\FortressUnknownCharacter{Z NOTATION BAG MEMBERSHIP}" RELATION "Z_NOTATION_BAG_MEMBERSHIP")
   (?\u22CF "\\mathbin{\\curlywedge}" OPERATOR "CURLY_LOGICAL_AND" "CURLYAND")
   (?\u22CE "\\mathbin{\\curlyvee}" OPERATOR "CURLY_LOGICAL_OR" "CURLYOR")
   (?\u2227 "\\wedge" OPERATOR "LOGICAL_AND" "AND")
   (?\u27D1 "\\FortressUnknownCharacter{AND WITH DOT}" OPERATOR "AND_WITH_DOT")
   (?\u2A51 "\\dot{\\wedge}" OPERATOR "LOGICAL_AND_WITH_DOT_ABOVE")
   (?\u2A53 "\\FortressUnknownCharacter{DOUBLE LOGICAL AND}" OPERATOR "DOUBLE_LOGICAL_AND")
   (?\u2A55 "\\twointersectand" OPERATOR "TWO_INTERSECTING_LOGICAL_AND" "BITAND")
   (?\u2A5A "\\FortressUnknownCharacter{LOGICAL AND WITH MIDDLE STEM}" OPERATOR "LOGICAL_AND_WITH_MIDDLE_STEM")
   (?\u2A5C "\\FortressUnknownCharacter{LOGICAL AND WITH HORIZONTAL DASH}" OPERATOR "LOGICAL_AND_WITH_HORIZONTAL_DASH")
   (?\u2A5E "\\FortressUnknownCharacter{LOGICAL AND WITH DOUBLE OVERBAR}" OPERATOR "LOGICAL_AND_WITH_DOUBLE_OVERBAR")
   (?\u2A60 "\\FortressUnknownCharacter{LOGICAL AND WITH DOUBLE UNDERBAR}" OPERATOR "LOGICAL_AND_WITH_DOUBLE_UNDERBAR")
   (?\u2228 "\\vee" OPERATOR "LOGICAL_OR" "OR")
   (?\u2A52 "\\dot{\\vee}" OPERATOR "LOGICAL_OR_WITH_DOT_ABOVE")
   (?\u2A54 "\\FortressUnknownCharacter{DOUBLE LOGICAL OR}" OPERATOR "DOUBLE_LOGICAL_OR")
   (?\u2A56 "\\twointersector" OPERATOR "TWO_INTERSECTING_LOGICAL_OR" "BITOR")
   (none "\\twointersectxor" OPERATOR "TWO_INTERSECTING_LOGICAL_XOR" "BITXOR")
   (none "\\twointersectnot" OPERATOR "TWO_INTERSECTING_LOGICAL_NOT" "BITNOT")
   (?\u2A5B "\\FortressUnknownCharacter{LOGICAL OR WITH MIDDLE STEM}" OPERATOR "LOGICAL_OR_WITH_MIDDLE_STEM")
   (?\u2A5D "\\FortressUnknownCharacter{LOGICAL OR WITH HORIZONTAL DASH}" OPERATOR "LOGICAL_OR_WITH_HORIZONTAL_DASH")
   (?\u2A62 "\\FortressUnknownCharacter{LOGICAL OR WITH DOUBLE OVERBAR}" OPERATOR "LOGICAL_OR_WITH_DOUBLE_OVERBAR")
   (?\u2A63 "\\FortressUnknownCharacter{LOGICAL OR WITH DOUBLE UNDERBAR}" OPERATOR "LOGICAL_OR_WITH_DOUBLE_UNDERBAR")
   (?\u2192 "\\rightarrow" OPERATOR "RIGHTWARDS_ARROW" "IMPLIES")
   (?\u2194 "\\leftrightarrow" OPERATOR "LEFT_RIGHT_ARROW" "IFF")
   (?\u22BC "\\nand" OPERATOR "NAND")
   (?\u22BD "\\nor" OPERATOR "NOR")
   (?\u22BB "\\xor" OPERATOR "XOR")
   (?\u005E "\\texttt{{\\char'136}}" OPERATOR "CIRCUMFLEX_ACCENT")
   (?\u0021 "!" OPERATOR "EXCLAMATION_MARK")
   (?\u0024 "\\$" OPERATOR "DOLLAR_SIGN")
   (?\u0025 "\\%" OPERATOR "PERCENT_SIGN")
   (?\u003F "?" OPERATOR "QUESTION_MARK")
   (?\u0040 "@" OPERATOR "COMMERCIAL_AT")
   (?\u005C "\\hbox{\\char'134}" OPERATOR "BACKSLASH")
   (?\u007E "\\hbox{\\char'176}" OPERATOR "TILDE")
   (?\u00A1 "\\hbox{\\char'74}" OPERATOR "INVERTED_EXCLAMATION_MARK")
   (?\u00A2 "\\FortressUnknownCharacter{CENT SIGN}" OPERATOR "CENT_SIGN" "CENTS")
   (?\u00A3 "\\FortressUnknownCharacter{POUND SIGN}" OPERATOR "POUND_SIGN")
   (?\u00A4 "\\FortressUnknownCharacter{CURRENCY SIGN}" OPERATOR "CURRENCY_SIGN")
   (?\u00A5 "\\FortressUnknownCharacter{YEN SIGN}" OPERATOR "YEN_SIGN")
   (?\u00A6 "\\FortressUnknownCharacter{BROKEN BAR}" OPERATOR "BROKEN_BAR")
   (?\u00AC "\\neg" OPERATOR "NOT_SIGN" "NOT")
   (?\u00B0 "{{}^\\circ}" OPERATOR "DEGREE_SIGN" "DEGREES")
   (?\u00BF "\\hbox{\\char'76}" OPERATOR "INVERTED_QUESTION_MARK")
   (?\u203C "!!" OPERATOR "DOUBLE_EXCLAMATION_MARK")
   (?\u2190 "\\leftarrow" OPERATOR "LEFTWARDS_ARROW")
   (?\u2191 "\\uparrow" OPERATOR "UPWARDS_ARROW" "UPARROW")
   (?\u2193 "\\downarrow" OPERATOR "DOWNWARDS_ARROW" "DOWNARROW")
   (?\u2195 "\\updownarrow" OPERATOR "UP_DOWN_ARROW" "UPDOWNARROW")
   (?\u2196 "\\nwarrow" OPERATOR "NORTH_WEST_ARROW" "NWARROW")
   (?\u2197 "\\nearrow" OPERATOR "NORTH_EAST_ARROW" "NEARROW")
   (?\u2198 "\\searrow" OPERATOR "SOUTH_EAST_ARROW" "SEARROW")
   (?\u2199 "\\swarrow" OPERATOR "SOUTH_WEST_ARROW" "SWARROW")
   (?\u219A "\\nleftarrow" OPERATOR "LEFTWARDS_ARROW_WITH_STROKE")
   (?\u219B "\\nrightarrow" OPERATOR "RIGHTWARDS_ARROW_WITH_STROKE")
   (?\u219C "\\FortressUnknownCharacter{LEFTWARDS WAVE ARROW}" OPERATOR "LEFTWARDS_WAVE_ARROW")
   (?\u219D "\\leadsto" OPERATOR "RIGHTWARDS_WAVE_ARROW" "LEADSTO")
   (?\u219E "\\FortressUnknownCharacter{LEFTWARDS TWO HEADED ARROW}" OPERATOR "LEFTWARDS_TWO_HEADED_ARROW")
   (?\u219F "\\FortressUnknownCharacter{UPWARDS TWO HEADED ARROW}" OPERATOR "UPWARDS_TWO_HEADED_ARROW")
   (?\u21A0 "\\FortressUnknownCharacter{RIGHTWARDS TWO HEADED ARROW}" OPERATOR "RIGHTWARDS_TWO_HEADED_ARROW")
   (?\u21A1 "\\FortressUnknownCharacter{DOWNWARDS TWO HEADED ARROW}" OPERATOR "DOWNWARDS_TWO_HEADED_ARROW")
   (?\u21A2 "\\FortressUnknownCharacter{LEFTWARDS ARROW WITH TAIL}" OPERATOR "LEFTWARDS_ARROW_WITH_TAIL")
   (?\u21A3 "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH TAIL}" OPERATOR "RIGHTWARDS_ARROW_WITH_TAIL")
   (?\u21A4 "\\FortressUnknownCharacter{LEFTWARDS ARROW FROM BAR}" OPERATOR "LEFTWARDS_ARROW_FROM_BAR")
   (?\u21A5 "\\FortressUnknownCharacter{UPWARDS ARROW FROM BAR}" OPERATOR "UPWARDS_ARROW_FROM_BAR")
   (?\u21A6 "\\mapsto" OPERATOR "RIGHTWARDS_ARROW_FROM_BAR" "MAPSTO")
   (?\u21A7 "\\FortressUnknownCharacter{DOWNWARDS ARROW FROM BAR}" OPERATOR "DOWNWARDS_ARROW_FROM_BAR")
   (?\u21A8 "\\FortressUnknownCharacter{UP DOWN ARROW WITH BASE}" OPERATOR "UP_DOWN_ARROW_WITH_BASE")
   (?\u21A9 "\\FortressUnknownCharacter{LEFTWARDS ARROW WITH HOOK}" OPERATOR "LEFTWARDS_ARROW_WITH_HOOK")
   (?\u21AA "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH HOOK}" OPERATOR "RIGHTWARDS_ARROW_WITH_HOOK")
   (?\u21AB "\\FortressUnknownCharacter{LEFTWARDS ARROW WITH LOOP}" OPERATOR "LEFTWARDS_ARROW_WITH_LOOP")
   (?\u21AC "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH LOOP}" OPERATOR "RIGHTWARDS_ARROW_WITH_LOOP")
   (?\u21AD "\\FortressUnknownCharacter{LEFT RIGHT WAVE ARROW}" OPERATOR "LEFT_RIGHT_WAVE_ARROW")
   (?\u21AE "\\FortressUnknownCharacter{LEFT RIGHT ARROW WITH STROKE}" OPERATOR "LEFT_RIGHT_ARROW_WITH_STROKE")
   (?\u21AF "\\FortressUnknownCharacter{DOWNWARDS ZIGZAG ARROW}" OPERATOR "DOWNWARDS_ZIGZAG_ARROW")
   (?\u21B0 "\\FortressUnknownCharacter{UPWARDS ARROW WITH TIP LEFTWARDS}" OPERATOR "UPWARDS_ARROW_WITH_TIP_LEFTWARDS")
   (?\u21B1 "\\FortressUnknownCharacter{UPWARDS ARROW WITH TIP RIGHTWARDS}" OPERATOR "UPWARDS_ARROW_WITH_TIP_RIGHTWARDS")
   (?\u21B2 "\\FortressUnknownCharacter{DOWNWARDS ARROW WITH TIP LEFTWARDS}" OPERATOR "DOWNWARDS_ARROW_WITH_TIP_LEFTWARDS")
   (?\u21B3 "\\FortressUnknownCharacter{DOWNWARDS ARROW WITH TIP RIGHTWARDS}" OPERATOR "DOWNWARDS_ARROW_WITH_TIP_RIGHTWARDS")
   (?\u21B4 "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH CORNER DOWNWARDS}" OPERATOR "RIGHTWARDS_ARROW_WITH_CORNER_DOWNWARDS")
   (?\u21B5 "\\FortressUnknownCharacter{DOWNWARDS ARROW WITH CORNER LEFTWARDS}" OPERATOR "DOWNWARDS_ARROW_WITH_CORNER_LEFTWARDS")
   (?\u21B6 "\\FortressUnknownCharacter{ANTICLOCKWISE TOP SEMICIRCLE ARROW}" OPERATOR "ANTICLOCKWISE_TOP_SEMICIRCLE_ARROW")
   (?\u21B7 "\\FortressUnknownCharacter{CLOCKWISE TOP SEMICIRCLE ARROW}" OPERATOR "CLOCKWISE_TOP_SEMICIRCLE_ARROW")
   (?\u21B8 "\\FortressUnknownCharacter{NORTH WEST ARROW TO LONG BAR}" OPERATOR "NORTH_WEST_ARROW_TO_LONG_BAR")
   (?\u21B9 "\\FortressUnknownCharacter{LEFTWARDS ARROW TO BAR OVER RIGHTWARDS ARROW TO BAR}" OPERATOR "LEFTWARDS_ARROW_TO_BAR_OVER_RIGHTWARDS_ARROW_TO_BAR")
   (?\u21BA "\\FortressUnknownCharacter{ANTICLOCKWISE OPEN CIRCLE ARROW}" OPERATOR "ANTICLOCKWISE_OPEN_CIRCLE_ARROW")
   (?\u21BB "\\FortressUnknownCharacter{CLOCKWISE OPEN CIRCLE ARROW}" OPERATOR "CLOCKWISE_OPEN_CIRCLE_ARROW")
   (?\u21BC "\\leftharpoonup" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_UPWARDS" "LEFTHARPOONUP")
   (?\u21BD "\\leftharpoondown" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_DOWNWARDS" "LEFTHARPOONDOWN")
   (?\u21BE "\\upharpoonright" OPERATOR "UPWARDS_HARPOON_WITH_BARB_RIGHTWARDS" "UPHARPOONRIGHT")
   (?\u21BF "\\upharpoonleft" OPERATOR "UPWARDS_HARPOON_WITH_BARB_LEFTWARDS" "UPHARPOONLEFT")
   (?\u21C0 "\\rightharpoonup" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_UPWARDS" "RIGHTHARPOONUP")
   (?\u21C1 "\\rightharpoondown" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_DOWNWARDS" "RIGHTHARPOONDOWN")
   (?\u21C2 "\\downharpoonright" OPERATOR "DOWNWARDS_HARPOON_WITH_BARB_RIGHTWARDS" "DOWNHARPOONRIGHT")
   (?\u21C3 "\\downharpoonleft" OPERATOR "DOWNWARDS_HARPOON_WITH_BARB_LEFTWARDS" "DOWNHARPOONLEFT")
   (?\u21C4 "\\rightleftarrows" OPERATOR "RIGHTWARDS_ARROW_OVER_LEFTWARDS_ARROW" "RIGHTLEFTARROWS")
   (?\u21C5 "\\FortressUnknownCharacter{UPWARDS ARROW LEFTWARDS OF DOWNWARDS ARROW}" OPERATOR "UPWARDS_ARROW_LEFTWARDS_OF_DOWNWARDS_ARROW")
   (?\u21C6 "\\leftrightarrows" OPERATOR "LEFTWARDS_ARROW_OVER_RIGHTWARDS_ARROW" "LEFTRIGHTARROWS")
   (?\u21C7 "\\leftleftarrows" OPERATOR "LEFTWARDS_PAIRED_ARROWS" "LEFTLEFTARROWS")
   (?\u21C8 "\\upuparrows" OPERATOR "UPWARDS_PAIRED_ARROWS" "UPUPARROWS")
   (?\u21C9 "\\rightrightarrows" OPERATOR "RIGHTWARDS_PAIRED_ARROWS" "RIGHTRIGHTARROWS")
   (?\u21CA "\\downdownarrows" OPERATOR "DOWNWARDS_PAIRED_ARROWS" "DOWNDOWNARROWS")
   (?\u21CB "\\FortressUnknownCharacter{LEFTWARDS HARPOON OVER RIGHTWARDS HARPOON}" OPERATOR "LEFTWARDS_HARPOON_OVER_RIGHTWARDS_HARPOON")
   (?\u21CC "\\rightleftharpoons" OPERATOR "RIGHTWARDS_HARPOON_OVER_LEFTWARDS_HARPOON" "RIGHTLEFTHARPOONS")
   (?\u21CD "\\nLeftarrow" OPERATOR "LEFTWARDS_DOUBLE_ARROW_WITH_STROKE")
   (?\u21CE "\\nLeftrightarrow" OPERATOR "LEFT_RIGHT_DOUBLE_ARROW_WITH_STROKE")
   (?\u21CF "\\nRightarrow" OPERATOR "RIGHTWARDS_DOUBLE_ARROW_WITH_STROKE")
   (?\u21D0 "\\Leftarrow" OPERATOR "LEFTWARDS_DOUBLE_ARROW")
   (?\u21D1 "\\Uparrow" OPERATOR "UPWARDS_DOUBLE_ARROW")
   (?\u21D2 "\\Rightarrow" OPERATOR "RIGHTWARDS_DOUBLE_ARROW")
   (?\u21D3 "\\Downarrow" OPERATOR "DOWNWARDS_DOUBLE_ARROW")
   (?\u21D4 "\\Leftrightarrow" OPERATOR "LEFT_RIGHT_DOUBLE_ARROW")
   (?\u21D5 "\\Updownarrow" OPERATOR "UP_DOWN_DOUBLE_ARROW")
   (?\u21D6 "\\FortressUnknownCharacter{NORTH WEST DOUBLE ARROW}" OPERATOR "NORTH_WEST_DOUBLE_ARROW")
   (?\u21D7 "\\FortressUnknownCharacter{NORTH EAST DOUBLE ARROW}" OPERATOR "NORTH_EAST_DOUBLE_ARROW")
   (?\u21D8 "\\FortressUnknownCharacter{SOUTH EAST DOUBLE ARROW}" OPERATOR "SOUTH_EAST_DOUBLE_ARROW")
   (?\u21D9 "\\FortressUnknownCharacter{SOUTH WEST DOUBLE ARROW}" OPERATOR "SOUTH_WEST_DOUBLE_ARROW")
   (?\u21DA "\\Lleftarrow" OPERATOR "LEFTWARDS_TRIPLE_ARROW")
   (?\u21DB "\\Rrightarrow" OPERATOR "RIGHTWARDS_TRIPLE_ARROW")
   (?\u21DC "\\FortressUnknownCharacter{LEFTWARDS SQUIGGLE ARROW}" OPERATOR "LEFTWARDS_SQUIGGLE_ARROW")
   (?\u21DD "\\rightsquigarrow" OPERATOR "RIGHTWARDS_SQUIGGLE_ARROW")
   (?\u21DE "\\FortressUnknownCharacter{UPWARDS ARROW WITH DOUBLE STROKE}" OPERATOR "UPWARDS_ARROW_WITH_DOUBLE_STROKE")
   (?\u21DF "\\FortressUnknownCharacter{DOWNWARDS ARROW WITH DOUBLE STROKE}" OPERATOR "DOWNWARDS_ARROW_WITH_DOUBLE_STROKE")
   (?\u21E0 "\\dashleftarrow" OPERATOR "LEFTWARDS_DASHED_ARROW")
   (?\u21E1 "\\FortressUnknownCharacter{UPWARDS DASHED ARROW}" OPERATOR "UPWARDS_DASHED_ARROW")
   (?\u21E2 "\\dashrightarrow" OPERATOR "RIGHTWARDS_DASHED_ARROW")
   (?\u21E3 "\\FortressUnknownCharacter{DOWNWARDS DASHED ARROW}" OPERATOR "DOWNWARDS_DASHED_ARROW")
   (?\u21E4 "\\FortressUnknownCharacter{LEFTWARDS ARROW TO BAR}" OPERATOR "LEFTWARDS_ARROW_TO_BAR")
   (?\u21E5 "\\FortressUnknownCharacter{RIGHTWARDS ARROW TO BAR}" OPERATOR "RIGHTWARDS_ARROW_TO_BAR")
   (?\u21E6 "\\FortressUnknownCharacter{LEFTWARDS WHITE ARROW}" OPERATOR "LEFTWARDS_WHITE_ARROW")
   (?\u21E7 "\\FortressUnknownCharacter{UPWARDS WHITE ARROW}" OPERATOR "UPWARDS_WHITE_ARROW")
   (?\u21E8 "\\FortressUnknownCharacter{RIGHTWARDS WHITE ARROW}" OPERATOR "RIGHTWARDS_WHITE_ARROW")
   (?\u21E9 "\\FortressUnknownCharacter{DOWNWARDS WHITE ARROW}" OPERATOR "DOWNWARDS_WHITE_ARROW")
   (?\u21EA "\\FortressUnknownCharacter{UPWARDS WHITE ARROW FROM BAR}" OPERATOR "UPWARDS_WHITE_ARROW_FROM_BAR")
   (?\u21EB "\\FortressUnknownCharacter{UPWARDS WHITE ARROW ON PEDESTAL}" OPERATOR "UPWARDS_WHITE_ARROW_ON_PEDESTAL")
   (?\u21EC "\\FortressUnknownCharacter{UPWARDS WHITE ARROW ON PEDESTAL WITH HORIZONTAL BAR}" OPERATOR "UPWARDS_WHITE_ARROW_ON_PEDESTAL_WITH_HORIZONTAL_BAR")
   (?\u21ED "\\FortressUnknownCharacter{UPWARDS WHITE ARROW ON PEDESTAL WITH VERTICAL BAR}" OPERATOR "UPWARDS_WHITE_ARROW_ON_PEDESTAL_WITH_VERTICAL_BAR")
   (?\u21EE "\\FortressUnknownCharacter{UPWARDS WHITE DOUBLE ARROW}" OPERATOR "UPWARDS_WHITE_DOUBLE_ARROW")
   (?\u21EF "\\FortressUnknownCharacter{UPWARDS WHITE DOUBLE ARROW ON PEDESTAL}" OPERATOR "UPWARDS_WHITE_DOUBLE_ARROW_ON_PEDESTAL")
   (?\u21F0 "\\FortressUnknownCharacter{RIGHTWARDS WHITE ARROW FROM WALL}" OPERATOR "RIGHTWARDS_WHITE_ARROW_FROM_WALL")
   (?\u21F1 "\\FortressUnknownCharacter{NORTH WEST ARROW TO CORNER}" OPERATOR "NORTH_WEST_ARROW_TO_CORNER")
   (?\u21F2 "\\FortressUnknownCharacter{SOUTH EAST ARROW TO CORNER}" OPERATOR "SOUTH_EAST_ARROW_TO_CORNER")
   (?\u21F3 "\\FortressUnknownCharacter{UP DOWN WHITE ARROW}" OPERATOR "UP_DOWN_WHITE_ARROW")
   (?\u21F4 "\\FortressUnknownCharacter{RIGHT ARROW WITH SMALL CIRCLE}" OPERATOR "RIGHT_ARROW_WITH_SMALL_CIRCLE")
   (?\u21F5 "\\FortressUnknownCharacter{DOWNWARDS ARROW LEFTWARDS OF UPWARDS ARROW}" OPERATOR "DOWNWARDS_ARROW_LEFTWARDS_OF_UPWARDS_ARROW")
   (?\u21F6 "\\FortressUnknownCharacter{THREE RIGHTWARDS ARROWS}" OPERATOR "THREE_RIGHTWARDS_ARROWS")
   (?\u21F7 "\\FortressUnknownCharacter{LEFTWARDS ARROW WITH VERTICAL STROKE}" OPERATOR "LEFTWARDS_ARROW_WITH_VERTICAL_STROKE")
   (?\u21F8 "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH VERTICAL STROKE}" OPERATOR "RIGHTWARDS_ARROW_WITH_VERTICAL_STROKE")
   (?\u21F9 "\\FortressUnknownCharacter{LEFT RIGHT ARROW WITH VERTICAL STROKE}" OPERATOR "LEFT_RIGHT_ARROW_WITH_VERTICAL_STROKE")
   (?\u21FA "\\FortressUnknownCharacter{LEFTWARDS ARROW WITH DOUBLE VERTICAL STROKE}" OPERATOR "LEFTWARDS_ARROW_WITH_DOUBLE_VERTICAL_STROKE")
   (?\u21FB "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH DOUBLE VERTICAL STROKE}" OPERATOR "RIGHTWARDS_ARROW_WITH_DOUBLE_VERTICAL_STROKE")
   (?\u21FC "\\FortressUnknownCharacter{LEFT RIGHT ARROW WITH DOUBLE VERTICAL STROKE}" OPERATOR "LEFT_RIGHT_ARROW_WITH_DOUBLE_VERTICAL_STROKE")
   (?\u21FD "\\FortressUnknownCharacter{LEFTWARDS OPEN HEADED ARROW}" OPERATOR "LEFTWARDS_OPEN_HEADED_ARROW")
   (?\u21FE "\\FortressUnknownCharacter{RIGHTWARDS OPEN HEADED ARROW}" OPERATOR "RIGHTWARDS_OPEN_HEADED_ARROW")
   (?\u21FF "\\FortressUnknownCharacter{LEFT RIGHT OPEN HEADED ARROW}" OPERATOR "LEFT_RIGHT_OPEN_HEADED_ARROW")
   (?\u2200 "\\forall" OPERATOR "FOR_ALL" "FORALL")
   (?\u2201 "\\complement" OPERATOR "COMPLEMENT")
   (?\u2202 "\\partial" OPERATOR "PARTIAL_DIFFERENTIAL" "DEL")
   (?\u2203 "\\exists" OPERATOR "THERE_EXISTS" "EXISTS")
   (?\u2204 "\\not\\exists" OPERATOR "THERE_DOES_NOT_EXIST")
   (?\u2206 "\\Delta" OPERATOR "INCREMENT")
   (?\u220F "\\prod" BIGOP "N_ARY_PRODUCT" "PROD")
   (?\u2210 "\\coprod" BIGOP "N_ARY_COPRODUCT" "COPROD")
   (?\u2211 "\\sum" BIGOP "N_ARY_SUMMATION" "SUM")
   (?\u2218 "\\circ" OPERATOR "RING_OPERATOR" "CIRC" "RING" "COMPOSE")
   (?\u2219 "\\bullet" OPERATOR "BULLET_OPERATOR" "BULLET")
   (?\u221A "\\surd" OPERATOR "SQUARE_ROOT" "SQRT")
   (?\u221B "\\FortressUnknownCharacter{CUBE ROOT}" OPERATOR "CUBE_ROOT" "CBRT")
   (?\u221C "\\FortressUnknownCharacter{FOURTH ROOT}" OPERATOR "FOURTH_ROOT" "FOURTHROOT")
   (?\u221D "\\propto" OPERATOR "PROPORTIONAL_TO" "PROPTO")
   (?\u2223 "\\mid" OPERATOR "DIVIDES")
   (?\u2224 "\\nmid" OPERATOR "DOES_NOT_DIVIDE")
   (?\u2225 "\\parallel" OPERATOR "PARALLEL_TO" "PARALLEL")
   (?\u2226 "\\nparallel" OPERATOR "NOT_PARALLEL_TO" "NPARALLEL")
   (?\u222B "\\int" OPERATOR "INTEGRAL")
   (?\u222C "\\FortressUnknownCharacter{DOUBLE INTEGRAL}" OPERATOR "DOUBLE_INTEGRAL")
   (?\u222D "\\FortressUnknownCharacter{TRIPLE INTEGRAL}" OPERATOR "TRIPLE_INTEGRAL")
   (?\u222E "\\oint" OPERATOR "CONTOUR_INTEGRAL")
   (?\u222F "\\FortressUnknownCharacter{SURFACE INTEGRAL}" OPERATOR "SURFACE_INTEGRAL")
   (?\u2230 "\\FortressUnknownCharacter{VOLUME INTEGRAL}" OPERATOR "VOLUME_INTEGRAL")
   (?\u2231 "\\FortressUnknownCharacter{CLOCKWISE INTEGRAL}" OPERATOR "CLOCKWISE_INTEGRAL")
   (?\u2232 "\\FortressUnknownCharacter{CLOCKWISE CONTOUR INTEGRAL}" OPERATOR "CLOCKWISE_CONTOUR_INTEGRAL")
   (?\u2233 "\\FortressUnknownCharacter{ANTICLOCKWISE CONTOUR INTEGRAL}" OPERATOR "ANTICLOCKWISE_CONTOUR_INTEGRAL")
   (?\u2234 "\\therefore" OPERATOR "THEREFORE")
   (?\u2235 "\\because" OPERATOR "BECAUSE")
   (?\u2236 "\\FortressUnknownCharacter{!RATIO}" OPERATOR "RATIO")
   (?\u2239 "\\FortressUnknownCharacter{!EXCESS}" OPERATOR "EXCESS")
   (?\u223A "\\FortressUnknownCharacter{GEOMETRIC PROPORTION}" OPERATOR "GEOMETRIC_PROPORTION")
   (?\u223B "\\FortressUnknownCharacter{!HOMOTHETIC}" OPERATOR "HOMOTHETIC")
   (?\u223C "\\sim" OPERATOR "TILDE_OPERATOR" "SIM")
   (?\u223D "\\backsim" OPERATOR "REVERSED_TILDE" "BACKSIM")
   (?\u223E "\\FortressUnknownCharacter{INVERTED LAZY S}" OPERATOR "INVERTED_LAZY_S")
   (?\u223F "\\FortressUnknownCharacter{SINE WAVE}" OPERATOR "SINE_WAVE")
   (?\u2240 "\\wr" OPERATOR "WREATH_PRODUCT" "WREATH")
   (?\u2241 "\\nsim" OPERATOR "NOT_TILDE")
   (?\u224B "\\FortressUnknownCharacter{TRIPLE TILDE}" OPERATOR "TRIPLE_TILDE")
   (?\u224F "\\bumpeq" OPERATOR "DIFFERENCE_BETWEEN" "BUMPEQ")
   (?\u2250 "\\doteq" OPERATOR "APPROACHES_THE_LIMIT" "DOTEQ")
   (?\u2258 "\\FortressUnknownCharacter{CORRESPONDS TO}" OPERATOR "CORRESPONDS_TO")
   (?\u2259 "\\FortressUnknownCharacter{!ESTIMATES}" OPERATOR "ESTIMATES")
   (?\u225A "\\FortressUnknownCharacter{EQUIANGULAR TO}" OPERATOR "EQUIANGULAR_TO")
   (?\u225E "\\FortressUnknownCharacter{MEASURED BY}" OPERATOR "MEASURED_BY")
   (?\u226C "\\between" OPERATOR "BETWEEN")
   (?\u228C "\\FortressUnknownCharacter{!MULTISET}" OPERATOR "MULTISET")
   (?\u229A "\\circledcirc" OPERATOR "CIRCLED_RING_OPERATOR" "CIRCLEDRING")
   (?\u229D "\\circleddash" OPERATOR "CIRCLED_DASH")
   (?\u22A2 "\\vdash" OPERATOR "RIGHT_TACK" "VDASH" "TURNSTILE")
   (?\u22A3 "\\dashv" OPERATOR "LEFT_TACK" "DASHV")
   (?\u22A6 "\\vdash" OPERATOR "ASSERTION")
   (?\u22A7 "\\vDash" OPERATOR "MODELS")
   (?\u22A8 "\\models" OPERATOR "TRUE")
   (?\u22A9 "\\Vdash" OPERATOR "FORCES")
   (?\u22AA "\\Vvdash" OPERATOR "TRIPLE_VERTICAL_BAR_RIGHT_TURNSTILE")
   (?\u22AB "\\FortressUnknownCharacter{DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE}" OPERATOR "DOUBLE_VERTICAL_BAR_DOUBLE_RIGHT_TURNSTILE")
   (?\u22AC "\\nvdash" OPERATOR "DOES_NOT_PROVE")
   (?\u22AD "\\FortressUnknownCharacter{NOT TRUE}" OPERATOR "NOT_TRUE")
   (?\u22AE "\\nVdash" OPERATOR "DOES_NOT_FORCE")
   (?\u22AF "\\nVDash" OPERATOR "NEGATED_DOUBLE_VERTICAL_BAR_DOUBLE_RIGHT_TURNSTILE")
   (?\u22B6 "\\FortressUnknownCharacter{ORIGINAL OF}" OPERATOR "ORIGINAL_OF")
   (?\u22B7 "\\FortressUnknownCharacter{IMAGE OF}" OPERATOR "IMAGE_OF")
   (?\u22B8 "\\multimap" OPERATOR "MULTIMAP")
   (?\u22B9 "\\FortressUnknownCharacter{HERMITIAN CONJUGATE MATRIX}" OPERATOR "HERMITIAN_CONJUGATE_MATRIX")
   (?\u22BA "\\intercal" OPERATOR "INTERCALATE")
   (?\u22BE "\\FortressUnknownCharacter{RIGHT ANGLE WITH ARC}" OPERATOR "RIGHT_ANGLE_WITH_ARC")
   (?\u22BF "\\FortressUnknownCharacter{RIGHT TRIANGLE}" OPERATOR "RIGHT_TRIANGLE")
   (?\u22C0 "\\bigwedge" BIGOP "N_ARY_LOGICAL_AND" "BIGAND" "ALL")
   (?\u22C1 "\\bigvee" BIGOP "N_ARY_LOGICAL_OR" "BIGOR" "ANY")
   (?\u22C2 "\\bigcap" BIGOP "N_ARY_INTERSECTION" "BIGCAP" "BIGINTERSECT")
   (?\u22C3 "\\bigcup" BIGOP "N_ARY_UNION" "BIGCUP" "BIGUNION")
   (?\u22C4 "\\diamond" OPERATOR "DIAMOND_OPERATOR" "DIAMOND")
   (?\u22C6 "\\star" OPERATOR "STAR_OPERATOR" "STAR")
   (?\u22C7 "\\divideontimes" OPERATOR "DIVISION_TIMES")
   (?\u22C8 "\\bowtie" OPERATOR "BOWTIE")
   (?\u22C9 "\\ltimes" OPERATOR "LEFT_NORMAL_FACTOR_SEMIDIRECT_PRODUCT")
   (?\u22CA "\\rtimes" OPERATOR "RIGHT_NORMAL_FACTOR_SEMIDIRECT_PRODUCT")
   (?\u22CB "\\leftthreetimes" OPERATOR "LEFT_SEMIDIRECT_PRODUCT")
   (?\u22CC "\\rightthreetimes" OPERATOR "RIGHT_SEMIDIRECT_PRODUCT")
   (?\u22D4 "\\pitchfork" OPERATOR "PITCHFORK")
   (?\u22EE "\\FortressUnknownCharacter{VERTICAL ELLIPSIS}" OPERATOR "VERTICAL_ELLIPSIS")
   (?\u22EF "\\FortressUnknownCharacter{MIDLINE HORIZONTAL ELLIPSIS}" OPERATOR "MIDLINE_HORIZONTAL_ELLIPSIS")
   (?\u22F0 "\\FortressUnknownCharacter{UP RIGHT DIAGONAL ELLIPSIS}" OPERATOR "UP_RIGHT_DIAGONAL_ELLIPSIS")
   (?\u22F1 "\\FortressUnknownCharacter{DOWN RIGHT DIAGONAL ELLIPSIS}" OPERATOR "DOWN_RIGHT_DIAGONAL_ELLIPSIS")
   (?\u27C0 "\\FortressUnknownCharacter{THREE DIMENSIONAL ANGLE}" OPERATOR "THREE_DIMENSIONAL_ANGLE")
   (?\u27C1 "\\FortressUnknownCharacter{WHITE TRIANGLE CONTAINING SMALL WHITE TRIANGLE}" OPERATOR "WHITE_TRIANGLE_CONTAINING_SMALL_WHITE_TRIANGLE")
   (?\u27C2 "\\FortressUnknownCharacter{!PERPENDICULAR}" OPERATOR "PERPENDICULAR" "PERP")
   (?\u27D0 "\\FortressUnknownCharacter{WHITE DIAMOND WITH CENTRED DOT}" OPERATOR "WHITE_DIAMOND_WITH_CENTRED_DOT")
   (?\u27D2 "\\FortressUnknownCharacter{ELEMENT OF OPENING UPWARDS}" OPERATOR "ELEMENT_OF_OPENING_UPWARDS")
   (?\u27D3 "\\FortressUnknownCharacter{LOWER RIGHT CORNER WITH DOT}" OPERATOR "LOWER_RIGHT_CORNER_WITH_DOT")
   (?\u27D4 "\\FortressUnknownCharacter{UPPER LEFT CORNER WITH DOT}" OPERATOR "UPPER_LEFT_CORNER_WITH_DOT")
   (?\u27D5 "\\FortressUnknownCharacter{LEFT OUTER JOIN}" OPERATOR "LEFT_OUTER_JOIN")
   (?\u27D6 "\\FortressUnknownCharacter{RIGHT OUTER JOIN}" OPERATOR "RIGHT_OUTER_JOIN")
   (?\u27D7 "\\FortressUnknownCharacter{FULL OUTER JOIN}" OPERATOR "FULL_OUTER_JOIN")
   (?\u27D8 "\\FortressUnknownCharacter{LARGE UP TACK}" OPERATOR "LARGE_UP_TACK")
   (?\u27D9 "\\FortressUnknownCharacter{LARGE DOWN TACK}" OPERATOR "LARGE_DOWN_TACK")
   (?\u27DA "\\FortressUnknownCharacter{LEFT AND RIGHT DOUBLE TURNSTILE}" OPERATOR "LEFT_AND_RIGHT_DOUBLE_TURNSTILE")
   (?\u27DB "\\FortressUnknownCharacter{LEFT AND RIGHT TACK}" OPERATOR "LEFT_AND_RIGHT_TACK")
   (?\u27DC "\\FortressUnknownCharacter{LEFT MULTIMAP}" OPERATOR "LEFT_MULTIMAP")
   (?\u27DD "\\FortressUnknownCharacter{LONG RIGHT TACK}" OPERATOR "LONG_RIGHT_TACK")
   (?\u27DE "\\FortressUnknownCharacter{LONG LEFT TACK}" OPERATOR "LONG_LEFT_TACK")
   (?\u27DF "\\FortressUnknownCharacter{UP TACK WITH CIRCLE ABOVE}" OPERATOR "UP_TACK_WITH_CIRCLE_ABOVE")
   (?\u27E0 "\\FortressUnknownCharacter{LOZENGE DIVIDED BY HORIZONTAL RULE}" OPERATOR "LOZENGE_DIVIDED_BY_HORIZONTAL_RULE")
   (?\u27E1 "\\FortressUnknownCharacter{WHITE CONCAVE SIDED DIAMOND}" OPERATOR "WHITE_CONCAVE_SIDED_DIAMOND")
   (?\u27E2 "\\FortressUnknownCharacter{WHITE CONCAVE SIDED DIAMOND WITH LEFTWARDS TICK}" OPERATOR "WHITE_CONCAVE_SIDED_DIAMOND_WITH_LEFTWARDS_TICK")
   (?\u27E3 "\\FortressUnknownCharacter{WHITE CONCAVE SIDED DIAMOND WITH RIGHTWARDS TICK}" OPERATOR "WHITE_CONCAVE_SIDED_DIAMOND_WITH_RIGHTWARDS_TICK")
   (?\u27E4 "\\FortressUnknownCharacter{WHITE SQUARE WITH LEFTWARDS TICK}" OPERATOR "WHITE_SQUARE_WITH_LEFTWARDS_TICK")
   (?\u27E5 "\\FortressUnknownCharacter{WHITE SQUARE WITH RIGHTWARDS TICK}" OPERATOR "WHITE_SQUARE_WITH_RIGHTWARDS_TICK")
   (?\u27F0 "\\FortressUnknownCharacter{UPWARDS QUADRUPLE ARROW}" OPERATOR "UPWARDS_QUADRUPLE_ARROW")
   (?\u27F1 "\\FortressUnknownCharacter{DOWNWARDS QUADRUPLE ARROW}" OPERATOR "DOWNWARDS_QUADRUPLE_ARROW")
   (?\u27F2 "\\FortressUnknownCharacter{ANTICLOCKWISE GAPPED CIRCLE ARROW}" OPERATOR "ANTICLOCKWISE_GAPPED_CIRCLE_ARROW")
   (?\u27F3 "\\FortressUnknownCharacter{CLOCKWISE GAPPED CIRCLE ARROW}" OPERATOR "CLOCKWISE_GAPPED_CIRCLE_ARROW")
   (?\u27F4 "\\FortressUnknownCharacter{RIGHT ARROW WITH CIRCLED PLUS}" OPERATOR "RIGHT_ARROW_WITH_CIRCLED_PLUS")
   (?\u27F5 "\\FortressUnknownCharacter{LONG LEFTWARDS ARROW}" OPERATOR "LONG_LEFTWARDS_ARROW")
   (?\u27F6 "\\FortressUnknownCharacter{LONG RIGHTWARDS ARROW}" OPERATOR "LONG_RIGHTWARDS_ARROW")
   (?\u27F7 "\\FortressUnknownCharacter{LONG LEFT RIGHT ARROW}" OPERATOR "LONG_LEFT_RIGHT_ARROW")
   (?\u27F8 "\\FortressUnknownCharacter{LONG LEFTWARDS DOUBLE ARROW}" OPERATOR "LONG_LEFTWARDS_DOUBLE_ARROW")
   (?\u27F9 "\\FortressUnknownCharacter{LONG RIGHTWARDS DOUBLE ARROW}" OPERATOR "LONG_RIGHTWARDS_DOUBLE_ARROW")
   (?\u27FA "\\FortressUnknownCharacter{LONG LEFT RIGHT DOUBLE ARROW}" OPERATOR "LONG_LEFT_RIGHT_DOUBLE_ARROW")
   (?\u27FB "\\FortressUnknownCharacter{LONG LEFTWARDS ARROW FROM BAR}" OPERATOR "LONG_LEFTWARDS_ARROW_FROM_BAR")
   (?\u27FC "\\FortressUnknownCharacter{LONG RIGHTWARDS ARROW FROM BAR}" OPERATOR "LONG_RIGHTWARDS_ARROW_FROM_BAR")
   (?\u27FD "\\FortressUnknownCharacter{LONG LEFTWARDS DOUBLE ARROW FROM BAR}" OPERATOR "LONG_LEFTWARDS_DOUBLE_ARROW_FROM_BAR")
   (?\u27FE "\\FortressUnknownCharacter{LONG RIGHTWARDS DOUBLE ARROW FROM BAR}" OPERATOR "LONG_RIGHTWARDS_DOUBLE_ARROW_FROM_BAR")
   (?\u27FF "\\FortressUnknownCharacter{LONG RIGHTWARDS SQUIGGLE ARROW}" OPERATOR "LONG_RIGHTWARDS_SQUIGGLE_ARROW")
   (?\u2900 "\\FortressUnknownCharacter{RIGHTWARDS TWO HEADED ARROW WITH VERTICAL STROKE}" OPERATOR "RIGHTWARDS_TWO_HEADED_ARROW_WITH_VERTICAL_STROKE")
   (?\u2901 "\\FortressUnknownCharacter{RIGHTWARDS TWO HEADED ARROW WITH DOUBLE VERTICAL STROKE}" OPERATOR "RIGHTWARDS_TWO_HEADED_ARROW_WITH_DOUBLE_VERTICAL_STROKE")
   (?\u2902 "\\FortressUnknownCharacter{LEFTWARDS DOUBLE ARROW WITH VERTICAL STROKE}" OPERATOR "LEFTWARDS_DOUBLE_ARROW_WITH_VERTICAL_STROKE")
   (?\u2903 "\\FortressUnknownCharacter{RIGHTWARDS DOUBLE ARROW WITH VERTICAL STROKE}" OPERATOR "RIGHTWARDS_DOUBLE_ARROW_WITH_VERTICAL_STROKE")
   (?\u2904 "\\FortressUnknownCharacter{LEFT RIGHT DOUBLE ARROW WITH VERTICAL STROKE}" OPERATOR "LEFT_RIGHT_DOUBLE_ARROW_WITH_VERTICAL_STROKE")
   (?\u2905 "\\FortressUnknownCharacter{RIGHTWARDS TWO HEADED ARROW FROM BAR}" OPERATOR "RIGHTWARDS_TWO_HEADED_ARROW_FROM_BAR")
   (?\u2906 "\\FortressUnknownCharacter{LEFTWARDS DOUBLE ARROW FROM BAR}" OPERATOR "LEFTWARDS_DOUBLE_ARROW_FROM_BAR")
   (?\u2907 "\\FortressUnknownCharacter{RIGHTWARDS DOUBLE ARROW FROM BAR}" OPERATOR "RIGHTWARDS_DOUBLE_ARROW_FROM_BAR")
   (?\u2908 "\\FortressUnknownCharacter{DOWNWARDS ARROW WITH HORIZONTAL STROKE}" OPERATOR "DOWNWARDS_ARROW_WITH_HORIZONTAL_STROKE")
   (?\u2909 "\\FortressUnknownCharacter{UPWARDS ARROW WITH HORIZONTAL STROKE}" OPERATOR "UPWARDS_ARROW_WITH_HORIZONTAL_STROKE")
   (?\u290A "\\FortressUnknownCharacter{UPWARDS TRIPLE ARROW}" OPERATOR "UPWARDS_TRIPLE_ARROW")
   (?\u290B "\\FortressUnknownCharacter{DOWNWARDS TRIPLE ARROW}" OPERATOR "DOWNWARDS_TRIPLE_ARROW")
   (?\u290C "\\FortressUnknownCharacter{LEFTWARDS DOUBLE DASH ARROW}" OPERATOR "LEFTWARDS_DOUBLE_DASH_ARROW")
   (?\u290D "\\FortressUnknownCharacter{RIGHTWARDS DOUBLE DASH ARROW}" OPERATOR "RIGHTWARDS_DOUBLE_DASH_ARROW")
   (?\u290E "\\FortressUnknownCharacter{LEFTWARDS TRIPLE DASH ARROW}" OPERATOR "LEFTWARDS_TRIPLE_DASH_ARROW")
   (?\u290F "\\FortressUnknownCharacter{RIGHTWARDS TRIPLE DASH ARROW}" OPERATOR "RIGHTWARDS_TRIPLE_DASH_ARROW")
   (?\u2910 "\\FortressUnknownCharacter{RIGHTWARDS TWO HEADED TRIPLE DASH ARROW}" OPERATOR "RIGHTWARDS_TWO_HEADED_TRIPLE_DASH_ARROW")
   (?\u2911 "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH DOTTED STEM}" OPERATOR "RIGHTWARDS_ARROW_WITH_DOTTED_STEM")
   (?\u2912 "\\FortressUnknownCharacter{UPWARDS ARROW TO BAR}" OPERATOR "UPWARDS_ARROW_TO_BAR")
   (?\u2913 "\\FortressUnknownCharacter{DOWNWARDS ARROW TO BAR}" OPERATOR "DOWNWARDS_ARROW_TO_BAR")
   (?\u2914 "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH TAIL WITH VERTICAL STROKE}" OPERATOR "RIGHTWARDS_ARROW_WITH_TAIL_WITH_VERTICAL_STROKE")
   (?\u2915 "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH TAIL WITH DOUBLE VERTICAL STROKE}" OPERATOR "RIGHTWARDS_ARROW_WITH_TAIL_WITH_DOUBLE_VERTICAL_STROKE")
   (?\u2916 "\\FortressUnknownCharacter{RIGHTWARDS TWO HEADED ARROW WITH TAIL}" OPERATOR "RIGHTWARDS_TWO_HEADED_ARROW_WITH_TAIL")
   (?\u2917 "\\FortressUnknownCharacter{RIGHTWARDS TWO HEADED ARROW WITH TAIL WITH VERTICAL STROKE}" OPERATOR "RIGHTWARDS_TWO_HEADED_ARROW_WITH_TAIL_WITH_VERTICAL_STROKE")
   (?\u2918 "\\FortressUnknownCharacter{RIGHTWARDS TWO HEADED ARROW WITH TAIL WITH DOUBLE VERTICAL STROKE}" OPERATOR "RIGHTWARDS_TWO_HEADED_ARROW_WITH_TAIL_WITH_DOUBLE_VERTICAL_STROKE")
   (?\u2919 "\\FortressUnknownCharacter{LEFTWARDS ARROW TAIL}" OPERATOR "LEFTWARDS_ARROW_TAIL")
   (?\u291A "\\FortressUnknownCharacter{RIGHTWARDS ARROW TAIL}" OPERATOR "RIGHTWARDS_ARROW_TAIL")
   (?\u291B "\\FortressUnknownCharacter{LEFTWARDS DOUBLE ARROW TAIL}" OPERATOR "LEFTWARDS_DOUBLE_ARROW_TAIL")
   (?\u291C "\\FortressUnknownCharacter{RIGHTWARDS DOUBLE ARROW TAIL}" OPERATOR "RIGHTWARDS_DOUBLE_ARROW_TAIL")
   (?\u291D "\\FortressUnknownCharacter{LEFTWARDS ARROW TO BLACK DIAMOND}" OPERATOR "LEFTWARDS_ARROW_TO_BLACK_DIAMOND")
   (?\u291E "\\FortressUnknownCharacter{RIGHTWARDS ARROW TO BLACK DIAMOND}" OPERATOR "RIGHTWARDS_ARROW_TO_BLACK_DIAMOND")
   (?\u291F "\\FortressUnknownCharacter{LEFTWARDS ARROW FROM BAR TO BLACK DIAMOND}" OPERATOR "LEFTWARDS_ARROW_FROM_BAR_TO_BLACK_DIAMOND")
   (?\u2920 "\\FortressUnknownCharacter{RIGHTWARDS ARROW FROM BAR TO BLACK DIAMOND}" OPERATOR "RIGHTWARDS_ARROW_FROM_BAR_TO_BLACK_DIAMOND")
   (?\u2921 "\\FortressUnknownCharacter{NORTH WEST AND SOUTH EAST ARROW}" OPERATOR "NORTH_WEST_AND_SOUTH_EAST_ARROW")
   (?\u2922 "\\FortressUnknownCharacter{NORTH EAST AND SOUTH WEST ARROW}" OPERATOR "NORTH_EAST_AND_SOUTH_WEST_ARROW")
   (?\u2923 "\\FortressUnknownCharacter{NORTH WEST ARROW WITH HOOK}" OPERATOR "NORTH_WEST_ARROW_WITH_HOOK")
   (?\u2924 "\\FortressUnknownCharacter{NORTH EAST ARROW WITH HOOK}" OPERATOR "NORTH_EAST_ARROW_WITH_HOOK")
   (?\u2925 "\\FortressUnknownCharacter{SOUTH EAST ARROW WITH HOOK}" OPERATOR "SOUTH_EAST_ARROW_WITH_HOOK")
   (?\u2926 "\\FortressUnknownCharacter{SOUTH WEST ARROW WITH HOOK}" OPERATOR "SOUTH_WEST_ARROW_WITH_HOOK")
   (?\u2927 "\\FortressUnknownCharacter{NORTH WEST ARROW AND NORTH EAST ARROW}" OPERATOR "NORTH_WEST_ARROW_AND_NORTH_EAST_ARROW")
   (?\u2928 "\\FortressUnknownCharacter{NORTH EAST ARROW AND SOUTH EAST ARROW}" OPERATOR "NORTH_EAST_ARROW_AND_SOUTH_EAST_ARROW")
   (?\u2929 "\\FortressUnknownCharacter{SOUTH EAST ARROW AND SOUTH WEST ARROW}" OPERATOR "SOUTH_EAST_ARROW_AND_SOUTH_WEST_ARROW")
   (?\u292A "\\FortressUnknownCharacter{SOUTH WEST ARROW AND NORTH WEST ARROW}" OPERATOR "SOUTH_WEST_ARROW_AND_NORTH_WEST_ARROW")
   (?\u292B "\\FortressUnknownCharacter{RISING DIAGONAL CROSSING FALLING DIAGONAL}" OPERATOR "RISING_DIAGONAL_CROSSING_FALLING_DIAGONAL")
   (?\u292C "\\FortressUnknownCharacter{FALLING DIAGONAL CROSSING RISING DIAGONAL}" OPERATOR "FALLING_DIAGONAL_CROSSING_RISING_DIAGONAL")
   (?\u292D "\\FortressUnknownCharacter{SOUTH EAST ARROW CROSSING NORTH EAST ARROW}" OPERATOR "SOUTH_EAST_ARROW_CROSSING_NORTH_EAST_ARROW")
   (?\u292E "\\FortressUnknownCharacter{NORTH EAST ARROW CROSSING SOUTH EAST ARROW}" OPERATOR "NORTH_EAST_ARROW_CROSSING_SOUTH_EAST_ARROW")
   (?\u292F "\\FortressUnknownCharacter{FALLING DIAGONAL CROSSING NORTH EAST ARROW}" OPERATOR "FALLING_DIAGONAL_CROSSING_NORTH_EAST_ARROW")
   (?\u2930 "\\FortressUnknownCharacter{RISING DIAGONAL CROSSING SOUTH EAST ARROW}" OPERATOR "RISING_DIAGONAL_CROSSING_SOUTH_EAST_ARROW")
   (?\u2931 "\\FortressUnknownCharacter{NORTH EAST ARROW CROSSING NORTH WEST ARROW}" OPERATOR "NORTH_EAST_ARROW_CROSSING_NORTH_WEST_ARROW")
   (?\u2932 "\\FortressUnknownCharacter{NORTH WEST ARROW CROSSING NORTH EAST ARROW}" OPERATOR "NORTH_WEST_ARROW_CROSSING_NORTH_EAST_ARROW")
   (?\u2933 "\\FortressUnknownCharacter{WAVE ARROW POINTING DIRECTLY RIGHT}" OPERATOR "WAVE_ARROW_POINTING_DIRECTLY_RIGHT")
   (?\u2934 "\\FortressUnknownCharacter{ARROW POINTING RIGHTWARDS THEN CURVING UPWARDS}" OPERATOR "ARROW_POINTING_RIGHTWARDS_THEN_CURVING_UPWARDS")
   (?\u2935 "\\FortressUnknownCharacter{ARROW POINTING RIGHTWARDS THEN CURVING DOWNWARDS}" OPERATOR "ARROW_POINTING_RIGHTWARDS_THEN_CURVING_DOWNWARDS")
   (?\u2936 "\\FortressUnknownCharacter{ARROW POINTING DOWNWARDS THEN CURVING LEFTWARDS}" OPERATOR "ARROW_POINTING_DOWNWARDS_THEN_CURVING_LEFTWARDS")
   (?\u2937 "\\FortressUnknownCharacter{ARROW POINTING DOWNWARDS THEN CURVING RIGHTWARDS}" OPERATOR "ARROW_POINTING_DOWNWARDS_THEN_CURVING_RIGHTWARDS")
   (?\u2938 "\\FortressUnknownCharacter{RIGHT SIDE ARC CLOCKWISE ARROW}" OPERATOR "RIGHT_SIDE_ARC_CLOCKWISE_ARROW")
   (?\u2939 "\\FortressUnknownCharacter{LEFT SIDE ARC ANTICLOCKWISE ARROW}" OPERATOR "LEFT_SIDE_ARC_ANTICLOCKWISE_ARROW")
   (?\u293A "\\FortressUnknownCharacter{TOP ARC ANTICLOCKWISE ARROW}" OPERATOR "TOP_ARC_ANTICLOCKWISE_ARROW")
   (?\u293B "\\FortressUnknownCharacter{BOTTOM ARC ANTICLOCKWISE ARROW}" OPERATOR "BOTTOM_ARC_ANTICLOCKWISE_ARROW")
   (?\u293C "\\FortressUnknownCharacter{TOP ARC CLOCKWISE ARROW WITH MINUS}" OPERATOR "TOP_ARC_CLOCKWISE_ARROW_WITH_MINUS")
   (?\u293D "\\FortressUnknownCharacter{TOP ARC ANTICLOCKWISE ARROW WITH PLUS}" OPERATOR "TOP_ARC_ANTICLOCKWISE_ARROW_WITH_PLUS")
   (?\u293E "\\FortressUnknownCharacter{LOWER RIGHT SEMICIRCULAR CLOCKWISE ARROW}" OPERATOR "LOWER_RIGHT_SEMICIRCULAR_CLOCKWISE_ARROW")
   (?\u293F "\\FortressUnknownCharacter{LOWER LEFT SEMICIRCULAR ANTICLOCKWISE ARROW}" OPERATOR "LOWER_LEFT_SEMICIRCULAR_ANTICLOCKWISE_ARROW")
   (?\u2940 "\\FortressUnknownCharacter{ANTICLOCKWISE CLOSED CIRCLE ARROW}" OPERATOR "ANTICLOCKWISE_CLOSED_CIRCLE_ARROW")
   (?\u2941 "\\FortressUnknownCharacter{CLOCKWISE CLOSED CIRCLE ARROW}" OPERATOR "CLOCKWISE_CLOSED_CIRCLE_ARROW")
   (?\u2942 "\\FortressUnknownCharacter{RIGHTWARDS ARROW ABOVE SHORT LEFTWARDS ARROW}" OPERATOR "RIGHTWARDS_ARROW_ABOVE_SHORT_LEFTWARDS_ARROW")
   (?\u2943 "\\FortressUnknownCharacter{LEFTWARDS ARROW ABOVE SHORT RIGHTWARDS ARROW}" OPERATOR "LEFTWARDS_ARROW_ABOVE_SHORT_RIGHTWARDS_ARROW")
   (?\u2944 "\\FortressUnknownCharacter{SHORT RIGHTWARDS ARROW ABOVE LEFTWARDS ARROW}" OPERATOR "SHORT_RIGHTWARDS_ARROW_ABOVE_LEFTWARDS_ARROW")
   (?\u2945 "\\FortressUnknownCharacter{RIGHTWARDS ARROW WITH PLUS BELOW}" OPERATOR "RIGHTWARDS_ARROW_WITH_PLUS_BELOW")
   (?\u2946 "\\FortressUnknownCharacter{LEFTWARDS ARROW WITH PLUS BELOW}" OPERATOR "LEFTWARDS_ARROW_WITH_PLUS_BELOW")
   (?\u2947 "\\FortressUnknownCharacter{RIGHTWARDS ARROW THROUGH X}" OPERATOR "RIGHTWARDS_ARROW_THROUGH_X")
   (?\u2948 "\\FortressUnknownCharacter{LEFT RIGHT ARROW THROUGH SMALL CIRCLE}" OPERATOR "LEFT_RIGHT_ARROW_THROUGH_SMALL_CIRCLE")
   (?\u2949 "\\FortressUnknownCharacter{UPWARDS TWO HEADED ARROW FROM SMALL CIRCLE}" OPERATOR "UPWARDS_TWO_HEADED_ARROW_FROM_SMALL_CIRCLE")
   (?\u294A "\\FortressUnknownCharacter{LEFT BARB UP RIGHT BARB DOWN HARPOON}" OPERATOR "LEFT_BARB_UP_RIGHT_BARB_DOWN_HARPOON")
   (?\u294B "\\FortressUnknownCharacter{LEFT BARB DOWN RIGHT BARB UP HARPOON}" OPERATOR "LEFT_BARB_DOWN_RIGHT_BARB_UP_HARPOON")
   (?\u294C "\\FortressUnknownCharacter{UP BARB RIGHT DOWN BARB LEFT HARPOON}" OPERATOR "UP_BARB_RIGHT_DOWN_BARB_LEFT_HARPOON")
   (?\u294D "\\FortressUnknownCharacter{UP BARB LEFT DOWN BARB RIGHT HARPOON}" OPERATOR "UP_BARB_LEFT_DOWN_BARB_RIGHT_HARPOON")
   (?\u294E "\\FortressUnknownCharacter{LEFT BARB UP RIGHT BARB UP HARPOON}" OPERATOR "LEFT_BARB_UP_RIGHT_BARB_UP_HARPOON")
   (?\u294F "\\FortressUnknownCharacter{UP BARB RIGHT DOWN BARB RIGHT HARPOON}" OPERATOR "UP_BARB_RIGHT_DOWN_BARB_RIGHT_HARPOON")
   (?\u2950 "\\FortressUnknownCharacter{LEFT BARB DOWN RIGHT BARB DOWN HARPOON}" OPERATOR "LEFT_BARB_DOWN_RIGHT_BARB_DOWN_HARPOON")
   (?\u2951 "\\FortressUnknownCharacter{UP BARB LEFT DOWN BARB LEFT HARPOON}" OPERATOR "UP_BARB_LEFT_DOWN_BARB_LEFT_HARPOON")
   (?\u2952 "\\FortressUnknownCharacter{LEFTWARDS HARPOON WITH BARB UP TO BAR}" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_UP_TO_BAR")
   (?\u2953 "\\FortressUnknownCharacter{RIGHTWARDS HARPOON WITH BARB UP TO BAR}" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_UP_TO_BAR")
   (?\u2954 "\\FortressUnknownCharacter{UPWARDS HARPOON WITH BARB RIGHT TO BAR}" OPERATOR "UPWARDS_HARPOON_WITH_BARB_RIGHT_TO_BAR")
   (?\u2955 "\\FortressUnknownCharacter{DOWNWARDS HARPOON WITH BARB RIGHT TO BAR}" OPERATOR "DOWNWARDS_HARPOON_WITH_BARB_RIGHT_TO_BAR")
   (?\u2956 "\\FortressUnknownCharacter{LEFTWARDS HARPOON WITH BARB DOWN TO BAR}" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_DOWN_TO_BAR")
   (?\u2957 "\\FortressUnknownCharacter{RIGHTWARDS HARPOON WITH BARB DOWN TO BAR}" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_DOWN_TO_BAR")
   (?\u2958 "\\FortressUnknownCharacter{UPWARDS HARPOON WITH BARB LEFT TO BAR}" OPERATOR "UPWARDS_HARPOON_WITH_BARB_LEFT_TO_BAR")
   (?\u2959 "\\FortressUnknownCharacter{DOWNWARDS HARPOON WITH BARB LEFT TO BAR}" OPERATOR "DOWNWARDS_HARPOON_WITH_BARB_LEFT_TO_BAR")
   (?\u295A "\\FortressUnknownCharacter{LEFTWARDS HARPOON WITH BARB UP FROM BAR}" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_UP_FROM_BAR")
   (?\u295B "\\FortressUnknownCharacter{RIGHTWARDS HARPOON WITH BARB UP FROM BAR}" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_UP_FROM_BAR")
   (?\u295C "\\FortressUnknownCharacter{UPWARDS HARPOON WITH BARB RIGHT FROM BAR}" OPERATOR "UPWARDS_HARPOON_WITH_BARB_RIGHT_FROM_BAR")
   (?\u295D "\\FortressUnknownCharacter{DOWNWARDS HARPOON WITH BARB RIGHT FROM BAR}" OPERATOR "DOWNWARDS_HARPOON_WITH_BARB_RIGHT_FROM_BAR")
   (?\u295E "\\FortressUnknownCharacter{LEFTWARDS HARPOON WITH BARB DOWN FROM BAR}" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_DOWN_FROM_BAR")
   (?\u295F "\\FortressUnknownCharacter{RIGHTWARDS HARPOON WITH BARB DOWN FROM BAR}" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_DOWN_FROM_BAR")
   (?\u2960 "\\FortressUnknownCharacter{UPWARDS HARPOON WITH BARB LEFT FROM BAR}" OPERATOR "UPWARDS_HARPOON_WITH_BARB_LEFT_FROM_BAR")
   (?\u2961 "\\FortressUnknownCharacter{DOWNWARDS HARPOON WITH BARB LEFT FROM BAR}" OPERATOR "DOWNWARDS_HARPOON_WITH_BARB_LEFT_FROM_BAR")
   (?\u2962 "\\FortressUnknownCharacter{LEFTWARDS HARPOON WITH BARB UP ABOVE LEFTWARDS HARPOON WITH BARB DOWN}" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_UP_ABOVE_LEFTWARDS_HARPOON_WITH_BARB_DOWN")
   (?\u2963 "\\FortressUnknownCharacter{UPWARDS HARPOON WITH BARB LEFT BESIDE UPWARDS HARPOON WITH BARB RIGHT}" OPERATOR "UPWARDS_HARPOON_WITH_BARB_LEFT_BESIDE_UPWARDS_HARPOON_WITH_BARB_RIGHT")
   (?\u2964 "\\FortressUnknownCharacter{RIGHTWARDS HARPOON WITH BARB UP ABOVE RIGHTWARDS HARPOON WITH BARB DOWN}" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_UP_ABOVE_RIGHTWARDS_HARPOON_WITH_BARB_DOWN")
   (?\u2965 "\\FortressUnknownCharacter{DOWNWARDS HARPOON WITH BARB LEFT BESIDE DOWNWARDS HARPOON WITH BARB RIGHT}" OPERATOR "DOWNWARDS_HARPOON_WITH_BARB_LEFT_BESIDE_DOWNWARDS_HARPOON_WITH_BARB_RIGHT")
   (?\u2966 "\\FortressUnknownCharacter{LEFTWARDS HARPOON WITH BARB UP ABOVE RIGHTWARDS HARPOON WITH BARB UP}" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_UP_ABOVE_RIGHTWARDS_HARPOON_WITH_BARB_UP")
   (?\u2967 "\\FortressUnknownCharacter{LEFTWARDS HARPOON WITH BARB DOWN ABOVE RIGHTWARDS HARPOON WITH BARB DOWN}" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_DOWN_ABOVE_RIGHTWARDS_HARPOON_WITH_BARB_DOWN")
   (?\u2968 "\\FortressUnknownCharacter{RIGHTWARDS HARPOON WITH BARB UP ABOVE LEFTWARDS HARPOON WITH BARB UP}" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_UP_ABOVE_LEFTWARDS_HARPOON_WITH_BARB_UP")
   (?\u2969 "\\FortressUnknownCharacter{RIGHTWARDS HARPOON WITH BARB DOWN ABOVE LEFTWARDS HARPOON WITH BARB DOWN}" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_DOWN_ABOVE_LEFTWARDS_HARPOON_WITH_BARB_DOWN")
   (?\u296A "\\FortressUnknownCharacter{LEFTWARDS HARPOON WITH BARB UP ABOVE LONG DASH}" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_UP_ABOVE_LONG_DASH")
   (?\u296B "\\FortressUnknownCharacter{LEFTWARDS HARPOON WITH BARB DOWN BELOW LONG DASH}" OPERATOR "LEFTWARDS_HARPOON_WITH_BARB_DOWN_BELOW_LONG_DASH")
   (?\u296C "\\FortressUnknownCharacter{RIGHTWARDS HARPOON WITH BARB UP ABOVE LONG DASH}" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_UP_ABOVE_LONG_DASH")
   (?\u296D "\\FortressUnknownCharacter{RIGHTWARDS HARPOON WITH BARB DOWN BELOW LONG DASH}" OPERATOR "RIGHTWARDS_HARPOON_WITH_BARB_DOWN_BELOW_LONG_DASH")
   (?\u296E "\\FortressUnknownCharacter{UPWARDS HARPOON WITH BARB LEFT BESIDE DOWNWARDS HARPOON WITH BARB RIGHT}" OPERATOR "UPWARDS_HARPOON_WITH_BARB_LEFT_BESIDE_DOWNWARDS_HARPOON_WITH_BARB_RIGHT")
   (?\u296F "\\FortressUnknownCharacter{DOWNWARDS HARPOON WITH BARB LEFT BESIDE UPWARDS HARPOON WITH BARB RIGHT}" OPERATOR "DOWNWARDS_HARPOON_WITH_BARB_LEFT_BESIDE_UPWARDS_HARPOON_WITH_BARB_RIGHT")
   (?\u2970 "\\FortressUnknownCharacter{RIGHT DOUBLE ARROW WITH ROUNDED HEAD}" OPERATOR "RIGHT_DOUBLE_ARROW_WITH_ROUNDED_HEAD")
   (?\u2971 "\\FortressUnknownCharacter{EQUALS SIGN ABOVE RIGHTWARDS ARROW}" OPERATOR "EQUALS_SIGN_ABOVE_RIGHTWARDS_ARROW")
   (?\u2972 "\\FortressUnknownCharacter{TILDE OPERATOR ABOVE RIGHTWARDS ARROW}" OPERATOR "TILDE_OPERATOR_ABOVE_RIGHTWARDS_ARROW")
   (?\u2973 "\\FortressUnknownCharacter{LEFTWARDS ARROW ABOVE TILDE OPERATOR}" OPERATOR "LEFTWARDS_ARROW_ABOVE_TILDE_OPERATOR")
   (?\u2974 "\\FortressUnknownCharacter{RIGHTWARDS ARROW ABOVE TILDE OPERATOR}" OPERATOR "RIGHTWARDS_ARROW_ABOVE_TILDE_OPERATOR")
   (?\u2975 "\\FortressUnknownCharacter{RIGHTWARDS ARROW ABOVE ALMOST EQUAL TO}" OPERATOR "RIGHTWARDS_ARROW_ABOVE_ALMOST_EQUAL_TO")
   (?\u2976 "\\FortressUnknownCharacter{LESS THAN ABOVE LEFTWARDS ARROW}" OPERATOR "LESS_THAN_ABOVE_LEFTWARDS_ARROW")
   (?\u2977 "\\FortressUnknownCharacter{LEFTWARDS ARROW THROUGH LESS THAN}" OPERATOR "LEFTWARDS_ARROW_THROUGH_LESS_THAN")
   (?\u2978 "\\FortressUnknownCharacter{GREATER THAN ABOVE RIGHTWARDS ARROW}" OPERATOR "GREATER_THAN_ABOVE_RIGHTWARDS_ARROW")
   (?\u2979 "\\FortressUnknownCharacter{SUBSET ABOVE RIGHTWARDS ARROW}" OPERATOR "SUBSET_ABOVE_RIGHTWARDS_ARROW")
   (?\u297A "\\FortressUnknownCharacter{LEFTWARDS ARROW THROUGH SUBSET}" OPERATOR "LEFTWARDS_ARROW_THROUGH_SUBSET")
   (?\u297B "\\FortressUnknownCharacter{SUPERSET ABOVE LEFTWARDS ARROW}" OPERATOR "SUPERSET_ABOVE_LEFTWARDS_ARROW")
   (?\u297C "\\FortressUnknownCharacter{LEFT FISH TAIL}" OPERATOR "LEFT_FISH_TAIL")
   (?\u297D "\\FortressUnknownCharacter{RIGHT FISH TAIL}" OPERATOR "RIGHT_FISH_TAIL")
   (?\u297E "\\FortressUnknownCharacter{UP FISH TAIL}" OPERATOR "UP_FISH_TAIL")
   (?\u297F "\\FortressUnknownCharacter{DOWN FISH TAIL}" OPERATOR "DOWN_FISH_TAIL")
   (?\u2980 "\\FortressUnknownCharacter{TRIPLE VERTICAL BAR DELIMITER}" OPERATOR "TRIPLE_VERTICAL_BAR_DELIMITER")
   (?\u2981 "\\FortressUnknownCharacter{Z NOTATION SPOT}" OPERATOR "Z_NOTATION_SPOT")
   (?\u2982 "\\FortressUnknownCharacter{Z NOTATION TYPE COLON}" OPERATOR "Z_NOTATION_TYPE_COLON")
   (?\u2999 "\\FortressUnknownCharacter{DOTTED FENCE}" OPERATOR "DOTTED_FENCE")
   (?\u299A "\\FortressUnknownCharacter{VERTICAL ZIGZAG LINE}" OPERATOR "VERTICAL_ZIGZAG_LINE")
   (?\u299B "\\FortressUnknownCharacter{MEASURED ANGLE OPENING LEFT}" OPERATOR "MEASURED_ANGLE_OPENING_LEFT")
   (?\u299C "\\FortressUnknownCharacter{RIGHT ANGLE VARIANT WITH SQUARE}" OPERATOR "RIGHT_ANGLE_VARIANT_WITH_SQUARE")
   (?\u299D "\\FortressUnknownCharacter{MEASURED RIGHT ANGLE WITH DOT}" OPERATOR "MEASURED_RIGHT_ANGLE_WITH_DOT")
   (?\u299E "\\FortressUnknownCharacter{ANGLE WITH S INSIDE}" OPERATOR "ANGLE_WITH_S_INSIDE")
   (?\u299F "\\FortressUnknownCharacter{ACUTE ANGLE}" OPERATOR "ACUTE_ANGLE")
   (?\u29A0 "\\FortressUnknownCharacter{SPHERICAL ANGLE OPENING LEFT}" OPERATOR "SPHERICAL_ANGLE_OPENING_LEFT")
   (?\u29A1 "\\FortressUnknownCharacter{SPHERICAL ANGLE OPENING UP}" OPERATOR "SPHERICAL_ANGLE_OPENING_UP")
   (?\u29A2 "\\FortressUnknownCharacter{TURNED ANGLE}" OPERATOR "TURNED_ANGLE")
   (?\u29A3 "\\FortressUnknownCharacter{REVERSED ANGLE}" OPERATOR "REVERSED_ANGLE")
   (?\u29A4 "\\FortressUnknownCharacter{ANGLE WITH UNDERBAR}" OPERATOR "ANGLE_WITH_UNDERBAR")
   (?\u29A5 "\\FortressUnknownCharacter{REVERSED ANGLE WITH UNDERBAR}" OPERATOR "REVERSED_ANGLE_WITH_UNDERBAR")
   (?\u29A6 "\\FortressUnknownCharacter{OBLIQUE ANGLE OPENING UP}" OPERATOR "OBLIQUE_ANGLE_OPENING_UP")
   (?\u29A7 "\\FortressUnknownCharacter{OBLIQUE ANGLE OPENING DOWN}" OPERATOR "OBLIQUE_ANGLE_OPENING_DOWN")
   (?\u29A8 "\\FortressUnknownCharacter{MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW POINTING UP AND RIGHT}" OPERATOR "MEASURED_ANGLE_WITH_OPEN_ARM_ENDING_IN_ARROW_POINTING_UP_AND_RIGHT")
   (?\u29A9 "\\FortressUnknownCharacter{MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW POINTING UP AND LEFT}" OPERATOR "MEASURED_ANGLE_WITH_OPEN_ARM_ENDING_IN_ARROW_POINTING_UP_AND_LEFT")
   (?\u29AA "\\FortressUnknownCharacter{MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW POINTING DOWN AND RIGHT}" OPERATOR "MEASURED_ANGLE_WITH_OPEN_ARM_ENDING_IN_ARROW_POINTING_DOWN_AND_RIGHT")
   (?\u29AB "\\FortressUnknownCharacter{MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW POINTING DOWN AND LEFT}" OPERATOR "MEASURED_ANGLE_WITH_OPEN_ARM_ENDING_IN_ARROW_POINTING_DOWN_AND_LEFT")
   (?\u29AC "\\FortressUnknownCharacter{MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW POINTING RIGHT AND UP}" OPERATOR "MEASURED_ANGLE_WITH_OPEN_ARM_ENDING_IN_ARROW_POINTING_RIGHT_AND_UP")
   (?\u29AD "\\FortressUnknownCharacter{MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW POINTING LEFT AND UP}" OPERATOR "MEASURED_ANGLE_WITH_OPEN_ARM_ENDING_IN_ARROW_POINTING_LEFT_AND_UP")
   (?\u29AE "\\FortressUnknownCharacter{MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW POINTING RIGHT AND DOWN}" OPERATOR "MEASURED_ANGLE_WITH_OPEN_ARM_ENDING_IN_ARROW_POINTING_RIGHT_AND_DOWN")
   (?\u29AF "\\FortressUnknownCharacter{MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW POINTING LEFT AND DOWN}" OPERATOR "MEASURED_ANGLE_WITH_OPEN_ARM_ENDING_IN_ARROW_POINTING_LEFT_AND_DOWN")
   (?\u29B0 "\\FortressUnknownCharacter{REVERSED EMPTY SET}" OPERATOR "REVERSED_EMPTY_SET")
   (?\u29B1 "\\FortressUnknownCharacter{EMPTY SET WITH OVERBAR}" OPERATOR "EMPTY_SET_WITH_OVERBAR")
   (?\u29B2 "\\FortressUnknownCharacter{EMPTY SET WITH SMALL CIRCLE ABOVE}" OPERATOR "EMPTY_SET_WITH_SMALL_CIRCLE_ABOVE")
   (?\u29B3 "\\FortressUnknownCharacter{EMPTY SET WITH RIGHT ARROW ABOVE}" OPERATOR "EMPTY_SET_WITH_RIGHT_ARROW_ABOVE")
   (?\u29B4 "\\FortressUnknownCharacter{EMPTY SET WITH LEFT ARROW ABOVE}" OPERATOR "EMPTY_SET_WITH_LEFT_ARROW_ABOVE")
   (?\u29B5 "\\FortressUnknownCharacter{CIRCLE WITH HORIZONTAL BAR}" OPERATOR "CIRCLE_WITH_HORIZONTAL_BAR")
   (?\u29B6 "\\FortressUnknownCharacter{CIRCLED VERTICAL BAR}" OPERATOR "CIRCLED_VERTICAL_BAR")
   (?\u29B7 "\\FortressUnknownCharacter{CIRCLED PARALLEL}" OPERATOR "CIRCLED_PARALLEL")
   (?\u29B9 "\\FortressUnknownCharacter{CIRCLED PERPENDICULAR}" OPERATOR "CIRCLED_PERPENDICULAR")
   (?\u29BA "\\FortressUnknownCharacter{CIRCLE DIVIDED BY HORIZONTAL BAR AND TOP HALF DIVIDED BY VERTICAL BAR}" OPERATOR "CIRCLE_DIVIDED_BY_HORIZONTAL_BAR_AND_TOP_HALF_DIVIDED_BY_VERTICAL_BAR")
   (?\u29BB "\\FortressUnknownCharacter{CIRCLE WITH SUPERIMPOSED X}" OPERATOR "CIRCLE_WITH_SUPERIMPOSED_X")
   (?\u29BD "\\FortressUnknownCharacter{UP ARROW THROUGH CIRCLE}" OPERATOR "UP_ARROW_THROUGH_CIRCLE")
   (?\u29BE "\\FortressUnknownCharacter{CIRCLED WHITE BULLET}" OPERATOR "CIRCLED_WHITE_BULLET")
   (?\u29BF "\\FortressUnknownCharacter{CIRCLED BULLET}" OPERATOR "CIRCLED_BULLET")
   (?\u29C2 "\\FortressUnknownCharacter{CIRCLE WITH SMALL CIRCLE TO THE RIGHT}" OPERATOR "CIRCLE_WITH_SMALL_CIRCLE_TO_THE_RIGHT")
   (?\u29C3 "\\FortressUnknownCharacter{CIRCLE WITH TWO HORIZONTAL STROKES TO THE RIGHT}" OPERATOR "CIRCLE_WITH_TWO_HORIZONTAL_STROKES_TO_THE_RIGHT")
   (?\u29C5 "\\FortressUnknownCharacter{SQUARED FALLING DIAGONAL SLASH}" OPERATOR "SQUARED_FALLING_DIAGONAL_SLASH")
   (?\u29C7 "\\FortressUnknownCharacter{SQUARED SMALL CIRCLE}" OPERATOR "SQUARED_SMALL_CIRCLE")
   (?\u29C8 "\\FortressUnknownCharacter{SQUARED SQUARE}" OPERATOR "SQUARED_SQUARE")
   (?\u29C9 "\\FortressUnknownCharacter{TWO JOINED SQUARES}" OPERATOR "TWO_JOINED_SQUARES")
   (?\u29CA "\\FortressUnknownCharacter{TRIANGLE WITH DOT ABOVE}" OPERATOR "TRIANGLE_WITH_DOT_ABOVE")
   (?\u29CB "\\FortressUnknownCharacter{TRIANGLE WITH UNDERBAR}" OPERATOR "TRIANGLE_WITH_UNDERBAR")
   (?\u29CC "\\FortressUnknownCharacter{S IN TRIANGLE}" OPERATOR "S_IN_TRIANGLE")
   (?\u29CD "\\FortressUnknownCharacter{TRIANGLE WITH SERIFS AT BOTTOM}" OPERATOR "TRIANGLE_WITH_SERIFS_AT_BOTTOM")
   (?\u29CE "\\FortressUnknownCharacter{RIGHT TRIANGLE ABOVE LEFT TRIANGLE}" OPERATOR "RIGHT_TRIANGLE_ABOVE_LEFT_TRIANGLE")
   (?\u29CF "\\FortressUnknownCharacter{LEFT TRIANGLE BESIDE VERTICAL BAR}" OPERATOR "LEFT_TRIANGLE_BESIDE_VERTICAL_BAR")
   (?\u29D0 "\\FortressUnknownCharacter{VERTICAL BAR BESIDE RIGHT TRIANGLE}" OPERATOR "VERTICAL_BAR_BESIDE_RIGHT_TRIANGLE")
   (?\u29D1 "\\FortressUnknownCharacter{BOWTIE WITH LEFT HALF BLACK}" OPERATOR "BOWTIE_WITH_LEFT_HALF_BLACK")
   (?\u29D2 "\\FortressUnknownCharacter{BOWTIE WITH RIGHT HALF BLACK}" OPERATOR "BOWTIE_WITH_RIGHT_HALF_BLACK")
   (?\u29D3 "\\FortressUnknownCharacter{BLACK BOWTIE}" OPERATOR "BLACK_BOWTIE")
   (?\u29D6 "\\FortressUnknownCharacter{WHITE HOURGLASS}" OPERATOR "WHITE_HOURGLASS")
   (?\u29D7 "\\FortressUnknownCharacter{BLACK HOURGLASS}" OPERATOR "BLACK_HOURGLASS")
   (?\u29DC "\\FortressUnknownCharacter{INCOMPLETE INFINITY}" OPERATOR "INCOMPLETE_INFINITY")
   (?\u29DD "\\FortressUnknownCharacter{TIE OVER INFINITY}" OPERATOR "TIE_OVER_INFINITY")
   (?\u29DE "\\FortressUnknownCharacter{INFINITY NEGATED WITH VERTICAL BAR}" OPERATOR "INFINITY_NEGATED_WITH_VERTICAL_BAR")
   (?\u29DF "\\FortressUnknownCharacter{DOUBLE ENDED MULTIMAP}" OPERATOR "DOUBLE_ENDED_MULTIMAP")
   (?\u29E0 "\\FortressUnknownCharacter{SQUARE WITH CONTOURED OUTLINE}" OPERATOR "SQUARE_WITH_CONTOURED_OUTLINE")
   (?\u29E1 "\\FortressUnknownCharacter{INCREASES AS}" OPERATOR "INCREASES_AS")
   (?\u29E2 "\\FortressUnknownCharacter{SHUFFLE PRODUCT}" OPERATOR "SHUFFLE_PRODUCT")
   (?\u29E6 "\\FortressUnknownCharacter{GLEICH STARK}" OPERATOR "GLEICH_STARK")
   (?\u29E7 "\\FortressUnknownCharacter{!THERMODYNAMIC}" OPERATOR "THERMODYNAMIC")
   (?\u29E8 "\\FortressUnknownCharacter{DOWN POINTING TRIANGLE WITH LEFT HALF BLACK}" OPERATOR "DOWN_POINTING_TRIANGLE_WITH_LEFT_HALF_BLACK")
   (?\u29E9 "\\FortressUnknownCharacter{DOWN POINTING TRIANGLE WITH RIGHT HALF BLACK}" OPERATOR "DOWN_POINTING_TRIANGLE_WITH_RIGHT_HALF_BLACK")
   (?\u29EA "\\FortressUnknownCharacter{BLACK DIAMOND WITH DOWN ARROW}" OPERATOR "BLACK_DIAMOND_WITH_DOWN_ARROW")
   (?\u29EB "\\FortressUnknownCharacter{BLACK LOZENGE}" OPERATOR "BLACK_LOZENGE")
   (?\u29EC "\\FortressUnknownCharacter{WHITE CIRCLE WITH DOWN ARROW}" OPERATOR "WHITE_CIRCLE_WITH_DOWN_ARROW")
   (?\u29ED "\\FortressUnknownCharacter{BLACK CIRCLE WITH DOWN ARROW}" OPERATOR "BLACK_CIRCLE_WITH_DOWN_ARROW")
   (?\u29EE "\\FortressUnknownCharacter{ERROR BARRED WHITE SQUARE}" OPERATOR "ERROR_BARRED_WHITE_SQUARE")
   (?\u29EF "\\FortressUnknownCharacter{ERROR BARRED BLACK SQUARE}" OPERATOR "ERROR_BARRED_BLACK_SQUARE")
   (?\u29F0 "\\FortressUnknownCharacter{ERROR BARRED WHITE DIAMOND}" OPERATOR "ERROR_BARRED_WHITE_DIAMOND")
   (?\u29F1 "\\FortressUnknownCharacter{ERROR BARRED BLACK DIAMOND}" OPERATOR "ERROR_BARRED_BLACK_DIAMOND")
   (?\u29F2 "\\FortressUnknownCharacter{ERROR BARRED WHITE CIRCLE}" OPERATOR "ERROR_BARRED_WHITE_CIRCLE")
   (?\u29F3 "\\FortressUnknownCharacter{ERROR BARRED BLACK CIRCLE}" OPERATOR "ERROR_BARRED_BLACK_CIRCLE")
   (?\u29F4 "\\FortressUnknownCharacter{RULE DELAYED}" OPERATOR "RULE_DELAYED")
   (?\u29F6 "\\FortressUnknownCharacter{SOLIDUS WITH OVERBAR}" OPERATOR "SOLIDUS_WITH_OVERBAR")
   (?\u29F7 "\\FortressUnknownCharacter{REVERSE SOLIDUS WITH HORIZONTAL STROKE}" OPERATOR "REVERSE_SOLIDUS_WITH_HORIZONTAL_STROKE")
   (?\u29FA "\\FortressUnknownCharacter{DOUBLE PLUS}" OPERATOR "DOUBLE_PLUS")
   (?\u29FB "\\FortressUnknownCharacter{TRIPLE PLUS}" OPERATOR "TRIPLE_PLUS")
   (?\u29FE "\\FortressUnknownCharacter{!TINY}" OPERATOR "TINY")
   (?\u29FF "\\FortressUnknownCharacter{!MINY}" OPERATOR "MINY")
   (?\u2A00 "\\bigodot" BIGOP "N_ARY_CIRCLED_DOT_OPERATOR" "BIGODOT")
   (?\u2A01 "\\bigoplus" BIGOP "N_ARY_CIRCLED_PLUS_OPERATOR" "BIGOPLUS")
   (?\u2A02 "\\bigotimes" BIGOP "N_ARY_CIRCLED_TIMES_OPERATOR" "BIGOTIMES")
   (?\u2A03 "\\FortressUnknownCharacter{N ARY UNION OPERATOR WITH DOT}" BIGOP "N_ARY_UNION_OPERATOR_WITH_DOT" "BIGUDOT")
   (?\u2A04 "\\biguplus" BIGOP "N_ARY_UNION_OPERATOR_WITH_PLUS" "BIGUPLUS")
   (?\u2A05 "\\FortressUnknownCharacter{N ARY SQUARE INTERSECTION OPERATOR}" BIGOP "N_ARY_SQUARE_INTERSECTION_OPERATOR" "BIGSQCAP")
   (?\u2A06 "\\FortressUnknownCharacter{N ARY SQUARE UNION OPERATOR}" BIGOP "N_ARY_SQUARE_UNION_OPERATOR" "BIGSQCUP")
   (?\u2A07 "\\FortressUnknownCharacter{TWO LOGICAL AND OPERATOR}" OPERATOR "TWO_LOGICAL_AND_OPERATOR")
   (?\u2A08 "\\FortressUnknownCharacter{TWO LOGICAL OR OPERATOR}" OPERATOR "TWO_LOGICAL_OR_OPERATOR")
   (?\u2A09 "\\FortressUnknownCharacter{N ARY TIMES OPERATOR}" BIGOP "N_ARY_TIMES_OPERATOR" "BIGTIMES")
   (?\u2A0A "\\FortressUnknownCharacter{MODULO TWO SUM}" OPERATOR "MODULO_TWO_SUM")
   (?\u2A10 "\\FortressUnknownCharacter{CIRCULATION FUNCTION}" OPERATOR "CIRCULATION_FUNCTION")
   (?\u2A11 "\\FortressUnknownCharacter{ANTICLOCKWISE INTEGRATION}" OPERATOR "ANTICLOCKWISE_INTEGRATION")
   (?\u2A12 "\\FortressUnknownCharacter{LINE INTEGRATION WITH RECTANGULAR PATH AROUND POLE}" OPERATOR "LINE_INTEGRATION_WITH_RECTANGULAR_PATH_AROUND_POLE")
   (?\u2A13 "\\FortressUnknownCharacter{LINE INTEGRATION WITH SEMICIRCULAR PATH AROUND POLE}" OPERATOR "LINE_INTEGRATION_WITH_SEMICIRCULAR_PATH_AROUND_POLE")
   (?\u2A14 "\\FortressUnknownCharacter{LINE INTEGRATION NOT INCLUDING THE POLE}" OPERATOR "LINE_INTEGRATION_NOT_INCLUDING_THE_POLE")
   (?\u2A1D "\\Join" OPERATOR "JOIN")
   (?\u2A1E "\\FortressUnknownCharacter{LARGE LEFT TRIANGLE OPERATOR}" OPERATOR "LARGE_LEFT_TRIANGLE_OPERATOR")
   (?\u2A1F "\\FortressUnknownCharacter{Z NOTATION SCHEMA COMPOSITION}" OPERATOR "Z_NOTATION_SCHEMA_COMPOSITION")
   (?\u2A20 "\\FortressUnknownCharacter{Z NOTATION SCHEMA PIPING}" OPERATOR "Z_NOTATION_SCHEMA_PIPING")
   (?\u2A21 "\\FortressUnknownCharacter{Z NOTATION SCHEMA PROJECTION}" OPERATOR "Z_NOTATION_SCHEMA_PROJECTION")
   (?\u2A32 "\\FortressUnknownCharacter{SEMIDIRECT PRODUCT WITH BOTTOM CLOSED}" OPERATOR "SEMIDIRECT_PRODUCT_WITH_BOTTOM_CLOSED")
   (?\u2A33 "\\FortressUnknownCharacter{SMASH PRODUCT}" OPERATOR "SMASH_PRODUCT")
   (?\u2A3C "\\FortressUnknownCharacter{INTERIOR PRODUCT}" OPERATOR "INTERIOR_PRODUCT")
   (?\u2A3D "\\FortressUnknownCharacter{RIGHTHAND INTERIOR PRODUCT}" OPERATOR "RIGHTHAND_INTERIOR_PRODUCT")
   (?\u2A3E "\\FortressUnknownCharacter{Z NOTATION RELATIONAL COMPOSITION}" OPERATOR "Z_NOTATION_RELATIONAL_COMPOSITION")
   (?\u2A3F "\\FortressUnknownCharacter{AMALGAMATION OR COPRODUCT}" OPERATOR "AMALGAMATION_OR_COPRODUCT")
   (?\u2A57 "\\FortressUnknownCharacter{SLOPING LARGE OR}" OPERATOR "SLOPING_LARGE_OR")
   (?\u2A58 "\\FortressUnknownCharacter{SLOPING LARGE AND}" OPERATOR "SLOPING_LARGE_AND")
   (?\u2A61 "\\FortressUnknownCharacter{SMALL VEE WITH UNDERBAR}" OPERATOR "SMALL_VEE_WITH_UNDERBAR")
   (?\u2A64 "\\FortressUnknownCharacter{Z NOTATION DOMAIN ANTIRESTRICTION}" OPERATOR "Z_NOTATION_DOMAIN_ANTIRESTRICTION")
   (?\u2A65 "\\FortressUnknownCharacter{Z NOTATION RANGE ANTIRESTRICTION}" OPERATOR "Z_NOTATION_RANGE_ANTIRESTRICTION")
   (?\u2A68 "\\FortressUnknownCharacter{TRIPLE HORIZONTAL BAR WITH DOUBLE VERTICAL STROKE}" OPERATOR "TRIPLE_HORIZONTAL_BAR_WITH_DOUBLE_VERTICAL_STROKE")
   (?\u2A69 "\\FortressUnknownCharacter{TRIPLE HORIZONTAL BAR WITH TRIPLE VERTICAL STROKE}" OPERATOR "TRIPLE_HORIZONTAL_BAR_WITH_TRIPLE_VERTICAL_STROKE")
   (?\u2A6A "\\FortressUnknownCharacter{TILDE OPERATOR WITH DOT ABOVE}" OPERATOR "TILDE_OPERATOR_WITH_DOT_ABOVE")
   (?\u2A6B "\\FortressUnknownCharacter{TILDE OPERATOR WITH RISING DOTS}" OPERATOR "TILDE_OPERATOR_WITH_RISING_DOTS")
   (?\u2A6D "\\FortressUnknownCharacter{CONGRUENT WITH DOT ABOVE}" OPERATOR "CONGRUENT_WITH_DOT_ABOVE")
   (?\u2ACD "\\FortressUnknownCharacter{SQUARE LEFT OPEN BOX OPERATOR}" OPERATOR "SQUARE_LEFT_OPEN_BOX_OPERATOR")
   (?\u2ACE "\\FortressUnknownCharacter{SQUARE RIGHT OPEN BOX OPERATOR}" OPERATOR "SQUARE_RIGHT_OPEN_BOX_OPERATOR")
   (?\u2AD9 "\\FortressUnknownCharacter{ELEMENT OF OPENING DOWNWARDS}" OPERATOR "ELEMENT_OF_OPENING_DOWNWARDS")
   (?\u2ADA "\\FortressUnknownCharacter{PITCHFORK WITH TEE TOP}" OPERATOR "PITCHFORK_WITH_TEE_TOP")
   (?\u2ADC "\\FortressUnknownCharacter{!FORKING}" OPERATOR "FORKING")
   (?\u2ADD "\\FortressUnknownCharacter{!NONFORKING}" OPERATOR "NONFORKING")
   (?\u2ADE "\\FortressUnknownCharacter{SHORT LEFT TACK}" OPERATOR "SHORT_LEFT_TACK")
   (?\u2ADF "\\FortressUnknownCharacter{SHORT DOWN TACK}" OPERATOR "SHORT_DOWN_TACK")
   (?\u2AE0 "\\FortressUnknownCharacter{SHORT UP TACK}" OPERATOR "SHORT_UP_TACK")
   (?\u2AE1 "\\FortressUnknownCharacter{PERPENDICULAR WITH S}" OPERATOR "PERPENDICULAR_WITH_S")
   (?\u2AE2 "\\FortressUnknownCharacter{VERTICAL BAR TRIPLE RIGHT TURNSTILE}" OPERATOR "VERTICAL_BAR_TRIPLE_RIGHT_TURNSTILE")
   (?\u2AE3 "\\FortressUnknownCharacter{DOUBLE VERTICAL BAR LEFT TURNSTILE}" OPERATOR "DOUBLE_VERTICAL_BAR_LEFT_TURNSTILE")
   (?\u2AE4 "\\FortressUnknownCharacter{VERTICAL BAR DOUBLE LEFT TURNSTILE}" OPERATOR "VERTICAL_BAR_DOUBLE_LEFT_TURNSTILE")
   (?\u2AE5 "\\FortressUnknownCharacter{DOUBLE VERTICAL BAR DOUBLE LEFT TURNSTILE}" OPERATOR "DOUBLE_VERTICAL_BAR_DOUBLE_LEFT_TURNSTILE")
   (?\u2AE6 "\\FortressUnknownCharacter{LONG DASH FROM LEFT MEMBER OF DOUBLE VERTICAL}" OPERATOR "LONG_DASH_FROM_LEFT_MEMBER_OF_DOUBLE_VERTICAL")
   (?\u2AE7 "\\FortressUnknownCharacter{SHORT DOWN TACK WITH OVERBAR}" OPERATOR "SHORT_DOWN_TACK_WITH_OVERBAR")
   (?\u2AE8 "\\FortressUnknownCharacter{SHORT UP TACK WITH UNDERBAR}" OPERATOR "SHORT_UP_TACK_WITH_UNDERBAR")
   (?\u2AE9 "\\FortressUnknownCharacter{SHORT UP TACK ABOVE SHORT DOWN TACK}" OPERATOR "SHORT_UP_TACK_ABOVE_SHORT_DOWN_TACK")
   (?\u2AEA "\\FortressUnknownCharacter{DOUBLE DOWN TACK}" OPERATOR "DOUBLE_DOWN_TACK")
   (?\u2AEB "\\FortressUnknownCharacter{DOUBLE UP TACK}" OPERATOR "DOUBLE_UP_TACK")
   (?\u2AEC "\\FortressUnknownCharacter{DOUBLE STROKE NOT SIGN}" OPERATOR "DOUBLE_STROKE_NOT_SIGN")
   (?\u2AED "\\FortressUnknownCharacter{REVERSED DOUBLE STROKE NOT SIGN}" OPERATOR "REVERSED_DOUBLE_STROKE_NOT_SIGN")
   (?\u2AEE "\\FortressUnknownCharacter{DOES NOT DIVIDE WITH REVERSED NEGATION SLASH}" OPERATOR "DOES_NOT_DIVIDE_WITH_REVERSED_NEGATION_SLASH")
   (?\u2AEF "\\FortressUnknownCharacter{VERTICAL LINE WITH CIRCLE ABOVE}" OPERATOR "VERTICAL_LINE_WITH_CIRCLE_ABOVE")
   (?\u2AF0 "\\FortressUnknownCharacter{VERTICAL LINE WITH CIRCLE BELOW}" OPERATOR "VERTICAL_LINE_WITH_CIRCLE_BELOW")
   (?\u2AF1 "\\FortressUnknownCharacter{DOWN TACK WITH CIRCLE BELOW}" OPERATOR "DOWN_TACK_WITH_CIRCLE_BELOW")
   (?\u2AF2 "\\FortressUnknownCharacter{PARALLEL WITH HORIZONTAL STROKE}" OPERATOR "PARALLEL_WITH_HORIZONTAL_STROKE")
   (?\u2AF3 "\\FortressUnknownCharacter{PARALLEL WITH TILDE OPERATOR}" OPERATOR "PARALLEL_WITH_TILDE_OPERATOR")
   (?\u2AF5 "\\FortressUnknownCharacter{TRIPLE VERTICAL BAR WITH HORIZONTAL STROKE}" OPERATOR "TRIPLE_VERTICAL_BAR_WITH_HORIZONTAL_STROKE")
   (?\u2AF6 "\\FortressUnknownCharacter{TRIPLE COLON OPERATOR}" OPERATOR "TRIPLE_COLON_OPERATOR")
   (?\u2AFC "\\FortressUnknownCharacter{LARGE TRIPLE VERTICAL BAR OPERATOR}" OPERATOR "LARGE_TRIPLE_VERTICAL_BAR_OPERATOR")
   (?\u2AFE "\\FortressUnknownCharacter{WHITE VERTICAL BAR}" OPERATOR "WHITE_VERTICAL_BAR")
   (?\u2AFF "\\FortressUnknownCharacter{N ARY WHITE VERTICAL BAR}" BIGOP "N_ARY_WHITE_VERTICAL_BAR")
   (none "\\upplus" OPERATOR "UPPLUS")
   (none "\\upminus" OPERATOR "UPMINUS")
   (none "\\uptimes" OPERATOR "UPTIMES")
   (none "\\updot" OPERATOR "UPDOT")
   (none "\\upslash" OPERATOR "UPSLASH")
   (none "\\downplus" OPERATOR "DOWNPLUS")
   (none "\\downminus" OPERATOR "DOWNMINUS")
   (none "\\downtimes" OPERATOR "DOWNTIMES")
   (none "\\downdot" OPERATOR "DOWNDOT")
   (none "\\downslash" OPERATOR "DOWNSLASH")
   (none "\\chopplus" OPERATOR "CHOPPLUS")
   (none "\\chopminus" OPERATOR "CHOPMINUS")
   (none "\\choptimes" OPERATOR "CHOPTIMES")
   (none "\\chopdot" OPERATOR "CHOPDOT")
   (none "\\chopslash" OPERATOR "CHOPSLASH")
   (none "\\exactplus" OPERATOR "EXACTPLUS")
   (none "\\exactminus" OPERATOR "EXACTMINUS")
   (none "\\exacttimes" OPERATOR "EXACTTIMES")
   (none "\\exactdot" OPERATOR "EXACTDOT")
   (none "\\exactslash" OPERATOR "EXACTSLASH")
   ))



(setq *fortress-left-encloser-hashtable* (make-hash-table :test 'equal))
(setq *fortress-right-encloser-hashtable* (make-hash-table :test 'equal))
(setq *fortress-encloser-match-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-matched-hashtables
 *fortress-left-encloser-hashtable*
 *fortress-right-encloser-hashtable*
 *fortress-encloser-match-hashtable*
 '((("{" "\\lbrace") ("}" "\\rbrace"))
   (("<|" "\\langle") ("|>" "\\rangle"))
   ((?\u27E8 "\\langle") (?\u27E9 "\\rangle"))
   (("<||" "\\langle\\mskip-5mu\\langle") ("||>" "\\rangle\\mskip-5mu\\rangle"))
   ((?\u27EA "\\langle\\!\\langle") (?\u27EB "\\rangle\\!\\rangle"))
   (("</" "\\ulcorner") ("\\>" "\\urcorner"))
   (("<\\" "\\llcorner") ("/>" "\\lrcorner"))
   (("|\\" "\\lfloor") ("/|" "\\rfloor"))
   ((?\u230A "\\lfloor") (?\u230B "\\rfloor"))
   (("|/" "\\lceil") ("\\|" "\\rceil"))
   ((?\u2308 "\\lceil") (?\u2309 "\\rceil"))
   (("||\\" "\\lhfloor") ("/||" "\\rhfloor"))
   (("||/" "\\lhceil") ("\\||" "\\rhceil"))
   (("|||\\" "\\lhhfloor") ("/|||" "\\rhhfloor"))
   (("|||/" "\\lhhceil") ("\\|||" "\\rhhceil"))
   (("|" "\\mathopen{\\vert}") ("|" "\\mathclose{\\vert}"))
   (("||" "\\mathopen{\\Vert}") ("||" "\\mathclose{\\Vert}"))
   (("|||" "\\mathopen{\\Vvert}") ("|||" "\\mathclose{\\Vvert}"))
   (("||||" "\\mathopen{\\VVert}") ("||||" "\\mathclose{\\VVert}"))
   ))

(setq *fortress-bracket-resize-hashtable* (make-hash-table :test 'equal))

(fortress-initialize-hashtable-pairs
 *fortress-bracket-resize-hashtable*
 '(((LEFT-PARENTHESIS "(") ("\\left(" "\\bigl(" "\\Bigl(" "\\biggl(" "\\Biggl("))
   ((RIGHT-PARENTHESIS ")") ("\\right)" "\\bigr)" "\\Bigr)" "\\biggr)" "\\Biggr)"))
   ((LEFT-BRACKET "[") ("\\left[" "\\bigl[" "\\Bigl[" "\\biggl[" "\\Biggl["))
   ((RIGHT-BRACKET "]") ("\\right]" "\\bigr]" "\\Bigr]" "\\biggr]" "\\Biggr]"))
   ((LEFT-ENCLOSER "\\langle") ("\\left\\langle" "\\bigl\\langle" "\\Bigl\\langle" "\\biggl\\langle" "\\Biggl\\langle"))
   ((RIGHT-ENCLOSER "\\rangle") ("\\right\\rangle" "\\bigr\\rangle" "\\Bigr\\rangle" "\\biggr\\rangle" "\\Biggr\\rangle"))
   ((LEFT-ENCLOSER "\\lbrace") ("\\left\\lbrace" "\\bigl\\lbrace" "\\Bigl\\lbrace" "\\biggl\\lbrace" "\\Biggl\\lbrace"))
   ((RIGHT-ENCLOSER "\\rbrace") ("\\right\\rbrace" "\\bigr\\rbrace" "\\Bigr\\rbrace" "\\biggr\\rbrace" "\\Biggr\\rbrace"))
   ((LEFT-WHITE-BRACKET "\\llbracket") ("\\leftllbracket" "\\bigllbracket" "\\Bigllbracket" "\\biggllbracket" "\\Biggllbracket"))
   ((RIGHT-WHITE-BRACKET "\\rrbracket") ("\\leftrrbracket" "\\bigrrbracket" "\\Bigrrbracket" "\\biggrrbracket" "\\Biggrrbracket"))
   ((OPERATOR "\\mid") ("\\right|" "\\bigm|" "\\Bigm|" "\\biggm|" "\\Biggm|"))
   ((LEFT-ENCLOSER "\\mathopen{\\vert}") ("\\left\\vert" "\\bigl\\vert" "\\Bigl\\vert" "\\biggl\\vert" "\\Biggl\\vert"))
   ((RIGHT-ENCLOSER "\\mathclose{\\vert}") ("\\right\\vert" "\\bigr\\vert" "\\Bigr\\vert" "\\biggr\\vert" "\\Biggr\\vert"))
   ((LEFT-ENCLOSER "\\mathopen{\\Vert}") ("\\left\\Vert" "\\bigl\\Vert" "\\Bigl\\Vert" "\\biggl\\Vert" "\\Biggl\\Vert"))
   ((RIGHT-ENCLOSER "\\mathclose{\\Vert}") ("\\right\\Vert" "\\bigr\\Vert" "\\Bigr\\Vert" "\\biggr\\Vert" "\\Biggr\\Vert"))
   ((LEFT-ENCLOSER "\\lfloor") ("\\left\\lfloor" "\\bigl\\lfloor" "\\Bigl\\lfloor" "\\biggl\\lfloor" "\\Biggl\\lfloor"))
   ((RIGHT-ENCLOSER "\\rfloor") ("\\right\\rfloor" "\\bigr\\rfloor" "\\Bigr\\rfloor" "\\biggr\\rfloor" "\\Biggr\\rfloor"))
   ((LEFT-ENCLOSER "\\lceil") ("\\left\\lceil" "\\bigl\\lceil" "\\Bigl\\lceil" "\\biggl\\lceil" "\\Biggl\\lceil"))
   ((RIGHT-ENCLOSER "\\rceil") ("\\right\\rceil" "\\bigr\\rceil" "\\Bigr\\rceil" "\\biggr\\rceil" "\\Biggr\\rceil"))
   ))

(defun ascii-is-uppercase (c)
  (and (<= ?A c) (<= c ?Z)))

(defun ascii-is-letter (c)
  (or (and (<= ?A c) (<= c ?Z))
      (and (<= ?a c) (<= c ?z))))

(defun ascii-is-digit (c)
  (and (<= ?0 c) (<= c ?9)))

;;; The following definitions were built from Unicode data file
;;; UnicodeData.txt for version 5.1.0.

(defun unicode-is-uppercase (char)
  (cond ((<= char #x7f)
	 (and (<= #x41 char) (<= char #x5a)))
	(t (let ((c (encode-char char 'ucs)))
	     (or (and (<= #xc0 c) (<= c #xd6))
		 (and (<= #xd8 c) (<= c #xde))
		 (= c #x100)
		 (= c #x102)
		 (= c #x104)
		 (= c #x106)
		 (= c #x108)
		 (= c #x10a)
		 (= c #x10c)
		 (= c #x10e)
		 (= c #x110)
		 (= c #x112)
		 (= c #x114)
		 (= c #x116)
		 (= c #x118)
		 (= c #x11a)
		 (= c #x11c)
		 (= c #x11e)
		 (= c #x120)
		 (= c #x122)
		 (= c #x124)
		 (= c #x126)
		 (= c #x128)
		 (= c #x12a)
		 (= c #x12c)
		 (= c #x12e)
		 (= c #x130)
		 (= c #x132)
		 (= c #x134)
		 (= c #x136)
		 (= c #x139)
		 (= c #x13b)
		 (= c #x13d)
		 (= c #x13f)
		 (= c #x141)
		 (= c #x143)
		 (= c #x145)
		 (= c #x147)
		 (= c #x14a)
		 (= c #x14c)
		 (= c #x14e)
		 (= c #x150)
		 (= c #x152)
		 (= c #x154)
		 (= c #x156)
		 (= c #x158)
		 (= c #x15a)
		 (= c #x15c)
		 (= c #x15e)
		 (= c #x160)
		 (= c #x162)
		 (= c #x164)
		 (= c #x166)
		 (= c #x168)
		 (= c #x16a)
		 (= c #x16c)
		 (= c #x16e)
		 (= c #x170)
		 (= c #x172)
		 (= c #x174)
		 (= c #x176)
		 (and (<= #x178 c) (<= c #x179))
		 (= c #x17b)
		 (= c #x17d)
		 (and (<= #x181 c) (<= c #x182))
		 (= c #x184)
		 (and (<= #x186 c) (<= c #x187))
		 (and (<= #x189 c) (<= c #x18b))
		 (and (<= #x18e c) (<= c #x191))
		 (and (<= #x193 c) (<= c #x194))
		 (and (<= #x196 c) (<= c #x198))
		 (and (<= #x19c c) (<= c #x19d))
		 (and (<= #x19f c) (<= c #x1a0))
		 (= c #x1a2)
		 (= c #x1a4)
		 (and (<= #x1a6 c) (<= c #x1a7))
		 (= c #x1a9)
		 (= c #x1ac)
		 (and (<= #x1ae c) (<= c #x1af))
		 (and (<= #x1b1 c) (<= c #x1b3))
		 (= c #x1b5)
		 (and (<= #x1b7 c) (<= c #x1b8))
		 (= c #x1bc)
		 (= c #x1c4)
		 (= c #x1c7)
		 (= c #x1ca)
		 (= c #x1cd)
		 (= c #x1cf)
		 (= c #x1d1)
		 (= c #x1d3)
		 (= c #x1d5)
		 (= c #x1d7)
		 (= c #x1d9)
		 (= c #x1db)
		 (= c #x1de)
		 (= c #x1e0)
		 (= c #x1e2)
		 (= c #x1e4)
		 (= c #x1e6)
		 (= c #x1e8)
		 (= c #x1ea)
		 (= c #x1ec)
		 (= c #x1ee)
		 (= c #x1f1)
		 (= c #x1f4)
		 (and (<= #x1f6 c) (<= c #x1f8))
		 (= c #x1fa)
		 (= c #x1fc)
		 (= c #x1fe)
		 (= c #x200)
		 (= c #x202)
		 (= c #x204)
		 (= c #x206)
		 (= c #x208)
		 (= c #x20a)
		 (= c #x20c)
		 (= c #x20e)
		 (= c #x210)
		 (= c #x212)
		 (= c #x214)
		 (= c #x216)
		 (= c #x218)
		 (= c #x21a)
		 (= c #x21c)
		 (= c #x21e)
		 (= c #x220)
		 (= c #x222)
		 (= c #x224)
		 (= c #x226)
		 (= c #x228)
		 (= c #x22a)
		 (= c #x22c)
		 (= c #x22e)
		 (= c #x230)
		 (= c #x232)
		 (and (<= #x23a c) (<= c #x23b))
		 (and (<= #x23d c) (<= c #x23e))
		 (= c #x241)
		 (and (<= #x243 c) (<= c #x246))
		 (= c #x248)
		 (= c #x24a)
		 (= c #x24c)
		 (= c #x24e)
		 (= c #x370)
		 (= c #x372)
		 (= c #x376)
		 (= c #x386)
		 (and (<= #x388 c) (<= c #x38a))
		 (= c #x38c)
		 (and (<= #x38e c) (<= c #x38f))
		 (and (<= #x391 c) (<= c #x3a1))
		 (and (<= #x3a3 c) (<= c #x3ab))
		 (= c #x3cf)
		 (and (<= #x3d2 c) (<= c #x3d4))
		 (= c #x3d8)
		 (= c #x3da)
		 (= c #x3dc)
		 (= c #x3de)
		 (= c #x3e0)
		 (= c #x3e2)
		 (= c #x3e4)
		 (= c #x3e6)
		 (= c #x3e8)
		 (= c #x3ea)
		 (= c #x3ec)
		 (= c #x3ee)
		 (= c #x3f4)
		 (= c #x3f7)
		 (and (<= #x3f9 c) (<= c #x3fa))
		 (and (<= #x3fd c) (<= c #x42f))
		 (= c #x460)
		 (= c #x462)
		 (= c #x464)
		 (= c #x466)
		 (= c #x468)
		 (= c #x46a)
		 (= c #x46c)
		 (= c #x46e)
		 (= c #x470)
		 (= c #x472)
		 (= c #x474)
		 (= c #x476)
		 (= c #x478)
		 (= c #x47a)
		 (= c #x47c)
		 (= c #x47e)
		 (= c #x480)
		 (= c #x48a)
		 (= c #x48c)
		 (= c #x48e)
		 (= c #x490)
		 (= c #x492)
		 (= c #x494)
		 (= c #x496)
		 (= c #x498)
		 (= c #x49a)
		 (= c #x49c)
		 (= c #x49e)
		 (= c #x4a0)
		 (= c #x4a2)
		 (= c #x4a4)
		 (= c #x4a6)
		 (= c #x4a8)
		 (= c #x4aa)
		 (= c #x4ac)
		 (= c #x4ae)
		 (= c #x4b0)
		 (= c #x4b2)
		 (= c #x4b4)
		 (= c #x4b6)
		 (= c #x4b8)
		 (= c #x4ba)
		 (= c #x4bc)
		 (= c #x4be)
		 (and (<= #x4c0 c) (<= c #x4c1))
		 (= c #x4c3)
		 (= c #x4c5)
		 (= c #x4c7)
		 (= c #x4c9)
		 (= c #x4cb)
		 (= c #x4cd)
		 (= c #x4d0)
		 (= c #x4d2)
		 (= c #x4d4)
		 (= c #x4d6)
		 (= c #x4d8)
		 (= c #x4da)
		 (= c #x4dc)
		 (= c #x4de)
		 (= c #x4e0)
		 (= c #x4e2)
		 (= c #x4e4)
		 (= c #x4e6)
		 (= c #x4e8)
		 (= c #x4ea)
		 (= c #x4ec)
		 (= c #x4ee)
		 (= c #x4f0)
		 (= c #x4f2)
		 (= c #x4f4)
		 (= c #x4f6)
		 (= c #x4f8)
		 (= c #x4fa)
		 (= c #x4fc)
		 (= c #x4fe)
		 (= c #x500)
		 (= c #x502)
		 (= c #x504)
		 (= c #x506)
		 (= c #x508)
		 (= c #x50a)
		 (= c #x50c)
		 (= c #x50e)
		 (= c #x510)
		 (= c #x512)
		 (= c #x514)
		 (= c #x516)
		 (= c #x518)
		 (= c #x51a)
		 (= c #x51c)
		 (= c #x51e)
		 (= c #x520)
		 (= c #x522)
		 (and (<= #x531 c) (<= c #x556))
		 (and (<= #x10a0 c) (<= c #x10c5))
		 (= c #x1e00)
		 (= c #x1e02)
		 (= c #x1e04)
		 (= c #x1e06)
		 (= c #x1e08)
		 (= c #x1e0a)
		 (= c #x1e0c)
		 (= c #x1e0e)
		 (= c #x1e10)
		 (= c #x1e12)
		 (= c #x1e14)
		 (= c #x1e16)
		 (= c #x1e18)
		 (= c #x1e1a)
		 (= c #x1e1c)
		 (= c #x1e1e)
		 (= c #x1e20)
		 (= c #x1e22)
		 (= c #x1e24)
		 (= c #x1e26)
		 (= c #x1e28)
		 (= c #x1e2a)
		 (= c #x1e2c)
		 (= c #x1e2e)
		 (= c #x1e30)
		 (= c #x1e32)
		 (= c #x1e34)
		 (= c #x1e36)
		 (= c #x1e38)
		 (= c #x1e3a)
		 (= c #x1e3c)
		 (= c #x1e3e)
		 (= c #x1e40)
		 (= c #x1e42)
		 (= c #x1e44)
		 (= c #x1e46)
		 (= c #x1e48)
		 (= c #x1e4a)
		 (= c #x1e4c)
		 (= c #x1e4e)
		 (= c #x1e50)
		 (= c #x1e52)
		 (= c #x1e54)
		 (= c #x1e56)
		 (= c #x1e58)
		 (= c #x1e5a)
		 (= c #x1e5c)
		 (= c #x1e5e)
		 (= c #x1e60)
		 (= c #x1e62)
		 (= c #x1e64)
		 (= c #x1e66)
		 (= c #x1e68)
		 (= c #x1e6a)
		 (= c #x1e6c)
		 (= c #x1e6e)
		 (= c #x1e70)
		 (= c #x1e72)
		 (= c #x1e74)
		 (= c #x1e76)
		 (= c #x1e78)
		 (= c #x1e7a)
		 (= c #x1e7c)
		 (= c #x1e7e)
		 (= c #x1e80)
		 (= c #x1e82)
		 (= c #x1e84)
		 (= c #x1e86)
		 (= c #x1e88)
		 (= c #x1e8a)
		 (= c #x1e8c)
		 (= c #x1e8e)
		 (= c #x1e90)
		 (= c #x1e92)
		 (= c #x1e94)
		 (= c #x1e9e)
		 (= c #x1ea0)
		 (= c #x1ea2)
		 (= c #x1ea4)
		 (= c #x1ea6)
		 (= c #x1ea8)
		 (= c #x1eaa)
		 (= c #x1eac)
		 (= c #x1eae)
		 (= c #x1eb0)
		 (= c #x1eb2)
		 (= c #x1eb4)
		 (= c #x1eb6)
		 (= c #x1eb8)
		 (= c #x1eba)
		 (= c #x1ebc)
		 (= c #x1ebe)
		 (= c #x1ec0)
		 (= c #x1ec2)
		 (= c #x1ec4)
		 (= c #x1ec6)
		 (= c #x1ec8)
		 (= c #x1eca)
		 (= c #x1ecc)
		 (= c #x1ece)
		 (= c #x1ed0)
		 (= c #x1ed2)
		 (= c #x1ed4)
		 (= c #x1ed6)
		 (= c #x1ed8)
		 (= c #x1eda)
		 (= c #x1edc)
		 (= c #x1ede)
		 (= c #x1ee0)
		 (= c #x1ee2)
		 (= c #x1ee4)
		 (= c #x1ee6)
		 (= c #x1ee8)
		 (= c #x1eea)
		 (= c #x1eec)
		 (= c #x1eee)
		 (= c #x1ef0)
		 (= c #x1ef2)
		 (= c #x1ef4)
		 (= c #x1ef6)
		 (= c #x1ef8)
		 (= c #x1efa)
		 (= c #x1efc)
		 (= c #x1efe)
		 (and (<= #x1f08 c) (<= c #x1f0f))
		 (and (<= #x1f18 c) (<= c #x1f1d))
		 (and (<= #x1f28 c) (<= c #x1f2f))
		 (and (<= #x1f38 c) (<= c #x1f3f))
		 (and (<= #x1f48 c) (<= c #x1f4d))
		 (= c #x1f59)
		 (= c #x1f5b)
		 (= c #x1f5d)
		 (= c #x1f5f)
		 (and (<= #x1f68 c) (<= c #x1f6f))
		 (and (<= #x1fb8 c) (<= c #x1fbb))
		 (and (<= #x1fc8 c) (<= c #x1fcb))
		 (and (<= #x1fd8 c) (<= c #x1fdb))
		 (and (<= #x1fe8 c) (<= c #x1fec))
		 (and (<= #x1ff8 c) (<= c #x1ffb))
		 (= c #x2102)
		 (= c #x2107)
		 (and (<= #x210b c) (<= c #x210d))
		 (and (<= #x2110 c) (<= c #x2112))
		 (= c #x2115)
		 (and (<= #x2119 c) (<= c #x211d))
		 (= c #x2124)
		 (= c #x2126)
		 (= c #x2128)
		 (and (<= #x212a c) (<= c #x212d))
		 (and (<= #x2130 c) (<= c #x2133))
		 (and (<= #x213e c) (<= c #x213f))
		 (= c #x2145)
		 (= c #x2183)
		 (and (<= #x2c00 c) (<= c #x2c2e))
		 (= c #x2c60)
		 (and (<= #x2c62 c) (<= c #x2c64))
		 (= c #x2c67)
		 (= c #x2c69)
		 (= c #x2c6b)
		 (and (<= #x2c6d c) (<= c #x2c6f))
		 (= c #x2c72)
		 (= c #x2c75)
		 (= c #x2c80)
		 (= c #x2c82)
		 (= c #x2c84)
		 (= c #x2c86)
		 (= c #x2c88)
		 (= c #x2c8a)
		 (= c #x2c8c)
		 (= c #x2c8e)
		 (= c #x2c90)
		 (= c #x2c92)
		 (= c #x2c94)
		 (= c #x2c96)
		 (= c #x2c98)
		 (= c #x2c9a)
		 (= c #x2c9c)
		 (= c #x2c9e)
		 (= c #x2ca0)
		 (= c #x2ca2)
		 (= c #x2ca4)
		 (= c #x2ca6)
		 (= c #x2ca8)
		 (= c #x2caa)
		 (= c #x2cac)
		 (= c #x2cae)
		 (= c #x2cb0)
		 (= c #x2cb2)
		 (= c #x2cb4)
		 (= c #x2cb6)
		 (= c #x2cb8)
		 (= c #x2cba)
		 (= c #x2cbc)
		 (= c #x2cbe)
		 (= c #x2cc0)
		 (= c #x2cc2)
		 (= c #x2cc4)
		 (= c #x2cc6)
		 (= c #x2cc8)
		 (= c #x2cca)
		 (= c #x2ccc)
		 (= c #x2cce)
		 (= c #x2cd0)
		 (= c #x2cd2)
		 (= c #x2cd4)
		 (= c #x2cd6)
		 (= c #x2cd8)
		 (= c #x2cda)
		 (= c #x2cdc)
		 (= c #x2cde)
		 (= c #x2ce0)
		 (= c #x2ce2)
		 (= c #xa640)
		 (= c #xa642)
		 (= c #xa644)
		 (= c #xa646)
		 (= c #xa648)
		 (= c #xa64a)
		 (= c #xa64c)
		 (= c #xa64e)
		 (= c #xa650)
		 (= c #xa652)
		 (= c #xa654)
		 (= c #xa656)
		 (= c #xa658)
		 (= c #xa65a)
		 (= c #xa65c)
		 (= c #xa65e)
		 (= c #xa662)
		 (= c #xa664)
		 (= c #xa666)
		 (= c #xa668)
		 (= c #xa66a)
		 (= c #xa66c)
		 (= c #xa680)
		 (= c #xa682)
		 (= c #xa684)
		 (= c #xa686)
		 (= c #xa688)
		 (= c #xa68a)
		 (= c #xa68c)
		 (= c #xa68e)
		 (= c #xa690)
		 (= c #xa692)
		 (= c #xa694)
		 (= c #xa696)
		 (= c #xa722)
		 (= c #xa724)
		 (= c #xa726)
		 (= c #xa728)
		 (= c #xa72a)
		 (= c #xa72c)
		 (= c #xa72e)
		 (= c #xa732)
		 (= c #xa734)
		 (= c #xa736)
		 (= c #xa738)
		 (= c #xa73a)
		 (= c #xa73c)
		 (= c #xa73e)
		 (= c #xa740)
		 (= c #xa742)
		 (= c #xa744)
		 (= c #xa746)
		 (= c #xa748)
		 (= c #xa74a)
		 (= c #xa74c)
		 (= c #xa74e)
		 (= c #xa750)
		 (= c #xa752)
		 (= c #xa754)
		 (= c #xa756)
		 (= c #xa758)
		 (= c #xa75a)
		 (= c #xa75c)
		 (= c #xa75e)
		 (= c #xa760)
		 (= c #xa762)
		 (= c #xa764)
		 (= c #xa766)
		 (= c #xa768)
		 (= c #xa76a)
		 (= c #xa76c)
		 (= c #xa76e)
		 (= c #xa779)
		 (= c #xa77b)
		 (and (<= #xa77d c) (<= c #xa77e))
		 (= c #xa780)
		 (= c #xa782)
		 (= c #xa784)
		 (= c #xa786)
		 (= c #xa78b)
		 (and (<= #xff21 c) (<= c #xff3a))
		 (and (<= #x10400 c) (<= c #x10427))
		 (and (<= #x1d400 c) (<= c #x1d419))
		 (and (<= #x1d434 c) (<= c #x1d44d))
		 (and (<= #x1d468 c) (<= c #x1d481))
		 (= c #x1d49c)
		 (and (<= #x1d49e c) (<= c #x1d49f))
		 (= c #x1d4a2)
		 (and (<= #x1d4a5 c) (<= c #x1d4a6))
		 (and (<= #x1d4a9 c) (<= c #x1d4ac))
		 (and (<= #x1d4ae c) (<= c #x1d4b5))
		 (and (<= #x1d4d0 c) (<= c #x1d4e9))
		 (and (<= #x1d504 c) (<= c #x1d505))
		 (and (<= #x1d507 c) (<= c #x1d50a))
		 (and (<= #x1d50d c) (<= c #x1d514))
		 (and (<= #x1d516 c) (<= c #x1d51c))
		 (and (<= #x1d538 c) (<= c #x1d539))
		 (and (<= #x1d53b c) (<= c #x1d53e))
		 (and (<= #x1d540 c) (<= c #x1d544))
		 (= c #x1d546)
		 (and (<= #x1d54a c) (<= c #x1d550))
		 (and (<= #x1d56c c) (<= c #x1d585))
		 (and (<= #x1d5a0 c) (<= c #x1d5b9))
		 (and (<= #x1d5d4 c) (<= c #x1d5ed))
		 (and (<= #x1d608 c) (<= c #x1d621))
		 (and (<= #x1d63c c) (<= c #x1d655))
		 (and (<= #x1d670 c) (<= c #x1d689))
		 (and (<= #x1d6a8 c) (<= c #x1d6c0))
		 (and (<= #x1d6e2 c) (<= c #x1d6fa))
		 (and (<= #x1d71c c) (<= c #x1d734))
		 (and (<= #x1d756 c) (<= c #x1d76e))
		 (and (<= #x1d790 c) (<= c #x1d7a8))
		 (= c #x1d7ca))))))

(defun unicode-is-letter (char)
  (cond ((<= char #x7f)
	 (or (and (<= #x41 char) (<= char #x5a))
	     (and (<= #x61 char) (<= char #x7a))))
	(t (let ((c (encode-char char 'ucs)))
	     (or (= c #xaa)
		 (= c #xb5)
		 (= c #xba)
		 (and (<= #xc0 c) (<= c #xd6))
		 (and (<= #xd8 c) (<= c #xf6))
		 (and (<= #xf8 c) (<= c #x2c1))
		 (and (<= #x2c6 c) (<= c #x2d1))
		 (and (<= #x2e0 c) (<= c #x2e4))
		 (= c #x2ec)
		 (= c #x2ee)
		 (and (<= #x370 c) (<= c #x374))
		 (and (<= #x376 c) (<= c #x377))
		 (and (<= #x37a c) (<= c #x37d))
		 (= c #x386)
		 (and (<= #x388 c) (<= c #x38a))
		 (= c #x38c)
		 (and (<= #x38e c) (<= c #x3a1))
		 (and (<= #x3a3 c) (<= c #x3f5))
		 (and (<= #x3f7 c) (<= c #x481))
		 (and (<= #x48a c) (<= c #x523))
		 (and (<= #x531 c) (<= c #x556))
		 (= c #x559)
		 (and (<= #x561 c) (<= c #x587))
		 (and (<= #x5d0 c) (<= c #x5ea))
		 (and (<= #x5f0 c) (<= c #x5f2))
		 (and (<= #x621 c) (<= c #x64a))
		 (and (<= #x66e c) (<= c #x66f))
		 (and (<= #x671 c) (<= c #x6d3))
		 (= c #x6d5)
		 (and (<= #x6e5 c) (<= c #x6e6))
		 (and (<= #x6ee c) (<= c #x6ef))
		 (and (<= #x6fa c) (<= c #x6fc))
		 (= c #x6ff)
		 (= c #x710)
		 (and (<= #x712 c) (<= c #x72f))
		 (and (<= #x74d c) (<= c #x7a5))
		 (= c #x7b1)
		 (and (<= #x7ca c) (<= c #x7ea))
		 (and (<= #x7f4 c) (<= c #x7f5))
		 (= c #x7fa)
		 (and (<= #x904 c) (<= c #x939))
		 (= c #x93d)
		 (= c #x950)
		 (and (<= #x958 c) (<= c #x961))
		 (and (<= #x971 c) (<= c #x972))
		 (and (<= #x97b c) (<= c #x97f))
		 (and (<= #x985 c) (<= c #x98c))
		 (and (<= #x98f c) (<= c #x990))
		 (and (<= #x993 c) (<= c #x9a8))
		 (and (<= #x9aa c) (<= c #x9b0))
		 (= c #x9b2)
		 (and (<= #x9b6 c) (<= c #x9b9))
		 (= c #x9bd)
		 (= c #x9ce)
		 (and (<= #x9dc c) (<= c #x9dd))
		 (and (<= #x9df c) (<= c #x9e1))
		 (and (<= #x9f0 c) (<= c #x9f1))
		 (and (<= #xa05 c) (<= c #xa0a))
		 (and (<= #xa0f c) (<= c #xa10))
		 (and (<= #xa13 c) (<= c #xa28))
		 (and (<= #xa2a c) (<= c #xa30))
		 (and (<= #xa32 c) (<= c #xa33))
		 (and (<= #xa35 c) (<= c #xa36))
		 (and (<= #xa38 c) (<= c #xa39))
		 (and (<= #xa59 c) (<= c #xa5c))
		 (= c #xa5e)
		 (and (<= #xa72 c) (<= c #xa74))
		 (and (<= #xa85 c) (<= c #xa8d))
		 (and (<= #xa8f c) (<= c #xa91))
		 (and (<= #xa93 c) (<= c #xaa8))
		 (and (<= #xaaa c) (<= c #xab0))
		 (and (<= #xab2 c) (<= c #xab3))
		 (and (<= #xab5 c) (<= c #xab9))
		 (= c #xabd)
		 (= c #xad0)
		 (and (<= #xae0 c) (<= c #xae1))
		 (and (<= #xb05 c) (<= c #xb0c))
		 (and (<= #xb0f c) (<= c #xb10))
		 (and (<= #xb13 c) (<= c #xb28))
		 (and (<= #xb2a c) (<= c #xb30))
		 (and (<= #xb32 c) (<= c #xb33))
		 (and (<= #xb35 c) (<= c #xb39))
		 (= c #xb3d)
		 (and (<= #xb5c c) (<= c #xb5d))
		 (and (<= #xb5f c) (<= c #xb61))
		 (= c #xb71)
		 (= c #xb83)
		 (and (<= #xb85 c) (<= c #xb8a))
		 (and (<= #xb8e c) (<= c #xb90))
		 (and (<= #xb92 c) (<= c #xb95))
		 (and (<= #xb99 c) (<= c #xb9a))
		 (= c #xb9c)
		 (and (<= #xb9e c) (<= c #xb9f))
		 (and (<= #xba3 c) (<= c #xba4))
		 (and (<= #xba8 c) (<= c #xbaa))
		 (and (<= #xbae c) (<= c #xbb9))
		 (= c #xbd0)
		 (and (<= #xc05 c) (<= c #xc0c))
		 (and (<= #xc0e c) (<= c #xc10))
		 (and (<= #xc12 c) (<= c #xc28))
		 (and (<= #xc2a c) (<= c #xc33))
		 (and (<= #xc35 c) (<= c #xc39))
		 (= c #xc3d)
		 (and (<= #xc58 c) (<= c #xc59))
		 (and (<= #xc60 c) (<= c #xc61))
		 (and (<= #xc85 c) (<= c #xc8c))
		 (and (<= #xc8e c) (<= c #xc90))
		 (and (<= #xc92 c) (<= c #xca8))
		 (and (<= #xcaa c) (<= c #xcb3))
		 (and (<= #xcb5 c) (<= c #xcb9))
		 (= c #xcbd)
		 (= c #xcde)
		 (and (<= #xce0 c) (<= c #xce1))
		 (and (<= #xd05 c) (<= c #xd0c))
		 (and (<= #xd0e c) (<= c #xd10))
		 (and (<= #xd12 c) (<= c #xd28))
		 (and (<= #xd2a c) (<= c #xd39))
		 (= c #xd3d)
		 (and (<= #xd60 c) (<= c #xd61))
		 (and (<= #xd7a c) (<= c #xd7f))
		 (and (<= #xd85 c) (<= c #xd96))
		 (and (<= #xd9a c) (<= c #xdb1))
		 (and (<= #xdb3 c) (<= c #xdbb))
		 (= c #xdbd)
		 (and (<= #xdc0 c) (<= c #xdc6))
		 (and (<= #xe01 c) (<= c #xe30))
		 (and (<= #xe32 c) (<= c #xe33))
		 (and (<= #xe40 c) (<= c #xe46))
		 (and (<= #xe81 c) (<= c #xe82))
		 (= c #xe84)
		 (and (<= #xe87 c) (<= c #xe88))
		 (= c #xe8a)
		 (= c #xe8d)
		 (and (<= #xe94 c) (<= c #xe97))
		 (and (<= #xe99 c) (<= c #xe9f))
		 (and (<= #xea1 c) (<= c #xea3))
		 (= c #xea5)
		 (= c #xea7)
		 (and (<= #xeaa c) (<= c #xeab))
		 (and (<= #xead c) (<= c #xeb0))
		 (and (<= #xeb2 c) (<= c #xeb3))
		 (= c #xebd)
		 (and (<= #xec0 c) (<= c #xec4))
		 (= c #xec6)
		 (and (<= #xedc c) (<= c #xedd))
		 (= c #xf00)
		 (and (<= #xf40 c) (<= c #xf47))
		 (and (<= #xf49 c) (<= c #xf6c))
		 (and (<= #xf88 c) (<= c #xf8b))
		 (and (<= #x1000 c) (<= c #x102a))
		 (= c #x103f)
		 (and (<= #x1050 c) (<= c #x1055))
		 (and (<= #x105a c) (<= c #x105d))
		 (= c #x1061)
		 (and (<= #x1065 c) (<= c #x1066))
		 (and (<= #x106e c) (<= c #x1070))
		 (and (<= #x1075 c) (<= c #x1081))
		 (= c #x108e)
		 (and (<= #x10a0 c) (<= c #x10c5))
		 (and (<= #x10d0 c) (<= c #x10fa))
		 (= c #x10fc)
		 (and (<= #x1100 c) (<= c #x1159))
		 (and (<= #x115f c) (<= c #x11a2))
		 (and (<= #x11a8 c) (<= c #x11f9))
		 (and (<= #x1200 c) (<= c #x1248))
		 (and (<= #x124a c) (<= c #x124d))
		 (and (<= #x1250 c) (<= c #x1256))
		 (= c #x1258)
		 (and (<= #x125a c) (<= c #x125d))
		 (and (<= #x1260 c) (<= c #x1288))
		 (and (<= #x128a c) (<= c #x128d))
		 (and (<= #x1290 c) (<= c #x12b0))
		 (and (<= #x12b2 c) (<= c #x12b5))
		 (and (<= #x12b8 c) (<= c #x12be))
		 (= c #x12c0)
		 (and (<= #x12c2 c) (<= c #x12c5))
		 (and (<= #x12c8 c) (<= c #x12d6))
		 (and (<= #x12d8 c) (<= c #x1310))
		 (and (<= #x1312 c) (<= c #x1315))
		 (and (<= #x1318 c) (<= c #x135a))
		 (and (<= #x1380 c) (<= c #x138f))
		 (and (<= #x13a0 c) (<= c #x13f4))
		 (and (<= #x1401 c) (<= c #x166c))
		 (and (<= #x166f c) (<= c #x1676))
		 (and (<= #x1681 c) (<= c #x169a))
		 (and (<= #x16a0 c) (<= c #x16ea))
		 (and (<= #x1700 c) (<= c #x170c))
		 (and (<= #x170e c) (<= c #x1711))
		 (and (<= #x1720 c) (<= c #x1731))
		 (and (<= #x1740 c) (<= c #x1751))
		 (and (<= #x1760 c) (<= c #x176c))
		 (and (<= #x176e c) (<= c #x1770))
		 (and (<= #x1780 c) (<= c #x17b3))
		 (= c #x17d7)
		 (= c #x17dc)
		 (and (<= #x1820 c) (<= c #x1877))
		 (and (<= #x1880 c) (<= c #x18a8))
		 (= c #x18aa)
		 (and (<= #x1900 c) (<= c #x191c))
		 (and (<= #x1950 c) (<= c #x196d))
		 (and (<= #x1970 c) (<= c #x1974))
		 (and (<= #x1980 c) (<= c #x19a9))
		 (and (<= #x19c1 c) (<= c #x19c7))
		 (and (<= #x1a00 c) (<= c #x1a16))
		 (and (<= #x1b05 c) (<= c #x1b33))
		 (and (<= #x1b45 c) (<= c #x1b4b))
		 (and (<= #x1b83 c) (<= c #x1ba0))
		 (and (<= #x1bae c) (<= c #x1baf))
		 (and (<= #x1c00 c) (<= c #x1c23))
		 (and (<= #x1c4d c) (<= c #x1c4f))
		 (and (<= #x1c5a c) (<= c #x1c7d))
		 (and (<= #x1d00 c) (<= c #x1dbf))
		 (and (<= #x1e00 c) (<= c #x1f15))
		 (and (<= #x1f18 c) (<= c #x1f1d))
		 (and (<= #x1f20 c) (<= c #x1f45))
		 (and (<= #x1f48 c) (<= c #x1f4d))
		 (and (<= #x1f50 c) (<= c #x1f57))
		 (= c #x1f59)
		 (= c #x1f5b)
		 (= c #x1f5d)
		 (and (<= #x1f5f c) (<= c #x1f7d))
		 (and (<= #x1f80 c) (<= c #x1fb4))
		 (and (<= #x1fb6 c) (<= c #x1fbc))
		 (= c #x1fbe)
		 (and (<= #x1fc2 c) (<= c #x1fc4))
		 (and (<= #x1fc6 c) (<= c #x1fcc))
		 (and (<= #x1fd0 c) (<= c #x1fd3))
		 (and (<= #x1fd6 c) (<= c #x1fdb))
		 (and (<= #x1fe0 c) (<= c #x1fec))
		 (and (<= #x1ff2 c) (<= c #x1ff4))
		 (and (<= #x1ff6 c) (<= c #x1ffc))
		 (= c #x2071)
		 (= c #x207f)
		 (and (<= #x2090 c) (<= c #x2094))
		 (= c #x2102)
		 (= c #x2107)
		 (and (<= #x210a c) (<= c #x2113))
		 (= c #x2115)
		 (and (<= #x2119 c) (<= c #x211d))
		 (= c #x2124)
		 (= c #x2126)
		 (= c #x2128)
		 (and (<= #x212a c) (<= c #x212d))
		 (and (<= #x212f c) (<= c #x2139))
		 (and (<= #x213c c) (<= c #x213f))
		 (and (<= #x2145 c) (<= c #x2149))
		 (= c #x214e)
		 (and (<= #x2183 c) (<= c #x2184))
		 (and (<= #x2c00 c) (<= c #x2c2e))
		 (and (<= #x2c30 c) (<= c #x2c5e))
		 (and (<= #x2c60 c) (<= c #x2c6f))
		 (and (<= #x2c71 c) (<= c #x2c7d))
		 (and (<= #x2c80 c) (<= c #x2ce4))
		 (and (<= #x2d00 c) (<= c #x2d25))
		 (and (<= #x2d30 c) (<= c #x2d65))
		 (= c #x2d6f)
		 (and (<= #x2d80 c) (<= c #x2d96))
		 (and (<= #x2da0 c) (<= c #x2da6))
		 (and (<= #x2da8 c) (<= c #x2dae))
		 (and (<= #x2db0 c) (<= c #x2db6))
		 (and (<= #x2db8 c) (<= c #x2dbe))
		 (and (<= #x2dc0 c) (<= c #x2dc6))
		 (and (<= #x2dc8 c) (<= c #x2dce))
		 (and (<= #x2dd0 c) (<= c #x2dd6))
		 (and (<= #x2dd8 c) (<= c #x2dde))
		 (= c #x2e2f)
		 (and (<= #x3005 c) (<= c #x3006))
		 (and (<= #x3031 c) (<= c #x3035))
		 (and (<= #x303b c) (<= c #x303c))
		 (and (<= #x3041 c) (<= c #x3096))
		 (and (<= #x309d c) (<= c #x309f))
		 (and (<= #x30a1 c) (<= c #x30fa))
		 (and (<= #x30fc c) (<= c #x30ff))
		 (and (<= #x3105 c) (<= c #x312d))
		 (and (<= #x3131 c) (<= c #x318e))
		 (and (<= #x31a0 c) (<= c #x31b7))
		 (and (<= #x31f0 c) (<= c #x31ff))
		 (and (<= #x3400 c) (<= c #x4db5))
		 (and (<= #x4e00 c) (<= c #x9fc3))
		 (and (<= #xa000 c) (<= c #xa48c))
		 (and (<= #xa500 c) (<= c #xa60c))
		 (and (<= #xa610 c) (<= c #xa61f))
		 (and (<= #xa62a c) (<= c #xa62b))
		 (and (<= #xa640 c) (<= c #xa65f))
		 (and (<= #xa662 c) (<= c #xa66e))
		 (and (<= #xa67f c) (<= c #xa697))
		 (and (<= #xa717 c) (<= c #xa71f))
		 (and (<= #xa722 c) (<= c #xa788))
		 (and (<= #xa78b c) (<= c #xa78c))
		 (and (<= #xa7fb c) (<= c #xa801))
		 (and (<= #xa803 c) (<= c #xa805))
		 (and (<= #xa807 c) (<= c #xa80a))
		 (and (<= #xa80c c) (<= c #xa822))
		 (and (<= #xa840 c) (<= c #xa873))
		 (and (<= #xa882 c) (<= c #xa8b3))
		 (and (<= #xa90a c) (<= c #xa925))
		 (and (<= #xa930 c) (<= c #xa946))
		 (and (<= #xaa00 c) (<= c #xaa28))
		 (and (<= #xaa40 c) (<= c #xaa42))
		 (and (<= #xaa44 c) (<= c #xaa4b))
		 (= c #xac00)
		 (= c #xd7a3)
		 (and (<= #xf900 c) (<= c #xfa2d))
		 (and (<= #xfa30 c) (<= c #xfa6a))
		 (and (<= #xfa70 c) (<= c #xfad9))
		 (and (<= #xfb00 c) (<= c #xfb06))
		 (and (<= #xfb13 c) (<= c #xfb17))
		 (= c #xfb1d)
		 (and (<= #xfb1f c) (<= c #xfb28))
		 (and (<= #xfb2a c) (<= c #xfb36))
		 (and (<= #xfb38 c) (<= c #xfb3c))
		 (= c #xfb3e)
		 (and (<= #xfb40 c) (<= c #xfb41))
		 (and (<= #xfb43 c) (<= c #xfb44))
		 (and (<= #xfb46 c) (<= c #xfbb1))
		 (and (<= #xfbd3 c) (<= c #xfd3d))
		 (and (<= #xfd50 c) (<= c #xfd8f))
		 (and (<= #xfd92 c) (<= c #xfdc7))
		 (and (<= #xfdf0 c) (<= c #xfdf9))
		 (= c #x1dfa0645)
		 (= c #xfdfb)
		 (and (<= #xfe70 c) (<= c #xfe74))
		 (and (<= #xfe76 c) (<= c #xfefc))
		 (and (<= #xff21 c) (<= c #xff3a))
		 (and (<= #xff41 c) (<= c #xff5a))
		 (and (<= #xff66 c) (<= c #xffbe))
		 (and (<= #xffc2 c) (<= c #xffc7))
		 (and (<= #xffca c) (<= c #xffcf))
		 (and (<= #xffd2 c) (<= c #xffd7))
		 (and (<= #xffda c) (<= c #xffdc))
		 (and (<= #x10000 c) (<= c #x1000b))
		 (and (<= #x1000d c) (<= c #x10026))
		 (and (<= #x10028 c) (<= c #x1003a))
		 (and (<= #x1003c c) (<= c #x1003d))
		 (and (<= #x1003f c) (<= c #x1004d))
		 (and (<= #x10050 c) (<= c #x1005d))
		 (and (<= #x10080 c) (<= c #x100fa))
		 (and (<= #x10280 c) (<= c #x1029c))
		 (and (<= #x102a0 c) (<= c #x102d0))
		 (and (<= #x10300 c) (<= c #x1031e))
		 (and (<= #x10330 c) (<= c #x10340))
		 (and (<= #x10342 c) (<= c #x10349))
		 (and (<= #x10380 c) (<= c #x1039d))
		 (and (<= #x103a0 c) (<= c #x103c3))
		 (and (<= #x103c8 c) (<= c #x103cf))
		 (and (<= #x10400 c) (<= c #x1049d))
		 (and (<= #x10800 c) (<= c #x10805))
		 (= c #x10808)
		 (and (<= #x1080a c) (<= c #x10835))
		 (and (<= #x10837 c) (<= c #x10838))
		 (= c #x1083c)
		 (= c #x1083f)
		 (and (<= #x10900 c) (<= c #x10915))
		 (and (<= #x10920 c) (<= c #x10939))
		 (= c #x10a00)
		 (and (<= #x10a10 c) (<= c #x10a13))
		 (and (<= #x10a15 c) (<= c #x10a17))
		 (and (<= #x10a19 c) (<= c #x10a33))
		 (and (<= #x12000 c) (<= c #x1236e))
		 (and (<= #x1d400 c) (<= c #x1d454))
		 (and (<= #x1d456 c) (<= c #x1d49c))
		 (and (<= #x1d49e c) (<= c #x1d49f))
		 (= c #x1d4a2)
		 (and (<= #x1d4a5 c) (<= c #x1d4a6))
		 (and (<= #x1d4a9 c) (<= c #x1d4ac))
		 (and (<= #x1d4ae c) (<= c #x1d4b9))
		 (= c #x1d4bb)
		 (and (<= #x1d4bd c) (<= c #x1d4c3))
		 (and (<= #x1d4c5 c) (<= c #x1d505))
		 (and (<= #x1d507 c) (<= c #x1d50a))
		 (and (<= #x1d50d c) (<= c #x1d514))
		 (and (<= #x1d516 c) (<= c #x1d51c))
		 (and (<= #x1d51e c) (<= c #x1d539))
		 (and (<= #x1d53b c) (<= c #x1d53e))
		 (and (<= #x1d540 c) (<= c #x1d544))
		 (= c #x1d546)
		 (and (<= #x1d54a c) (<= c #x1d550))
		 (and (<= #x1d552 c) (<= c #x1d6a5))
		 (and (<= #x1d6a8 c) (<= c #x1d6c0))
		 (and (<= #x1d6c2 c) (<= c #x1d6da))
		 (and (<= #x1d6dc c) (<= c #x1d6fa))
		 (and (<= #x1d6fc c) (<= c #x1d714))
		 (and (<= #x1d716 c) (<= c #x1d734))
		 (and (<= #x1d736 c) (<= c #x1d74e))
		 (and (<= #x1d750 c) (<= c #x1d76e))
		 (and (<= #x1d770 c) (<= c #x1d788))
		 (and (<= #x1d78a c) (<= c #x1d7a8))
		 (and (<= #x1d7aa c) (<= c #x1d7c2))
		 (and (<= #x1d7c4 c) (<= c #x1d7cb))
		 (= c #x20000)
		 (= c #x2a6d6)
		 (and (<= #x2f800 c) (<= c #x2fa1d)))))))

(defun unicode-is-digit (char)
  (cond ((<= char #x7f)
	 (and (<= #x30 char) (<= char #x39)))
	(t (let ((c (encode-char char 'ucs)))
	     (or (and (<= #x660 c) (<= c #x669))
		 (and (<= #x6f0 c) (<= c #x6f9))
		 (and (<= #x7c0 c) (<= c #x7c9))
		 (and (<= #x966 c) (<= c #x96f))
		 (and (<= #x9e6 c) (<= c #x9ef))
		 (and (<= #xa66 c) (<= c #xa6f))
		 (and (<= #xae6 c) (<= c #xaef))
		 (and (<= #xb66 c) (<= c #xb6f))
		 (and (<= #xbe6 c) (<= c #xbef))
		 (and (<= #xc66 c) (<= c #xc6f))
		 (and (<= #xce6 c) (<= c #xcef))
		 (and (<= #xd66 c) (<= c #xd6f))
		 (and (<= #xe50 c) (<= c #xe59))
		 (and (<= #xed0 c) (<= c #xed9))
		 (and (<= #xf20 c) (<= c #xf29))
		 (and (<= #x1040 c) (<= c #x1049))
		 (and (<= #x1090 c) (<= c #x1099))
		 (and (<= #x17e0 c) (<= c #x17e9))
		 (and (<= #x1810 c) (<= c #x1819))
		 (and (<= #x1946 c) (<= c #x194f))
		 (and (<= #x19d0 c) (<= c #x19d9))
		 (and (<= #x1b50 c) (<= c #x1b59))
		 (and (<= #x1bb0 c) (<= c #x1bb9))
		 (and (<= #x1c40 c) (<= c #x1c49))
		 (and (<= #x1c50 c) (<= c #x1c59))
		 (and (<= #xa620 c) (<= c #xa629))
		 (and (<= #xa8d0 c) (<= c #xa8d9))
		 (and (<= #xa900 c) (<= c #xa909))
		 (and (<= #xaa50 c) (<= c #xaa59))
		 (and (<= #xff10 c) (<= c #xff19))
		 (and (<= #x104a0 c) (<= c #x104a9))
		 (and (<= #x1d7ce c) (<= c #x1d7ff)))))))

(defun unicode-is-connecting-punctuation (char)
  (cond ((<= char #x7f)
	 (= char #x005F))
	(t (let ((c (encode-char char 'ucs)))
	     (or (= c #x203F)
		 (= c #x2040)
		 (= c #x2054)
		 (= c #xFE33)
		 (= c #xFE34)
		 (= c #xFE4D)
		 (= c #xFE4E)
		 (= c #xFE4F)
		 (= c #xFF3F))))))

(defun unicode-is-prime (char)
  (and (> char #x7f)
       (let ((c (encode-char char 'ucs)))
	 (or (= c #x2032)		;PRIME
	     (= c #x2033)		;DOUBLE PRIME
	     (= c #x2034)		;TRIPLE PRIME
	     (= c #x2057)))))		;QUADRUPLE PRIME

;;; *****************************************
;;; End of new fortify code; beginning of old fortify code.
;;; For now, we will keep them both running together.
;;; *****************************************


(global-set-key "\M-?" 'buffer-rotate-switch)
(global-set-key "\M-&" 'fortify)
(global-set-key "\C-x&" 'method-fortify)
(global-set-key "\M-_" 'emphasize)

(defvar buffer-rotate-switch-depth 0 "Depth of rotation for buffer-rotate-switch command")

(defun buffer-rotate-switch (prefix-arg)
  "Switch buffers in rotation.
Doing this command once is similar to typing C-X B Return to switch to
the default buffer, that is, the one second from the top of the buffer
list.  Typing this command n times in succession has the effect of pulling
the the n+1'th buffer on the buffer list to the top of the buffer list,
making it the current buffer."
  (interactive "p")
  (let ((n (length (buffer-list))))
    (cond ((eq last-command 'buffer-rotate-switch)
	   (setq buffer-rotate-switch-depth
		 (mod (+ 1 buffer-rotate-switch-depth) n)))
	  (t (setq buffer-rotate-switch-depth 0)))
    (let ((b buffer-rotate-switch-depth))
      (while (> b 0)
	(switch-to-buffer (nth buffer-rotate-switch-depth (buffer-list)))
	(setq b (- b 1))))
    (cond ((< (+ buffer-rotate-switch-depth 1) n)
	   (switch-to-buffer (nth (+ buffer-rotate-switch-depth 1) (buffer-list)))))))

(defun emphasize (prefix-arg)
  "Emphasize preceding word.
The strings \\emph{ and } are inserted before and after the word before point.
However, if the character before point is }, and the preceding { is in turn
preceded by \\emph, then the \\emph{ sequence is moved backward one word.
Thus, after typing a sequence of n words, one can mark them the TeX emphasis
simply by typing M-_ n times."
  (interactive "*p")
  (let* ((case-fold-search nil)
	 (old-point (point)))
    (cond ((= (char-before (point)) ?\})
	   (search-backward "{")
	   (goto-char (- (point) 5))
	   (unless (looking-at "\\\\emph")
	     (goto-char old-point)
	     (keyboard-quit))
	   (let ((old-emph-point (point)))
	     (backward-word 1)
	     (let ((new-emph-point (point)))
	       (goto-char old-emph-point)
	       (delete-char 6)
	       (goto-char new-emph-point)
	       (insert "\\emph{")
	       (goto-char old-point))))
	  (t (backward-word 1)
	     (insert "\\emph{")
	     (forward-word 1)
	     (insert "}")))))

;;; We assume these TeX macro definitions:
;;; \def\Fortress{\list{}{\leftmargin 1em
;;;                       \itemindent\listparindent
;;;                       \parsep 0pt plus 1pt}\item
;;;                       \FortressInnerMacros\tabbing}
;;; \def\endFortress{\endtabbing\endlist}
;;; \def\FortressMathsurround{\mathsurround=0.166666em}
;;; \def\KWD#1{\(\mathtt{#1}\FortressMathsurround\)}
;;; \def\OPR#1{\(\mathtt{#1}\FortressMathsurround\)}
;;; \def\TYP#1{\(\mathrm{#1}\FortressMathsurround\)}
;;; \def\VAR#1{\(\mathit{#1}\FortressMathsurround\)}
;;; \def\EXP#1{\({\FortressInnerMacros#1}\FortressMathsurround\)}
;;; \def\innerKWD#1{\mathrel\mathtt{#1}}
;;; \def\innerOPR#1{\mathbin\mathtt{#1}}
;;; \def\innerTYP#1{\mathrm{#1}}
;;; \def\innerVAR#1{\mathit{#1}}
;;; \def\FortressInnerMacros{\let\KWD\innerKWD\let\OPR\innerOPR
;;;   \let\TYP\innerTYP\let\VAR\innerVAR}

(defun fortify (prefix-arg)
  "Format text as Fortress code.
A portion of the text in the buffer is formatted as Fortress code
by inserting TeX commands and performing certain transformations.
With no prefix argument, the contiguous nonblank text preceding point
is formatted.  With ^U, the region is formatted.  With ^U^U, the
region is formatted into a side-by-side display showing formatted
code on the left and unformatted code in the \\tt font on the right.
A prefix argument of 2 or 5 causes the preceding nonblank text (if 2)
or the region (if 5) to be formatted as if the contents of a string.
A prefix argument of 3 or 6 causes the preceding nonblank text (if 3)
or the region (if 6) to be formatted as Fortress code and followed
by another copy, formatted as string contents, in parentheses.
For prefix arguments 2, 3, 5, and 6, the text to be formatted must
lie within a single line.  No matter what the prefix argument,
if the text to be formatted lies entirely within a single line and
the side-by-side option is not requested, then the formatted text
is simply surrounded by either \\KWD{...} or \\OPR{...} or \\VAR{...}
or \\TYP{...} or \\EXP{...} within the line; otherwise
a multiline LaTeX Fortress environment is created.  If the region
is to be processed and the first character in the region is %,
then the region is first copied, and within the copy all lines
have any initial % character removed before the text is formatted,
but if the first two characters in the region are %%, then
C-U M-X comment-region is called instead, to do a cleverer job
of removing the comment characters; thus the net result is
that the original region precedes the formatted code.
In this way, Fortress code can be kept within a TeX source file
as a comment and easily altered and reformatted as necessary.
The text to be formatted must not contain any ^P or ^Q characters,
which is not much of a restriction, since these are not valid in
Fortress source code)."
  (interactive "*p")
  (let* ((case-fold-search nil)
	 (extra-space-inserted nil)
	 (process-region (and prefix-arg (>= prefix-arg 4)))
	 (side-by-side (and prefix-arg (>= prefix-arg 16)))
	 (string-only (and prefix-arg (or (= prefix-arg 2) (= prefix-arg 5))))
	 (parenthetical-string (and prefix-arg (or (= prefix-arg 3) (= prefix-arg 6))))
	 (old-point (copy-marker (point)))
	 (end (copy-marker (cond (process-region
				  (region-end))
				 (t (re-search-backward "[^\n \t]" nil nil)
				    (forward-char)
				    (unless (= (point) (marker-position old-point))
				      (insert " ")  ;Need to delete this later!
				      (setq extra-space-inserted (copy-marker (point))))
				    (point)))))
	 (start (copy-marker (cond (process-region
				    (region-beginning))
				   (t (re-search-backward "\\(^\\| \\|\t\\)" nil t)
				      (if (looking-at "[ \t]") (forward-char))
				      (point)))))
	 (multi-line (> (count-lines start end) 1)))
    (cond ((and (< start end) (= (char-after (- (marker-position end) 1)) ?\n))
	   (set-marker end (- (marker-position end) 1))
	   (setq multi-line t)))
    (if (and multi-line (or string-only parenthetical-string)) (keyboard-quit))
    (goto-char (marker-position start))
    (if (re-search-forward "[]" (marker-position end) t) (keyboard-quit))
    (untabify start end)
    (cond ((and process-region
		(= (char-after (marker-position start)) ?\%)
		(or (null (char-before (marker-position start)))
		    (= (char-before (marker-position start)) ?\n)))
	   ;; Make a copy
	   (let ((region-data (buffer-substring (marker-position start) (marker-position end))))
	     (goto-char (marker-position end))
	     (insert "\n")
	     (set-marker start (point))
	     (insert region-data)
	     (set-marker end (point))
	     (goto-char (marker-position start))
             (cond ((looking-at "%%") (comment-region (marker-position start) (marker-position end) '(4)))
		   (t (delete-char 1)
		      ;; Remove leading % from each line
		      (process-fortify-rules '(("\n%" "\n")) (marker-position start) (marker-position end)))))))
    (cond (string-only
	   (process-fortify-rules fortify-brace-rules (marker-position start) (marker-position end))
	   (process-fortify-rules fortify-string-rules (marker-position start) (marker-position end))
	   (goto-char (marker-position start))
	   (insert "\\STR{")
	   (goto-char (marker-position end))
	   (insert-before-markers "}"))
	  (t (let ((parenthetical-data (and parenthetical-string
					    (buffer-substring (marker-position start) (marker-position end)))))
	       ;; indent-stack contains pairs (indentation point-for-start-of-line-data)
	       (let ((indent-stack '()))
		 (goto-char (marker-position start))
		 (let ((first-indent (current-indentation)))
		   (cond (side-by-side
			  (let ((line-start (point)))
			    (end-of-line)
			    (let ((data (buffer-substring line-start (point))))
			      (insert-before-markers " START")
			      (insert-before-markers data)
			      (insert-before-markers "END"))
			    (goto-char line-start))))
		   (insert "\\(")
		   (cond ((or side-by-side multi-line)
			  (cond ((= first-indent 0)
				 (setq indent-stack (list (list 0 (point)))))
				(t
				 ;; Establish indentation of first line
				 (insert "\\)LEFT\\tt")
				 (insert-char ?\~ first-indent)
				 (insert "RIGHT\\pushtabs\\=\\+\\(")
				 (setq indent-stack (list (list first-indent (point))
							  (list 0 (point)))))))))
		 (forward-line)
		 (while (< (point) (marker-position end))
		   ;; Invariant: indent-stack is nonempty
		   ;; Invariant: indentations in the stack are strictly monotonically decreasing
		   ;; Invariant: points-for-start-of-line-data in the stack are monotonically decreasing
		   ;; Invariant: we are just after a newline
		   (let ((k (current-indentation)))
		     (cond ((not (looking-at "^[ ]*$"))
			    ;; Line is nonblank
			    (backward-char)
			    (let ((decrements "") (poptabs ""))
			      (while (< k (car (car indent-stack)))
				(setq decrements (concat "\\-" decrements))
				(setq poptabs (concat "\\poptabs" poptabs))
				(setq indent-stack (cdr indent-stack)))
			      ;; Stack began with a 0, so stack cannot become empty
			      (insert "\\)")
			      (insert decrements)
			      (insert poptabs)
			      (insert "\\("))
			    (forward-line)
			    (cond (side-by-side
				   (let ((line-start (point)))
				     (end-of-line)
				     (let ((data (buffer-substring line-start (point))))
				       (insert-before-markers " START")
				       (insert-before-markers data)
				       (insert-before-markers "END")
				       (goto-char line-start)))))
			    ;; Invariant: stack is nonempty
			    (cond ((> k (car (car indent-stack)))
				   (let ((here (copy-marker (point))))
				     (goto-char (cadr (car indent-stack)))
				     (let ((desired-column (+ (current-column) k)))
				       (move-to-column desired-column)
				       (let ((c (char-before (point))))
					 (cond ((and (= (current-column) desired-column)
						     (or (and (= c ?\ ) (not (= (char-after (point)) ?\ )))
							 (= c ?\()
							 (= c ?\[)
							 (= c ?\{)
							 (and (or (= c ?\\) (= c ?\/))
							      (> k 1)
							      (let ((b (char-before (- (point) 1))))
								(or (= b ?\<) (= b ?\() (= b ?\[) (= b ?\{))))))
						;; We have a good place to align to
						(insert " \\null\\)\\pushtabs\\=\\+\\(")
						(goto-char (marker-position here)))
					       (t (goto-char (marker-position here))
						  ;; This line has to establish its own indentation
						  (insert "\\)LEFT\\tt")
						  (insert-char ?\~ (- k (car (car indent-stack))))
						  (insert "RIGHT\\pushtabs\\=\\+\\(")))))
				     (set-marker here nil)
				     (setq indent-stack (cons (list k (point)) indent-stack))))
				  (t (setq indent-stack (cons (list k (point)) (cdr indent-stack))))))))
		   ;; Step forward a line for while loop
		   (forward-line))
		 (goto-char (marker-position end))
		 (let ((decrements "") (poptabs ""))
		   (while (not (null (cdr indent-stack)))
		     (setq decrements (concat "\\-" decrements))
		     (setq poptabs (concat "\\poptabs" poptabs))
		     (setq indent-stack (cdr indent-stack)))
		   (insert-before-markers "\\)")
		   (insert-before-markers decrements)
		   (insert-before-markers poptabs)
		   (insert-before-markers "\\("))
		 (insert-before-markers "\\)"))
	       (process-fortify-rules fortify-brace-rules (marker-position start) (marker-position end))
	       (goto-char (marker-position start))
	       (let ((code-start (point)))
		 (while (re-search-forward "\\((\\*\\(.*\\)\\*)\\|\"[^\"\n]*\"\\|START.*END\\)" (marker-position end) t)
		   (cond ((= (char-before (point)) ?\))
			  ;; Comment
			  (replace-match "\\\\mathtt{(*}\\\\;\\\\hbox{\\\\rm \\2\\\\unskip}\\\\;\\\\mathtt{*)}" t nil)
			  (process-fortify-rules fortify-code-rules code-start (match-beginning 0)))
			 ((= (char-before (point)) ?\")
			  ;; String
			  (let ((mbeg (match-beginning 0))
				(here (copy-marker (point))))
			    (process-fortify-rules fortify-string-rules mbeg (point))
			    (goto-char mbeg)
			    (delete-char 1)
			    (insert "\\hbox{\\rm``\\STR{")
			    (goto-char (marker-position here))
			    (set-marker here nil)
			    (delete-char -1)
			    (insert "}''}")
			    (process-fortify-rules fortify-code-rules code-start mbeg)))
			 (t
			  ;; Side-by-side text
			  (let ((mbeg (match-beginning 0)))
			    (process-fortify-rules fortify-string-rules mbeg (point))
			    (process-fortify-rules fortify-code-rules code-start mbeg))))
		   (setq code-start (point)))
		 (process-fortify-rules fortify-code-rules code-start (marker-position end)))
	       (cond ((or side-by-side multi-line)
		      (goto-char (marker-position start))
		      (insert "\\begin{Fortress}\n")
		      (goto-char (marker-position end))
		      (insert-before-markers "\n\\end{Fortress}"))
		     (t (goto-char (marker-position start))
			(cond ((looking-at "\\\\(")
			       (replace-match "\\\\EXP{" t nil)))
			(goto-char (marker-position end))
			(backward-char 2)
			(cond ((looking-at "\\\\)")
			       (replace-match "}" t nil)))))
	       (process-fortify-rules fortify-final-fixups (marker-position start) (marker-position end))
	       (cond (parenthetical-string
		      (goto-char (marker-position end))
		      (insert-before-markers " (\\STR{")
		      (let ((place (point)))
			(insert-before-markers parenthetical-data) ;need to insert before old-point
			(set-marker start place))
		      (set-marker end (point))
		      (process-fortify-rules fortify-brace-rules (marker-position start) (marker-position end))
		      (process-fortify-rules fortify-string-rules (marker-position start) (marker-position end))
		      (insert-before-markers "})"))))))
	  (set-marker start nil)
	  (set-marker end nil)
	  (when extra-space-inserted
	    (goto-char (marker-position extra-space-inserted))
	    (delete-char -1)
	    (set-marker extra-space-inserted nil))
	  (let ((old-point-position (marker-position old-point)))
	    (set-marker old-point nil)
	    (goto-char old-point-position))))

;;; The bulk of the work is done by regexp-replacement.
;;; This routine processes a set of rules, one at a time, in order,
;;; on the portion of the buffer delimited by start and end.
;;; Each rule is simply a pair of a regexp and a replacement string.
;;; A subtlety is that the rule processor backs up by one character
;;; after each replacement.  This is because many rules match an
;;; extra character of right context that is not subject to replacement,
;;; and that character might be needed for a subsequent match.
;;; (In situations where more than one character of backup might be
;;; required, the solution is to have two copies of the rule in the list.)
;;; The one-character backup means that certain other rules need to be careful.
;;; For example, the rule in "fortify-brace-rules" that turns "}" into "\}"
;;; must check to make sure that the "}" is not preceded by a "\";
;;; otherwise the same "}" would be repeatedly replaced by "\}",
;;; leading to a runaway iteration (yes, this actually happened to me).

(defun process-fortify-rules (rules startpos endpos)
  (let ((old-point (copy-marker (point)))
	(end-marker (copy-marker endpos)))
    (while (not (null rules))
      (let ((regexp (car (car rules)))
	    (replacement (cadr (car rules))))
	(goto-char startpos)
	(while (re-search-forward regexp (marker-position end-marker) t)
	  (replace-match replacement t nil)
	  (goto-char (- (point) 1))))
      (setq rules (cdr rules)))
    (set-marker end-marker nil)
    (let ((old-point-position (marker-position old-point)))
      (set-marker old-point nil)
      (goto-char old-point-position))))

;; (defun process-fortify-rules (rules startpos endpos)
;;   (let ((old-point (copy-marker (point))))
;;     (goto-char endpos)
;;     (insert-before-markers " ")
;;     (let ((end-marker (copy-marker (point))))
;;       (while (not (null rules))
;; 	(let ((regexp (car (car rules)))
;; 	      (replacement (cadr (car rules))))
;; 	  (goto-char startpos)
;; 	  (while (re-search-forward regexp (marker-position end-marker) t)
;; 	    (replace-match replacement t nil)
;; 	    (goto-char (- (point) 1))))
;; 	(setq rules (cdr rules)))
;;       (goto-char (marker-position end-marker))
;;       (when (= (char-before (point)) ?\ )
;; 	(delete-char -1))
;;       (set-marker end-marker nil)
;;       (let ((old-point-position (marker-position old-point)))
;; 	(set-marker old-point nil)
;; 	(goto-char old-point-position)))))


(setq fortify-brace-rules
      '(
	;; Braces, observing interior space
	("{" "LB")
	("}" "RB")
	("LB " "\\\\{\\\\,")
	("LB" "\\\\{{}")
	(" RB" "\\\\,\\\\}")
	("RB" "\\\\}")
	;; Now fix up braces needed by indentation stuff: spaces adjacent
        ;; to them should not be converted to LaTeX thin-space commands!
	("LEFT" "{")
	("RIGHT" "}")
	))

(setq fortify-string-rules     ;also used for side-by-side text
      '(
	;; Have to undo damage done by the brace rules!  Also convert backslashes.
	;; Using LBX and RBX rather than LB and RB merely aids in debugging these rules.
	("\\\\{\\\\," "LBX ")
	("\\\\,\\\\}" " RBX")
	("\\\\{" "LBX")
	("\\\\}" "RBX")
	;; Must handle backslashes after unconverting the braces and before
        ;; converting any characters to use \char !  Note that the following
	;; character expansions carefully use no spaces, because later we
	;; convert spaces to tildes.
	("\\\\" "{\\\\char'134}")
	("LBX" "{\\\\char'173}")
	("RBX" "{\\\\char'175}")
	("#" "{\\\\char'43}")
	("\\$" "{\\\\char'44}")
	("%" "{\\\\char'45}")
	("&" "{\\\\char'46}")
	("_" "{\\\\char'137}")
	("\\^" "{\\\\char'136}")
	("~" "{\\\\char'176}")
	(" " "~")
	("START" "\\\\)\\\\`\\\\(\\\\hbox to 0pt{\\\\hss\\\\hbox to 0.5\\\\linewidth{\\\\tt{}")
	("END" "\\\\hfill}}")
	))

(setq fortify-code-rules
      '(
	;; Colon-equals-colon and colon-equals
	(":=:" "{}\\\\CONDEQ{}")
	(":=" "{}\\\\ASSIGN{}")
	;; Colons, observing space
	;;   Space after but not before is used for declarations
	;;   Space on neither side means it's a (typically infix) colon operator
	("\\([^ ]\\):\\([ ]\\)" "\\1{}\\\\COLON\\2")
	("\\([^ ]\\):\\([^ }]\\)" "\\1{}\\\\COLONOP{}\\2")
	(":\\([^}]\\)" "{}\\\\mathrel{\\\\mathtt{:}}\\1")
	;; Exponentiation: consider various forms for the exponent
	;;   Parameterized type (used after comprehensions)
	("\\^\\([a-zA-Z0-9_']+\\[\\\\[a-zA-Z0-9_ ,]*\\(\\[\\\\[a-zA-Z0-9_ ,]*\\\\\\]\\)\\\\\\]\\)" "^{ \\1 }")
	;;   Parameterized type with no nesting
	("\\^\\([a-zA-Z0-9_']+\\[\\\\[a-zA-Z0-9_ ,]*\\\\\\]\\)" "^{ \\1 }")
	;;   Parenthesized sums/diffs/dots/quotients of juxtapositions of variables and literals (no sum/diff/dot required)
	("\\^(\\(\\([+-][ ]*\\)?[A-Za-z0-9]+[']*\\([ ]+[A-Za-z0-9]+[']*\\)*\\([ ]*\\(+\\|-\\|DOT\\|/\\)[ ]*[A-Za-z0-9]+[']*\\([ ]+[A-Za-z0-9]+[']*\\)*\\)*\\))"
	 "^{ \\1 }")
	;;   Simple name or literal
	("\\^\\([A-Za-z0-9_.']+\\)" "^{ \\1 }")
        ;; Handle bare _ so we don't subsequently confuse it with inserted subscripting:
        ("\\(^\\|[^a-zA-Z0-9_{]\\)_\\([']*\\)\\($\\|[^a-zA-Z0-9_}]\\)" "\\1{\\\\tt\\\\_}\\2{}\\3")
        ("\\(^\\|[^a-zA-Z0-9_{]\\)__\\([']*\\)\\($\\|[^a-zA-Z0-9_}]\\)" "\\1{\\\\tt\\\\_\\\\_}\\2{}\\3")
        ("\\(^\\|[^a-zA-Z0-9_{]\\)___\\([']*\\)\\($\\|[^a-zA-Z0-9_}]\\)" "\\1{\\\\tt\\\\_\\\\_\\\\_}\\2{}\\3")
	;; Subscripts
	;;  Single-dimensional
	;;     Single letter or digit with optional prime marks
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z0-9][']*\\)\\]" "\\1{}_{\\2}")
	;;     Multidigit numeral
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([1-9][0-9]+\\)\\]" "\\1{}_{\\2}")
	;;     Single letter followed by digits with optional prime marks
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z]\\)\\([0-9]+\\)\\([']*\\)\\]" "\\1{}_{\\2{\\4}_{\\3}}")
	;;     Single letter, underscore, and label
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z]\\)_\\([A-Za-z][A-Za-z0-9]+\\)\\]" "\\1{}_{{\\2}_{\\\\mathrm{\\3}}}")
	;;     Sums/diffs/dots of juxtapositions of variables and literals (at least one sum/diff/dot required)
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\(\\([+-][ ]*\\)?[A-Za-z0-9]+[']*\\([ ]+[A-Za-z0-9]+[']*\\)*\\([ ]*\\(+\\|-\\|DOT\\)[ ]*[A-Za-z0-9]+[']*\\([ ]+[A-Za-z0-9]+[']*\\)*\\)+\\)\\]" "\\1{}_{\\2}")
	;;  Two-dimensional
	;;    Each either a single letter or digit, or single letter followed by digits, with optional prime marks
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z0-9][']*\\),\\([A-Za-z0-9][']*\\)\\]" "\\1{}_{\\2\\3}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z0-9][']*\\),\\([A-Za-z]\\)\\([0-9]+\\)\\([']*\\)\\]" "\\1{}_{\\2\\3{\\5}_{\\4}}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z]\\)\\([0-9]+\\)\\([']*\\),\\([A-Za-z0-9][']*\\)\\]" "\\1{}_{\\2{\\4}_{\\3}\\5}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z]\\)\\([0-9]+\\)\\([']*\\),\\([A-Za-z]\\)\\([0-9]+\\)\\([']*\\)\\]" "\\1{}_{\\2{\\4}_{\\3}\\5{\\7}_{\\6}}")
	;;  Three-dimensional
	;;    Each either a single letter or digit with optional prime marks, or a single letter followed by digits (no prime marks)
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z0-9][']*\\),\\([A-Za-z0-9][']*\\),\\([A-Za-z0-9][']*\\)\\]" "\\1{}_{\\2\\3\\4}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z0-9][']*\\),\\([A-Za-z0-9][']*\\),\\([A-Za-z]\\)\\([0-9]+\\)\\]" "\\1{}_{\\2\\3{\\4}_{\\5}}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z0-9][']*\\),\\([A-Za-z]\\)\\([0-9]+\\),\\([A-Za-z0-9][']*\\)\\]" "\\1{}_{\\2{\\3}_{\\4}\\5}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z0-9][']*\\),\\([A-Za-z]\\)\\([0-9]+\\),\\([A-Za-z]\\)\\([0-9]+\\)\\]" "\\1{}_{\\2{\\3}_{\\4}{\\5}_{\\6}}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z]\\)\\([0-9]+\\),\\([A-Za-z0-9][']*\\),\\([A-Za-z0-9][']*\\)\\]" "\\1{}_{{\\2}_{\\3}\\4\\5}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z]\\)\\([0-9]+\\),\\([A-Za-z0-9][']*\\),\\([A-Za-z]\\)\\([0-9]+\\)\\]" "\\1{}_{{\\2}_{\\3}\\4{\\5}_{\\6}}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z]\\)\\([0-9]+\\),\\([A-Za-z]\\)\\([0-9]+\\),\\([A-Za-z0-9][']*\\)\\]" "\\1{}_{{\\2}_{\\3}{\\4}_{\\5}\\6}")
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z]\\)\\([0-9]+\\),\\([A-Za-z]\\)\\([0-9]+\\),\\([A-Za-z]\\)\\([0-9]+\\)\\]" "\\1{}_{{\\2}_{\\3}{\\4}_{\\5}{\\6}_{\\7}}")
	;;  Four-dimensional
	;;    Each either a single letter or digit with optional prime marks
	("\\(\\<[a-z][a-zA-Z0-9']*\\|\\<[A-Z]\\)\\[\\([A-Za-z0-9][']*\\),\\([A-Za-z0-9][']*\\),\\([A-Za-z0-9][']*\\),\\([A-Za-z0-9][']*\\)\\]" "\\1{}_{\\2\\3\\4\\5}")
	;;  Subscript that has generators
	;; (Note use of spaces around \\2 etc. to allow contents to be properly expanded)
	;;    Simple generator
	("\\([^ \t\n]\\)\\[\\([^],<]*<-\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\)\\)\\]"
	 "\\1{}\\\\limits_{ \\2 }")
	;;    Two generators
	("\\([^ \t\n]\\)\\[\\([^],<]*<-\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\)\\),\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\)\\]"
	 "\\1{}\\\\limits_{\\\\genfrac{}{}{0pt}{1}{ \\2 }{ \\5 }}")
	;;    Three generators
	("\\([^ \t\n]\\)\\[\\([^],<]*<-\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\)\\),\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\),\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\)\\]"
	 "\\1{}\\\\limits_{\\\\genfrac{}{}{0pt}{1}{\\\\genfrac{}{}{0pt}{1}{ \\2 }{ \\5 }}{ \\7 }}")
	;;    Four generators
	("\\([^ \t\n]\\)\\[\\([^],<]*<-\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\)\\),\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\),\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\),\\([^][(){},]*\\|[^][(){},]*\\([[({][^][(){}]*[])}][^][(){},]*\\)*\\)\\]"
	 "\\1{}\\\\limits_{\\\\genfrac{}{}{0pt}{1}{\\\\genfrac{}{}{0pt}{1}{\\\\genfrac{}{}{0pt}{1}{ \\2 }{ \\5 }}{ \\7 }}{ \\9 }}")
	;; Greek letters
	("\\([^_]\\)\\<ALPHA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{A}\\2")
	("\\([^_]\\)\\<alpha\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\alpha}\\2")
	("\\([^_]\\)\\<BETA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{B}\\2")
	("\\([^_]\\)\\<beta\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\beta}\\2")
	("\\([^_]\\)\\<GAMMA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Gamma}\\2")
	("\\([^_]\\)\\<gamma\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\gamma}\\2")
	("\\([^_]\\)\\<DELTA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Delta}\\2")
	("\\([^_]\\)\\<delta\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\delta}\\2")
	("\\([^_]\\)\\<EPSILON\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{E}\\2")
	("\\([^_]\\)\\<epsilon\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\epsilon}\\2")
	("\\([^_]\\)\\<ZETA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{Z}\\2")
	("\\([^_]\\)\\<zeta\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\zeta}\\2")
	("\\([^_]\\)\\<ETA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{H}\\2")
	("\\([^_]\\)\\<eta\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\eta}\\2")
	("\\([^_]\\)\\<THETA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Theta}\\2")
	("\\([^_]\\)\\<theta\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\theta}\\2")
	("\\([^_]\\)\\<IOTA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{I}\\2")
	("\\([^_]\\)\\<iota\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\iota}\\2")
	("\\([^_]\\)\\<KAPPA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{K}\\2")
	("\\([^_]\\)\\<kappa\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\kappa}\\2")
	("\\([^_]\\)\\<LAMBDA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Lambda}\\2")
	("\\([^_]\\)\\<lambda\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\lambda}\\2")
	("\\([^_]\\)\\<MU\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{M}\\2")
	("\\([^_]\\)\\<mu\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\mu}\\2")
	("\\([^_]\\)\\<NU\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{N}\\2")
	("\\([^_]\\)\\<nu\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\nu}\\2")
	("\\([^_]\\)\\<XI\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Xi}\\2")
	("\\([^_]\\)\\<xi\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\xi}\\2")
	("\\([^_]\\)\\<OMICRON\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{O}\\2")
	("\\([^_]\\)\\<omicron\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{o}\\2")
	("\\([^_]\\)\\<PI\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Pi}\\2")
	("\\([^_]\\)\\<pi\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\pi}\\2")
	("\\([^_]\\)\\<RHO\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{P}\\2")
	("\\([^_]\\)\\<rho\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\rho}\\2")
	("\\([^_]\\)\\<SIGMA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Sigma}\\2")
	("\\([^_]\\)\\<sigma\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\sigma}\\2")
	("\\([^_]\\)\\<TAU\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{T}\\2")
	("\\([^_]\\)\\<tau\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\tau}\\2")
	("\\([^_]\\)\\<UPSILON\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Upsilon}\\2")
	("\\([^_]\\)\\<upsilon\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\upsilon}\\2")
	("\\([^_]\\)\\<PHI\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Phi}\\2")
	("\\([^_]\\)\\<phi\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\phi}\\2")
	("\\([^_]\\)\\<CHI\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{X}\\2")
	("\\([^_]\\)\\<chi\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\chi}\\2")
	("\\([^_]\\)\\<PSI\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Psi}\\2")
	("\\([^_]\\)\\<psi\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\psi}\\2")
	("\\([^_]\\)\\<OMEGA\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\Omega}\\2")
	("\\([^_]\\)\\<omega\\([']*\\>\\|[0-9_]\\)" "\\1{}\\\\GREEK{\\\\omega}\\2")
	;; Trig functions etc.
	("\\([^_]\\)\\<arccos\\>" "\\1{}\\\\arccos{}")
	("\\([^_]\\)\\<arcsin\\>" "\\1{}\\\\arcsin{}")
	("\\([^_]\\)\\<arctan\\>" "\\1{}\\\\arctan{}")
;; arg?
	("\\([^_]\\)\\<cos\\>" "\\1{}\\\\cos{}")
	("\\([^_]\\)\\<cosh\\>" "\\1{}\\\\cosh{}")
	("\\([^_]\\)\\<cot\\>" "\\1{}\\\\cot{}")
	("\\([^_]\\)\\<coth\\>" "\\1{}\\\\coth{}")
	("\\([^_]\\)\\<csc\\>" "\\1{}\\\\csc{}")
;; deg?
	("\\([^_]\\)\\<det\\>" "\\1{}\\\\det{}")
;; dim?
	("\\([^_]\\)\\<exp\\>" "\\1{}\\\\exp{}")
	("\\([^_]\\)\\<gcd\\>" "\\1{}\\\\gcd{}")
;; hom?
	("\\([^_]\\)\\<inf\\>" "\\1{}\\\\inf{}")
;; ker?
	("\\([^_]\\)\\<lcm\\>" "\\1{}\\\\TYP{lcm}")
	("\\([^_]\\)\\<lg\\>" "\\1{}\\\\lg{}")
;; lim?
;; liminf?
;; limsup?
	("\\([^_]\\)\\<ln\\>" "\\1{}\\\\ln{}")
	("\\([^_]\\)\\<log\\>" "\\1{}\\\\log{}")
	("\\([^_]\\)\\<max\\>" "\\1{}\\\\max{}")
	("\\([^_]\\)\\<min\\>" "\\1{}\\\\min{}")
;; Pr?
	("\\([^_]\\)\\<sec\\>" "\\1{}\\\\sec{}")
	("\\([^_]\\)\\<sin\\>" "\\1{}\\\\sin{}")
	("\\([^_]\\)\\<sinh\\>" "\\1{}\\\\sinh{}")
	("\\([^_]\\)\\<sup\\>" "\\1{}\\\\sup{}")
	("\\([^_]\\)\\<tan\\>" "\\1{}\\\\tan{}")
	("\\([^_]\\)\\<tanh\\>" "\\1{}\\\\tanh{}")
	;; Mathematical operators
	("<->" "{}\\\\leftrightarrow{}")  ;must precede <- and ->
	("<-" "{}\\\\leftarrow{}")
	("|->" "{}\\\\mapsto{}")
	("->" "{}\\\\rightarrow{}")
	("\\([^_]\\)\\<IMPLIES\\>" "\\1{}\\\\rightarrow{}")
	("\\([^_]\\)\\<IFF\\>" "\\1{}\\\\leftrightarrow{}")
	("<=>" "{}\\\\Leftrightarrow{}")  ;must precede <= and =>
	("=>" "{}\\\\Rightarrow{}")
	("<=" "{}\\\\leq{}")
	(">=" "{}\\\\geq{}")
	("=/=" "{}\\\\neq{}")
	("~>" "{}\\\\leadsto{}")
	("===" "{}\\\\sequiv{}")
	("\\([^_]\\)\\<DOT\\>\\([^_]\\)" "\\1{}\\\\cdot{}\\2")
	("\\([^_]\\)\\<BY\\>\\([^_]\\)" "\\1{}\\\\times{}\\2")
	("\\([^_]\\)\\<TIMES\\>\\([^_]\\)" "\\1{}\\\\times{}\\2")
	("\\([^_]\\)\\<CROSS\\>\\([^_]\\)" "\\1{}\\\\times{}\\2")
	("\\([^_]\\)\\<UNION\\>\\([^_]\\)" "\\1{}\\\\cup{}\\2")
	("\\([^_]\\)\\<INTERSECTION\\>\\([^_]\\)" "\\1{}\\\\cap{}\\2")
	("\\([^_]\\)\\<CUP\\>\\([^_]\\)" "\\1{}\\\\cup{}\\2")
	("\\([^_]\\)\\<CAP\\>\\([^_]\\)" "\\1{}\\\\cap{}\\2")
	("\\([^_]\\)\\<BOTTOM\\>\\([^_]\\)" "\\1{}\\\\bot{}\\2")
	("\\([^_]\\)\\<TOP\\>\\([^_]\\)" "\\1{}\\\\top{}\\2")
	("\\([^_]\\)\\<SUM\\>\\([^_]\\)" "\\1{}\\\\sum{}\\2")
	("\\([^_]\\)\\<PROD\\>\\([^_]\\)" "\\1{}\\\\prod{}\\2")
	("\\([^_]\\)\\<INTEGRAL\\>\\([^_]\\)" "\\1{}\\\\int{}\\2")
	("\\([^_]\\)\\<EMPTYSET\\>\\([^_]\\)" "\\1{}\\\\emptyset{}\\2")
	("\\([^_]\\)\\<SEQUIV\\>\\([^_]\\)" "\\1{}\\\\sequiv{}\\2")
	("\\([^_]\\)\\<EQUIV\\>\\([^_]\\)" "\\1{}\\\\equiv{}\\2")
	("\\([^_]\\)\\<NOTEQUIV\\>\\([^_]\\)" "\\1{}\\\\not\\\\equiv{}\\2")
	("\\([^_]\\)\\<EQ\\>\\([^_]\\)" "\\1=\\2")
	("\\([^_]\\)\\<LT\\>\\([^_]\\)" "\\1<{}\\2")
	("\\([^_]\\)\\<GT\\>\\([^_]\\)" "\\1>\\2")
	("\\([^_]\\)\\<LE\\>\\([^_]\\)" "\\1{}\\\\leq{}\\2")
	("\\([^_]\\)\\<GE\\>\\([^_]\\)" "\\1{}\\\\geq{}\\2")
	("\\([^_]\\)\\<NE\\>\\([^_]\\)" "\\1{}\\\\neq{}\\2")
	("\\([^_]\\)\\<AND\\>\\([^_]\\)" "\\1{}\\\\wedge{}\\2")
	("\\([^_]\\)\\<OR\\>\\([^_]\\)" "\\1{}\\\\vee{}\\2")
	("\\([^_]\\)\\<NOT\\>\\([^_]\\)" "\\1{}\\\\neg{}\\2")
	("\\([^_]\\)\\<XOR\\>\\([^_]\\)" "\\1{}\\\\xor{}\\2")
	("\\([^_]\\)\\<NAND\\>\\([^_]\\)" "\\1{}\\\\nand{}\\2")
	("\\([^_]\\)\\<NOR\\>\\([^_]\\)" "\\1{}\\\\nor{}\\2")
	("\\([^_]\\)\\<INF\\>\\([^_]\\)" "\\1{}\\\\infty{}\\2")
	("\\([^_]\\)\\<INFINITY\\>\\([^_]\\)" "\\1{}\\\\infty{}\\2")
	("\\([^_]\\)\\<SQRT\\>\\([^_]\\)" "\\1{}\\\\surd{}\\2")
	("\\([^_]\\)\\<EQV\\>\\([^_]\\)" "\\1{}\\\\equiv{}\\2")
	("\\([^_]\\)\\<EQUIV\\>\\([^_]\\)" "\\1{}\\\\equiv{}\\2")
	("\\([^_]\\)\\<CIRC\\>\\([^_]\\)" "\\1{}\\\\circ{}\\2")
	("\\([^_]\\)\\<RING\\>\\([^_]\\)" "\\1{}\\\\circ{}\\2")
	("\\([^_]\\)\\<COMPOSE\\>\\([^_]\\)" "\\1{}\\\\circ{}\\2")
	("\\([^_]\\)\\<VDASH\\>\\([^_]\\)" "\\1{}\\\\vdash{}\\2")
	("\\([^_]\\)\\<TURNSTILE\\>\\([^_]\\)" "\\1{}\\\\vdash{}\\2")
	("\\([^_]\\)\\<FORALL\\>\\([ \t]*([^()]*)\\)" "\\1{}\\\\forall{}\\2\\\\;")
	("\\([^_]\\)\\<FORALL\\>\\([^_]\\)" "\\1{}\\\\forall{}\\2")
	("\\([^_]\\)\\<EXISTS\\>\\([^_]\\)" "\\1{}\\\\exists{}\\2")
	("\\([^_]\\)\\<BIGAND\\>\\([^_]\\)" "\\1{}\\\\bigwedge{}\\2")
	("\\([^_]\\)\\<ALL\\>\\([^_]\\)" "\\1{}\\\\bigwedge{}\\2")
	("\\([^_]\\)\\<BIGOR\\>\\([^_]\\)" "\\1{}\\\\bigvee{}\\2")
	("\\([^_]\\)\\<ANY\\>\\([^_]\\)" "\\1{}\\\\bigvee{}\\2")
	("\\([^_]\\)\\<BIGCAP\\>\\([^_]\\)" "\\1{}\\\\bigcap{}\\2")
	("\\([^_]\\)\\<BIGINTERSECT\\>\\([^_]\\)" "\\1{}\\\\bigcap{}\\2")
	("\\([^_]\\)\\<BIGCUP\\>\\([^_]\\)" "\\1{}\\\\bigcup{}\\2")
	("\\([^_]\\)\\<BIGUNION\\>\\([^_]\\)" "\\1{}\\\\bigcup{}\\2")
	("\\([^_]\\)\\<OTIMES\\>\\([^_]\\)" "\\1{}\\\\otimes{}\\2")
	("\\([^_]\\)\\<ODOT\\>\\([^_]\\)" "\\1{}\\\\odot{}\\2")
	("\\([^_]\\)\\<CIRCLEDAST\\>\\([^_]\\)" "\\1{}\\\\circledast{}\\2")
	("\\([^_]\\)\\<BOXTIMES\\>\\([^_]\\)" "\\1{}\\\\boxtimes{}\\2")
	("\\([^_]\\)\\<BOXDOT\\>\\([^_]\\)" "\\1{}\\\\boxdot{}\\2")
	("\\([^_]\\)\\<DIV\\>\\([^_]\\)" "\\1{}\\\\div{}\\2")
	("\\([^_]\\)\\<OSLASH\\>\\([^_]\\)" "\\1{}\\\\oslash{}\\2")
	("\\([^_]\\)\\<DOT\\>\\([^_]\\)" "\\1{}\\\\cdot{}\\2")
	("\\([^_]\\)\\<TIMES\\>\\([^_]\\)" "\\1{}\\\\times{}\\2")
	("\\([^_]\\)\\<DIV\\>\\([^_]\\)" "\\1{}\\\\div{}\\2")
	("\\([^_]\\)\\<DOTPLUS\\>\\([^_]\\)" "\\1{}\\\\dotplus{}\\2")
	("\\([^_]\\)\\<DOTMINUS\\>\\([^_]\\)" "\\1{}\\\\dotminus{}\\2")
	("\\([^_]\\)\\<DOTTIMES\\>\\([^_]\\)" "\\1{}\\\\dottimes{}\\2")
	("\\([^_]\\)\\<OPLUS\\>\\([^_]\\)" "\\1{}\\\\oplus{}\\2")
	("\\([^_]\\)\\<OMINUS\\>\\([^_]\\)" "\\1{}\\\\ominus{}\\2")
	("\\([^_]\\)\\<OTIMES\\>\\([^_]\\)" "\\1{}\\\\otimes{}\\2")
	("\\([^_]\\)\\<OSLASH\\>\\([^_]\\)" "\\1{}\\\\oslash{}\\2")
	("\\([^_]\\)\\<ODOT\\>\\([^_]\\)" "\\1{}\\\\odot{}\\2")
	("\\([^_]\\)\\<CIRCLEDAST\\>\\([^_]\\)" "\\1{}\\\\circledast{}\\2")
	("\\([^_]\\)\\<BOXPLUS\\>\\([^_]\\)" "\\1{}\\\\boxplus{}\\2")
	("\\([^_]\\)\\<BOXMINUS\\>\\([^_]\\)" "\\1{}\\\\boxminus{}\\2")
	("\\([^_]\\)\\<BOXTIMES\\>\\([^_]\\)" "\\1{}\\\\boxtimes{}\\2")
	("\\([^_]\\)\\<BOXDOT\\>\\([^_]\\)" "\\1{}\\\\boxdot{}\\2")
	("\\([^_]\\)\\<BOXSLASH\\>\\([^_]\\)" "\\1{}\\\\boxslash{}\\2")
	("\\([^_]\\)\\<CAPCAP\\>\\([^_]\\)" "\\1{}\\\\Cap{}\\2")
	("\\([^_]\\)\\<UPLUS\\>\\([^_]\\)" "\\1{}\\\\uplus{}\\2")
	("\\([^_]\\)\\<CUPCUP\\>\\([^_]\\)" "\\1{}\\\\Cup{}\\2")
	("\\([^_]\\)\\<SETMINUS\\>\\([^_]\\)" "\\1{}\\\\setminus{}\\2")
	("\\([^_]\\)\\<SQCAP\\>\\([^_]\\)" "\\1{}\\\\sqcap{}\\2")
	("\\([^_]\\)\\<SQCUP\\>\\([^_]\\)" "\\1{}\\\\sqcup{}\\2")
	("\\([^_]\\)\\<CURLYAND\\>\\([^_]\\)" "\\1{}\\\\curlywedge{}\\2")
	("\\([^_]\\)\\<CURLYOR\\>\\([^_]\\)" "\\1{}\\\\curlyvee{}\\2")
	("\\([^_]\\)\\<SIMEQ\\>\\([^_]\\)" "\\1{}\\\\simeq{}\\2")
	("\\([^_]\\)\\<SIM\\>\\([^_]\\)" "\\1{}\\\\sim{}\\2")
	("\\([^_]\\)\\<APPROX\\>\\([^_]\\)" "\\1{}\\\\approx{}\\2")
	("\\([^_]\\)\\<APPROXEQ\\>\\([^_]\\)" "\\1{}\\\\approxeq{}\\2")
	("\\([^_]\\)\\<BUMPEQV\\>\\([^_]\\)" "\\1{}\\\\Bumpeq{}\\2")
	("\\([^_]\\)\\<DOTEQDOT\\>\\([^_]\\)" "\\1{}\\\\doteqdot{}\\2")
	("\\([^_]\\)\\<EQRING\\>\\([^_]\\)" "\\1{}\\\\eqcirc{}\\2")
	("\\([^_]\\)\\<RINGEQ\\>\\([^_]\\)" "\\1{}\\\\circeq{}\\2")
	("\\([^_]\\)\\<EQDEL\\>\\([^_]\\)" "\\1{}\\\\triangleq{}\\2")
	("\\([^_]\\)\\<NSIMEQ\\>\\([^_]\\)" "\\1{}\\\\not\\\\simeq{}\\2")
	("\\([^_]\\)\\<NAPPROX\\>\\([^_]\\)" "\\1{}\\\\not\\\\approx{}\\2")
	("\\([^_]\\)\\<NEQV\\>\\([^_]\\)" "\\1{}\\\\not\\\\equiv{}\\2")
	("\\([^_]\\)\\<NSEQV\\>\\([^_]\\)" "\\1{}\\\\not\\\\sequiv{}\\2")
	("<<<" "{}\\\\lll{}")
	("<<" "{}\\\\ll{}")
	("\\([^_]\\)\\<DOTLT\\>\\([^_]\\)" "\\1{}\\\\lessdot{}\\2")
	(">>>" "{}\\\\ggg{}")
	(">>" "{}\\\\gg{}")
	("\\([^_]\\)\\<DOTGT\\>\\([^_]\\)" "\\1{}\\\\gtrdot{}\\2")
	("\\([^_]\\)\\<NLT\\>\\([^_]\\)" "\\1{}\\\\nless{}\\2")
	("\\([^_]\\)\\<NGT\\>\\([^_]\\)" "\\1{}\\\\ngtr{}\\2")
	("\\([^_]\\)\\<NLE\\>\\([^_]\\)" "\\1{}\\\\nleq{}\\2")
	("\\([^_]\\)\\<NGE\\>\\([^_]\\)" "\\1{}\\\\ngeq{}\\2")
	("\\([^_]\\)\\<SUBSET\\>\\([^_]\\)" "\\1{}\\\\subset{}\\2")
	("\\([^_]\\)\\<SUBSETEQ\\>\\([^_]\\)" "\\1{}\\\\subseteq{}\\2")
	("\\([^_]\\)\\<SUBSETNEQ\\>\\([^_]\\)" "\\1{}\\\\subsetneq{}\\2")
	("\\([^_]\\)\\<SUBSUB\\>\\([^_]\\)" "\\1{}\\\\Subset{}\\2")
	("\\([^_]\\)\\<SUPSET\\>\\([^_]\\)" "\\1{}\\\\supset{}\\2")
	("\\([^_]\\)\\<SUPSETEQ\\>\\([^_]\\)" "\\1{}\\\\supseteq{}\\2")
	("\\([^_]\\)\\<SUPSETNEQ\\>\\([^_]\\)" "\\1{}\\\\supsetneq{}\\2")
	("\\([^_]\\)\\<SUPSUP\\>\\([^_]\\)" "\\1{}\\\\Supset{}\\2")
	("\\([^_]\\)\\<NSUBSET\\>\\([^_]\\)" "\\1{}\\\\not\\\\subset{}\\2")
	("\\([^_]\\)\\<NSUPSET\\>\\([^_]\\)" "\\1{}\\\\not\\\\supset{}\\2")
	("\\([^_]\\)\\<NSUBSETEQ\\>\\([^_]\\)" "\\1{}\\\\nsubseteq{}\\2")
	("\\([^_]\\)\\<NSUPSETEQ\\>\\([^_]\\)" "\\1{}\\\\nsupseteq{}\\2")
	("\\([^_]\\)\\<SQSUBSET\\>\\([^_]\\)" "\\1{}\\\\sqsubset{}\\2")
	("\\([^_]\\)\\<SQSUBSETEQ\\>\\([^_]\\)" "\\1{}\\\\sqsubseteq{}\\2")
	("\\([^_]\\)\\<SQSUPSET\\>\\([^_]\\)" "\\1{}\\\\sqsupset{}\\2")
	("\\([^_]\\)\\<SQSUPSETEQ\\>\\([^_]\\)" "\\1{}\\\\sqsupseteq{}\\2")
	("\\([^_]\\)\\<NSQSUBSET\\>\\([^_]\\)" "\\1{}\\\\not\\\\sqsubset{}\\2")
	("\\([^_]\\)\\<NSQSUBSETEQ\\>\\([^_]\\)" "\\1{}\\\\not\\\\sqsubseteq{}\\2")
	("\\([^_]\\)\\<NSQSUPSET\\>\\([^_]\\)" "\\1{}\\\\not\\\\sqsupset{}\\2")
	("\\([^_]\\)\\<NSQSUPSETEQ\\>\\([^_]\\)" "\\1{}\\\\not\\\\sqsupseteq{}\\2")
	("\\([^_]\\)\\<PREC\\>\\([^_]\\)" "\\1{}\\\\prec{}\\2")
	("\\([^_]\\)\\<PRECEQ\\>\\([^_]\\)" "\\1{}\\\\preccurlyeq{}\\2")
	("\\([^_]\\)\\<PRECSIM\\>\\([^_]\\)" "\\1{}\\\\precsim{}\\2")
	("\\([^_]\\)\\<EQPREC\\>\\([^_]\\)" "\\1{}\\\\curlyeqprec{}\\2")
	("\\([^_]\\)\\<PRECNSIM\\>\\([^_]\\)" "\\1{}\\\\precnsim{}\\2")
	("\\([^_]\\)\\<SUCC\\>\\([^_]\\)" "\\1{}\\\\succ{}\\2")
	("\\([^_]\\)\\<SUCCEQ\\>\\([^_]\\)" "\\1{}\\\\succcurlyeq{}\\2")
	("\\([^_]\\)\\<SUCCSIM\\>\\([^_]\\)" "\\1{}\\\\succsim{}\\2")
	("\\([^_]\\)\\<EQSUCC\\>\\([^_]\\)" "\\1{}\\\\curlyeqsucc{}\\2")
	("\\([^_]\\)\\<SUCCNSIM\\>\\([^_]\\)" "\\1{}\\\\succnsim{}\\2")
	("\\([^_]\\)\\<NPREC\\>\\([^_]\\)" "\\1{}\\\\nprec{}\\2")
	("\\([^_]\\)\\<NSUCC\\>\\([^_]\\)" "\\1{}\\\\nsucc{}\\2")
	("\\([^_]\\)\\<NPRECEQ\\>\\([^_]\\)" "\\1{}\\\\not\\\\preceq{}\\2")
	("\\([^_]\\)\\<NSUCCEQ\\>\\([^_]\\)" "\\1{}\\\\not\\\\succeq{}\\2")
	("\\([^_]\\)\\<SMALLER\\>\\([^_]\\)" "\\1{<\\\\!\\\\\llap{$-$}}\\2")
	("\\([^_]\\)\\<SMALLEREQ\\>\\([^_]\\)" "\\1{\\\\leq\\\\!\\\\llap{\\\\raisebox{.15ex}[0cm][0cm]{$-$}}}\\2")
	("\\([^_]\\)\\<LARGER\\>\\([^_]\\)" "\\1{\\\\rlap{$-$}\\\\!>}\\2")
	("\\([^_]\\)\\<LARGEREQ\\>\\([^_]\\)" "\\1{\\\\rlap{\\\\raisebox{.15ex}[0cm][0cm]{$-$}}\\\\!\\\\geq}\\2")
	("\\([^_]\\)\\<IN\\>\\([^_]\\)" "\\1{}\\\\in{}\\2")
	("\\([^_]\\)\\<NOTIN\\>\\([^_]\\)" "\\1{}\\\\not\\\\in{}\\2")
	("\\([^_]\\)\\<CONTAINS\\>\\([^_]\\)" "\\1{}\\\\ni{}\\2")
	("\\([^_]\\)\\<NCONTAINS\\>\\([^_]\\)" "\\1{}\\\\not\\\\ni{}\\2")
	("\\([^_]\\)\\<DEGREES\\>\\([^_]\\)" "\\1{{}^\\\\circ}\\2")
	("\\([^_]\\)\\<UPARROW\\>\\([^_]\\)" "\\1{}\\\\uparrow{}\\2")
	("\\([^_]\\)\\<DOWNARROW\\>\\([^_]\\)" "\\1{}\\\\downarrow{}\\2")
	("\\([^_]\\)\\<UPDOWNARROW\\>\\([^_]\\)" "\\1{}\\\\updownarrow{}\\2")
	("\\([^_]\\)\\<NWARROW\\>\\([^_]\\)" "\\1{}\\\\nwarrow{}\\2")
	("\\([^_]\\)\\<NEARROW\\>\\([^_]\\)" "\\1{}\\\\nearrow{}\\2")
	("\\([^_]\\)\\<SEARROW\\>\\([^_]\\)" "\\1{}\\\\searrow{}\\2")
	("\\([^_]\\)\\<SWARROW\\>\\([^_]\\)" "\\1{}\\\\swarrow{}\\2")
	("<-/-" "{}\\\\nleftarrow{}")
	("-/->" "{}\\\\nrightarrow{}")
	("\\([^_]\\)\\<LEFTHARPOONUP\\>\\([^_]\\)" "\\1{}\\\\leftharpoonup{}\\2")
	("\\([^_]\\)\\<LEFTHARPOONDOWN\\>\\([^_]\\)" "\\1{}\\\\leftharpoondown{}\\2")
	("\\([^_]\\)\\<UPHARPOONRIGHT\\>\\([^_]\\)" "\\1{}\\\\upharpoonright{}\\2")
	("\\([^_]\\)\\<UPHARPOONLEFT\\>\\([^_]\\)" "\\1{}\\\\upharpoonleft{}\\2")
	("\\([^_]\\)\\<RIGHTHARPOONUP\\>\\([^_]\\)" "\\1{}\\\\rightharpoonup{}\\2")
	("\\([^_]\\)\\<RIGHTHARPOONDOWN\\>\\([^_]\\)" "\\1{}\\\\rightharpoondown{}\\2")
	("\\([^_]\\)\\<DOWNHARPOONRIGHT\\>\\([^_]\\)" "\\1{}\\\\downharpoonright{}\\2")
	("\\([^_]\\)\\<DOWNHARPOONLEFT\\>\\([^_]\\)" "\\1{}\\\\downharpoonleft{}\\2")
	("\\([^_]\\)\\<RIGHTLEFTARROWS\\>\\([^_]\\)" "\\1{}\\\\rightleftarrows{}\\2")
	("\\([^_]\\)\\<LEFTRIGHTARROWS\\>\\([^_]\\)" "\\1{}\\\\leftrightarrows{}\\2")
	("\\([^_]\\)\\<LEFTLEFTARROWS\\>\\([^_]\\)" "\\1{}\\\\leftleftarrows{}\\2")
	("\\([^_]\\)\\<UPUPARROWS\\>\\([^_]\\)" "\\1{}\\\\upuparrows{}\\2")
	("\\([^_]\\)\\<RIGHTRIGHTARROWS\\>\\([^_]\\)" "\\1{}\\\\rightrightarrows{}\\2")
	("\\([^_]\\)\\<DOWNDOWNARROWS\\>\\([^_]\\)" "\\1{}\\\\downdownarrows{}\\2")
	("\\([^_]\\)\\<RIGHTLEFTHARPOONS\\>\\([^_]\\)" "\\1{}\\\\rightleftharpoons{}\\2")
	("\\([^_]\\)\\<DEL\\>\\([^_]\\)" "\\1{}\\\\partial{}\\2")
	("\\([^_]\\)\\<PROD\\>\\([^_]\\)" "\\1{}\\\\prod{}\\2")
	("\\([^_]\\)\\<COPRODUCT\\>\\([^_]\\)" "\\1{}\\\\coprod{}\\2")
	("\\([^_]\\)\\<SUM\\>\\([^_]\\)" "\\1{}\\\\sum{}\\2")
	("\\([^_]\\)\\<BULLET\\>\\([^_]\\)" "\\1{}\\\\bullet{}\\2")
	("\\([^_]\\)\\<PROPTO\\>\\([^_]\\)" "\\1{}\\\\propto{}\\2")
	("\\([^_]\\)\\<DIVIDES\\>\\([^_]\\)" "\\1{}\\\\mid{}\\2")
	("\\([^_]\\)\\<PARALLEL\\>\\([^_]\\)" "\\1{}\\\\parallel{}\\2")
	("\\([^_]\\)\\<NPARALLEL\\>\\([^_]\\)" "\\1{}\\\\nparallel{}\\2")
	("\\([^_]\\)\\<WREATH\\>\\([^_]\\)" "\\1{}\\\\wr{}\\2")
	("\\([^_]\\)\\<BUMPEQ\\>\\([^_]\\)" "\\1{}\\\\bumpeq{}\\2")
	("\\([^_]\\)\\<DOTEQ\\>\\([^_]\\)" "\\1{}\\\\doteq{}\\2")
	("\\([^_]\\)\\<CIRCLEDRING\\>\\([^_]\\)" "\\1{}\\\\circledcirc{}\\2")
	("\\([^_]\\)\\<DASHV\\>\\([^_]\\)" "\\1{}\\\\dashv{}\\2")
	("\\([^_]\\)\\<DIAMOND\\>\\([^_]\\)" "\\1{}\\\\diamond{}\\2")
	("\\([^_]\\)\\<STAR\\>\\([^_]\\)" "\\1{}\\\\star{}\\2")
	("\\([^_]\\)\\<BIGODOT\\>\\([^_]\\)" "\\1{}\\\\bigodot{}\\2")
	("\\([^_]\\)\\<BIGOPLUS\\>\\([^_]\\)" "\\1{}\\\\bigoplus{}\\2")
	("\\([^_]\\)\\<BIGUPLUS\\>\\([^_]\\)" "\\1{}\\\\biguplus{}\\2")
	("\\([^_]\\)\\<BIGOTIMES\\>\\([^_]\\)" "\\1{}\\\\bigotimes{}\\2")
	("\\([^_]\\)\\<JOIN\\>\\([^_]\\)" "\\1{}\\\\Join{}\\2")
	("\\([^_]\\)\\<UPPLUS\\>\\([^_]\\)" "\\1{}\\\\upplus{}\\2")
	("\\([^_]\\)\\<UPMINUS\\>\\([^_]\\)" "\\1{}\\\\upminus{}\\2")
	("\\([^_]\\)\\<UPTIMES\\>\\([^_]\\)" "\\1{}\\\\uptimes{}\\2")
	("\\([^_]\\)\\<UPDOT\\>\\([^_]\\)" "\\1{}\\\\updot{}\\2")
	("\\([^_]\\)\\<UPSLASH\\>\\([^_]\\)" "\\1{}\\\\upslash{}\\2")
	("\\([^_]\\)\\<DOWNPLUS\\>\\([^_]\\)" "\\1{}\\\\downplus{}\\2")
	("\\([^_]\\)\\<DOWNMINUS\\>\\([^_]\\)" "\\1{}\\\\downminus{}\\2")
	("\\([^_]\\)\\<DOWNTIMES\\>\\([^_]\\)" "\\1{}\\\\downtimes{}\\2")
	("\\([^_]\\)\\<DOWNDOT\\>\\([^_]\\)" "\\1{}\\\\downdot{}\\2")
	("\\([^_]\\)\\<DOWNSLASH\\>\\([^_]\\)" "\\1{}\\\\downslash{}\\2")
	("\\([^_]\\)\\<CHOPPLUS\\>\\([^_]\\)" "\\1{}\\\\chopplus{}\\2")
	("\\([^_]\\)\\<CHOPMINUS\\>\\([^_]\\)" "\\1{}\\\\chopminus{}\\2")
	("\\([^_]\\)\\<CHOPTIMES\\>\\([^_]\\)" "\\1{}\\\\choptimes{}\\2")
	("\\([^_]\\)\\<CHOPDOT\\>\\([^_]\\)" "\\1{}\\\\chopdot{}\\2")
	("\\([^_]\\)\\<CHOPSLASH\\>\\([^_]\\)" "\\1{}\\\\chopslash{}\\2")
	("\\([^_]\\)\\<EXACTPLUS\\>\\([^_]\\)" "\\1{}\\\\exactplus{}\\2")
	("\\([^_]\\)\\<EXACTMINUS\\>\\([^_]\\)" "\\1{}\\\\exactminus{}\\2")
	("\\([^_]\\)\\<EXACTTIMES\\>\\([^_]\\)" "\\1{}\\\\exacttimes{}\\2")
	("\\([^_]\\)\\<EXACTDOT\\>\\([^_]\\)" "\\1{}\\\\exactdot{}\\2")
	("\\([^_]\\)\\<EXACTSLASH\\>\\([^_]\\)" "\\1{}\\\\exactslash{}\\2")
	("\\([^_]\\)\\<TOTALLT\\>\\([^_]\\)" "\\1{}\\\\totallss{}\\2")
	("\\([^_]\\)\\<TOTALLE\\>\\([^_]\\)" "\\1{}\\\\totalleq{}\\2")
	("\\([^_]\\)\\<TOTALGE\\>\\([^_]\\)" "\\1{}\\\\totalgeq{}\\2")
	("\\([^_]\\)\\<TOTALGT\\>\\([^_]\\)" "\\1{}\\\\totalgtr{}\\2")
	("\\([^_]\\)\\<BITAND\\>\\([^_]\\)" "\\1{}\\\\twointersectand{}\\2")
	("\\([^_]\\)\\<BITOR\\>\\([^_]\\)" "\\1{}\\\\twointersector{}\\2")
	("\\([^_]\\)\\<BITXOR\\>\\([^_]\\)" "\\1{}\\\\twointersectxor{}\\2")
	("\\([^_]\\)\\<BITNOT\\>\\([^_]\\)" "\\1{}\\\\twointersectnot{}\\2")
	;; These are the old forms for floor, ceiling, etc.  New forms |\ /| etc. are below, with the brackets.
	("\\([^_]\\)\\<LF\\>\\([^_]\\)" "\\1{}\\\\lfloor{}\\2")
	("\\([^_]\\)\\<RF\\>\\([^_]\\)" "\\1{}\\\\rfloor{}\\2")
	("\\([^_]\\)\\<LC\\>\\([^_]\\)" "\\1{}\\\\lceil{}\\2")
	("\\([^_]\\)\\<RC\\>\\([^_]\\)" "\\1{}\\\\rceil{}\\2")
	("\\([^_]\\)\\<LHF\\>\\([^_]\\)" "\\1{}\\\\lhfloor{}\\2")
	("\\([^_]\\)\\<RHF\\>\\([^_]\\)" "\\1{}\\\\rhfloor{}\\2")
	("\\([^_]\\)\\<LHC\\>\\([^_]\\)" "\\1{}\\\\lhceil{}\\2")
	("\\([^_]\\)\\<RHC\\>\\([^_]\\)" "\\1{}\\\\rhceil{}\\2")
	("\\([^_]\\)\\<LHHF\\>\\([^_]\\)" "\\1{}\\\\lhhfloor{}\\2")
	("\\([^_]\\)\\<RHHF\\>\\([^_]\\)" "\\1{}\\\\rhhfloor{}\\2")
	("\\([^_]\\)\\<LHHC\\>\\([^_]\\)" "\\1{}\\\\lhhceil{}\\2")
	("\\([^_]\\)\\<RHHC\\>\\([^_]\\)" "\\1{}\\\\rhhceil{}\\2")
	("\\([^_]\\)\\<PP_SUM\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\sum}}\\2")
	("\\([^_]\\)\\<PP_PROD\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\prod}}\\2")
	("\\([^_]\\)\\<PP_AND\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\bigwedge}}\\2")
	("\\([^_]\\)\\<PP_OR\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\bigvee}}\\2")
	("\\([^_]\\)\\<PP_CAP\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\bigcap}}\\2")
	("\\([^_]\\)\\<PP_INTERSECT\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\bigcap}}\\2")
	("\\([^_]\\)\\<PP_CUP\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\bigcup}}\\2")
	("\\([^_]\\)\\<PP_UNION\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\bigcup}}\\2")
	("\\([^_]\\)\\<PP_ODOT\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\bigodot}}\\2")
	("\\([^_]\\)\\<PP_OPLUS\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\bigoplus}}\\2")
	("\\([^_]\\)\\<PP_UPLUS\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\biguplus}}\\2")
	("\\([^_]\\)\\<PP_OTIMES\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\bigotimes}}\\2")
	("\\([^_]\\)\\<PP_MAX\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\mathtt{MAX}}}\\2")
	("\\([^_]\\)\\<PP_MIN\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overrightarrow{\\\\mathtt{MIN}}}\\2")
	("\\([^_]\\)\\<PS_SUM\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\sum}}\\2")
	("\\([^_]\\)\\<PS_PROD\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\prod}}\\2")
	("\\([^_]\\)\\<PS_AND\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\bigwedge}}\\2")
	("\\([^_]\\)\\<PS_OR\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\bigvee}}\\2")
	("\\([^_]\\)\\<PS_CAP\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\bigcap}}\\2")
	("\\([^_]\\)\\<PS_INTERSECT\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\bigcap}}\\2")
	("\\([^_]\\)\\<PS_CUP\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\bigcup}}\\2")
	("\\([^_]\\)\\<PS_UNION\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\bigcup}}\\2")
	("\\([^_]\\)\\<PS_ODOT\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\bigodot}}\\2")
	("\\([^_]\\)\\<PS_OPLUS\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\bigoplus}}\\2")
	("\\([^_]\\)\\<PS_UPLUS\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\biguplus}}\\2")
	("\\([^_]\\)\\<PS_OTIMES\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\bigotimes}}\\2")
	("\\([^_]\\)\\<PS_MAX\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\mathtt{MAX}}}\\2")
	("\\([^_]\\)\\<PS_MIN\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrow{\\\\mathtt{MIN}}}\\2")
	("\\([^_]\\)\\<XPP_SUM\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\sum}}\\2")
	("\\([^_]\\)\\<XPP_PROD\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\prod}}\\2")
	("\\([^_]\\)\\<XPP_AND\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\bigwedge}}\\2")
	("\\([^_]\\)\\<XPP_OR\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\bigvee}}\\2")
	("\\([^_]\\)\\<XPP_CAP\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\bigcap}}\\2")
	("\\([^_]\\)\\<XPP_INTERSECT\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\bigcap}}\\2")
	("\\([^_]\\)\\<XPP_CUP\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\bigcup}}\\2")
	("\\([^_]\\)\\<XPP_UNION\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\bigcup}}\\2")
	("\\([^_]\\)\\<XPP_ODOT\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\bigodot}}\\2")
	("\\([^_]\\)\\<XPP_OPLUS\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\bigoplus}}\\2")
	("\\([^_]\\)\\<XPP_UPLUS\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\biguplus}}\\2")
	("\\([^_]\\)\\<XPP_OTIMES\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\bigotimes}}\\2")
	("\\([^_]\\)\\<XPP_MAX\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\mathtt{MAX}}}\\2")
	("\\([^_]\\)\\<XPP_MIN\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overcirclerightarrow{\\\\mathtt{MIN}}}\\2")
	("\\([^_]\\)\\<XPS_SUM\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\sum}}\\2")
	("\\([^_]\\)\\<XPS_PROD\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\prod}}\\2")
	("\\([^_]\\)\\<XPS_AND\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\bigwedge}}\\2")
	("\\([^_]\\)\\<XPS_OR\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\bigvee}}\\2")
	("\\([^_]\\)\\<XPS_CAP\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\bigcap}}\\2")
	("\\([^_]\\)\\<XPS_INTERSECT\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\bigcap}}\\2")
	("\\([^_]\\)\\<XPS_CUP\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\bigcup}}\\2")
	("\\([^_]\\)\\<XPS_UNION\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\bigcup}}\\2")
	("\\([^_]\\)\\<XPS_ODOT\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\bigodot}}\\2")
	("\\([^_]\\)\\<XPS_OPLUS\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\bigoplus}}\\2")
	("\\([^_]\\)\\<XPS_UPLUS\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\biguplus}}\\2")
	("\\([^_]\\)\\<XPS_OTIMES\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\bigotimes}}\\2")
	("\\([^_]\\)\\<XPS_MAX\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\mathtt{MAX}}}\\2")
	("\\([^_]\\)\\<XPS_MIN\\>\\([^_]\\)" "\\1{}\\\\mathop{\\\\overleftarrowcircle{\\\\mathtt{MIN}}}\\2")
	("\\.\\.\\." "{}\\\\ldots{}")
	;; Various brackets, observing interior space (important that llbracket come after langle)
	("\\[ " "[{}\\\\,")
	(" \\]" "{}\\\\,]")
	("<| " "<|\\\\,")
	("<|\\([^)]\\)" "{}\\\\langle{}\\1")
	(" |>" "{}\\\\,|>")
	("|>" "{}\\\\rangle{}")
	("<<| " "<<|\\\\,")
	("<<|" "{}\\\\langle\\\\!\\\\langle{}")
	(" |>>" "{}\\\\,|>>")
	("|>>" "{}\\\\rangle\\\!\\\\rangle{}")
	("</ " "</\\\\,")
	("</" "{}\\\\ulcorner{}")
	(" />" "{}\\\\,/>")
	("/>" "{}\\\\urcorner{}")
	("\\[\\\\ " "[\\\\\\\\,")
	("\\[\\\\" "{}\\\\llbracket{}")
	(" \\\\\\]" "{}\\\\,\\\\]")
	("\\\\\\]" "{}\\\\rrbracket{}")
	("\\(^\\|[^[{<|/\\.*]\\)|||\\\\" "\\1{}\\\\lhhfloor{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)|||\\\\" "\\1{}\\\\lhhfloor{}\\2")
	("\\(^\\|[^/\\.*]\\)/|||" "\\1{}\\\\rhhfloor{}\\2")
	("\\(^\\|[^/\\.*]\\)/|||" "\\1{}\\\\rhhfloor{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)|||/" "\\1{}\\\\lhhceil{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)|||/" "\\1{}\\\\lhhceil{}\\2")
	("\\(^\\|[^/\\.*]\\)\\\\|||" "\\1{}\\\\rhhceil{}\\2")
	("\\(^\\|[^/\\.*]\\)\\\\|||" "\\1{}\\\\rhhceil{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)||\\\\" "\\1{}\\\\lhfloor{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)||\\\\" "\\1{}\\\\lhfloor{}\\2")
	("\\(^\\|[^/\\.*]\\)/||" "\\1{}\\\\rhfloor{}\\2")
	("\\(^\\|[^/\\.*]\\)/||" "\\1{}\\\\rhfloor{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)||/" "\\1{}\\\\lhceil{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)||/" "\\1{}\\\\lhceil{}\\2")
	("\\(^\\|[^/\\.*]\\)\\\\||" "\\1{}\\\\rhceil{}\\2")
	("\\(^\\|[^/\\.*]\\)\\\\||" "\\1{}\\\\rhceil{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)|\\\\" "\\1{}\\\\lfloor{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)|\\\\" "\\1{}\\\\lfloor{}\\2")
	("\\(^\\|[^/\\.*]\\)/|" "\\1{}\\\\rfloor{}\\2")
	("\\(^\\|[^/\\.*]\\)/|" "\\1{}\\\\rfloor{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)|/" "\\1{}\\\\lceil{}\\2")
	("\\(^\\|[^[{<|/\\.*]\\)|/" "\\1{}\\\\lceil{}\\2")
	("\\(^\\|[^/\\.*]\\)\\\\|" "\\1{}\\\\rceil{}\\2")
	("\\(^\\|[^/\\.*]\\)\\\\|" "\\1{}\\\\rceil{}\\2")
	;; Literals
	("\\<\\([0-9.]+\\)_\\([0-9][0-9]+\\)\\>" "{}\\\\mathtt{\\1}_{\\2}")
	("\\<\\([0-9.]+\\)_\\([0-9]\\)\\>" "{\\1}_{\\\\,\\2}")
	("\\<\\([0-9A-Fa-f.]+\\)_\\([0-9]+\\)\\>" "{}\\\\mathtt{\\1}_{\\2}")
	("\\<\\([0-9.]+\\)_TWO\\>" "{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc two}}")
	("\\<\\([0-9A-Fa-f.]+\\)_TWO\\>" "{}\\\\mathrm{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc two}}")
	("\\<\\([0-9.]+\\)_THREE\\>" "{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc three}}")
	("\\<\\([0-9A-Fa-f.]+\\)_THREE\\>" "{}\\\\mathrm{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc three}}")
	("\\<\\([0-9.]+\\)_FOUR\\>" "{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc four}}")
	("\\<\\([0-9A-Fa-f.]+\\)_FOUR\\>" "{}\\\\mathrm{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc four}}")
	("\\<\\([0-9.]+\\)_FIVE\\>" "{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc five}}")
	("\\<\\([0-9A-Fa-f.]+\\)_FIVE\\>" "{}\\\\mathrm{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc five}}")
	("\\<\\([0-9.]+\\)_SIX\\>" "{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc six}}")
	("\\<\\([0-9A-Fa-f.]+\\)_SIX\\>" "{}\\\\mathrm{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc six}}")
	("\\<\\([0-9.]+\\)_SEVEN\\>" "{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc seven}}")
	("\\<\\([0-9A-Fa-f.]+\\)_SEVEN\\>" "{}\\\\mathrm{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc seven}}")
	("\\<\\([0-9.]+\\)_EIGHT\\>" "{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc eight}}")
	("\\<\\([0-9A-Fa-f.]+\\)_EIGHT\\>" "{}\\\\mathrm{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc eight}}")
	("\\<\\([0-9.]+\\)_NINE\\>" "{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc nine}}")
	("\\<\\([0-9A-Fa-f.]+\\)_NINE\\>" "{}\\\\mathrm{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc nine}}")
	("\\<\\([0-9.]+\\)_TEN\\>" "{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc ten}}")
	("\\<\\([0-9A-Fa-f.]+\\)_TEN\\>" "{}\\\\mathrm{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc ten}}")
	("\\<\\([0-9.]+\\)_ELEVEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc eleven}}")
	("\\<\\([0-9A-Fa-f.]+\\)_ELEVEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc eleven}}")
	("\\<\\([0-9.]+\\)_TWELVE\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc twelve}}")
	("\\<\\([0-9A-Fa-fXx.]+\\)_TWELVE\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc twelve}}")
	("\\<\\([0-9.]+\\)_THIRTEEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc thirteen}}")
	("\\<\\([0-9A-Fa-f.]+\\)_THIRTEEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc thirteen}}")
	("\\<\\([0-9.]+\\)_FOURTEEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc fourteen}}")
	("\\<\\([0-9A-Fa-f.]+\\)_FOURTEEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc fourteen}}")
	("\\<\\([0-9.]+\\)_FIFTEEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc fifteen}}")
	("\\<\\([0-9A-Fa-f.]+\\)_FIFTEEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc fifteen}}")
	("\\<\\([0-9.]+\\)_SIXTEEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc sixteen}}")
	("\\<\\([0-9A-Fa-f.]+\\)_SIXTEEN\\>" "{}\\\\mathtt{\\1}_{\\\\,\\\\\hbox{\\\\small\\\\sc sixteen}}")
	;; Keywords
	("\\(^\\|[^{_\\\\]\\)\\<\\(grammar\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(trait\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(value\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(object\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(extends\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(comprises\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(excludes\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(where\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(do\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(at\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(also\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(end\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(for\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(if\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(then\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(else\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(elif\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(while\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(case\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(of\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(typed\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(asif\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(fn\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(label\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(exit\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(with\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(atomic\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(tryatomic\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(pure\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(io\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(throw\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(throws\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(try\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(catch\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(forbid\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(finally\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(dispatch\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(in\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(typecase\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(requires\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(ensures\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(provided\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(invariant\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(property\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(idiom\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(hidden\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(settable\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(wrapped\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(outcome\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(getter\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(setter\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(opr\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(var\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(nat\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(native\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(int\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(bool\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(juxtaposition\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(coerce\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(coerces\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(widens\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(or\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(dim\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(unit\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(default\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(absorbs\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(SI_unit\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{SI{\\\\char'137}unit}\\3")  ;*** special handling
	("\\(^\\|[^{_\\\\]\\)\\<\\(spawn\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(test\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(static\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(component\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(api\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(import\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(export\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(except\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(public\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(private\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(abstract\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(override\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(syntax\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(most\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(type\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\KWD{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(self\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\mathord{\\\\KWD{\\2}}\\3")
	;; Operators for units
	("\\(^\\|[^{_\\\\]\\)\\<\\(per\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\mathbin{\\\\TYP{\\2}}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(square\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\mathbin{\\\\TYP{\\2}}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(cubic\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\mathbin{\\\\TYP{\\2}}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(squared\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\TYP{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(cubed\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\TYP{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(inverse\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\mathbin{\\\\TYP{\\2}}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(reciprocal\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\mathbin{\\\\TYP{\\2}}\\3");
	("\\(^\\|[^{_\\\\]\\)\\<\\(dimensionless\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\mathbin{\\\\TYP{\\2}}\\3")
	;; Standard units
	("\\(^\\|[^{_\\\\]\\)\\<\\(\\|yotta\\|zetta\\|exa\\|peta\\|tera\\|giga\\|mega\\|kilo\\|hecto\\|deka\\|deci\\|centi\\|milli\\|micro\\|nano\\|pico\\|femto\\|atto\\|zepto\\|yocto\\)\\(\\|meter\\|meters\\|gram\\|grams\\|second\\|seconds\\|ampere\\|amperes\\|kelvin\\|kelvins\\|mole\\|moles\\|candela\\|candelas\\|radian\\|radians\\|steradian\\|steradians\\|hertz\\|newton\\|newtons\\|pascal\\|pascals\\|joule\\|joules\\|watt\\|watts\\|coulomb\\|coulombs\\|volt\\|volts\\|farad\\|farads\\|ohm\\|ohms\\|siemens\\|weber\\|webers\\|tesla\\|teslas\\|henry\\|henries\\|lumen\\|lumens\\|lux\\|becquerel\\|becquerels\\|gray\\|grays\\|katal\\|katals\\|metricTon\\|metricTons\\|tonne\\|tonnes\\|liter\\|liters\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\TYP{\\2\\3}\\4")
	("\\(^\\|[^{_\\\\]\\)\\<\\(kilohm\\|kilohms\\|megohm\\|megohms\\|minute\\|minutes\\|hour\\|hours\\|day\\|days\\|degreeOfAngle\\|degrees\\|minuteOfAngle\\|minutesOfAngle\\|secondOfAngle\\|secondsOfAngle\\|bit\\|bits\\|byte\\|bytes\\|inch\\|inches\\|foot\\|feet\\|yard\\|yards\\|mile\\|miles\\|rod\\|rods\\|furlong\\|furlongs\\|surveyFoot\\|surveyFeet\\|surveyMile\\|surveyMiles\\|nauticalMile\\|nauticalMiles\\|knot\\|knots\\|week\\|weeks\\|fortnight\\|fortnights\\|microfortnight\\|microfortnights\\|gallon\\|gallons\\|fluidQuart\\|fluidQuarts\\|fluidPint\\|fluidPints\\|fluidCup\\|fluidCups\\|fluidOunce\\|fluidOunces\\|fluidDram\\|fluidDrams\\|minim\\|minims\\|traditionalTablespoon\\|traditionalTablespoons\\|traditionalTeaspoon\\|traditionalTeaspoons\\|federalTablespoon\\|federalTablespoons\\|federalTeaspoon\\|federalTeaspoons\\|dryPint\\|dryPints\\|dryQuart\\|dryQuarts\\|peck\\|pecks\\|bushel\\|bushels\\|acre\\|imperialGallon\\|imperialQuart\\|imperialPint\\|imperialGill\\|imperialFluidOunce\\|imperialFluidDrachm\\|imperialFluidDRam\\|imperialFluidScruple\\|imperialMinim\\|pound\\|pounds\\|ounce\\|ounces\\|grain\\|grains\\|troyPound\\|troyPounds\\|troyOunce\\|troyOunces\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\TYP{\\2}\\3")
	;; Variables (any identifier followed by a } has already been processed)
	;;   Subscripted relational operators
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_LT\\($\\|\\>[^}_]\\)" "\\1\\2{}_{<}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_LE\\($\\|\\>[^}_]\\)" "\\1\\2{}_{\\\\leq}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_EQ\\($\\|\\>[^}_]\\)" "\\1\\2{}_{=}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_GE\\($\\|\\>[^}_]\\)" "\\1\\2{}_{\\\\geq}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_GT\\($\\|\\>[^}_]\\)" "\\1\\2{}_{>}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_NE\\($\\|\\>[^}_]\\)" "\\1\\2{}_{\\\\neq}\\3")
        ;;   Stars, splats, etc.
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_star\\($\\|\\>[^}_]\\)" "\\1\\2^*\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_plus\\($\\|\\>[^}_]\\)" "\\1\\2^+\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_minus\\($\\|\\>[^}_]\\)" "\\1\\2^-\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9_]*\\)\\>_splat\\($\\|\\>[^}_]\\)" "\\1\\2^{\\\\#}\\3")
	;;   Blackboard font
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Z]\\)\\2\\>\\($\\|[^}_]\\)" "\\1{}\\\\mathbb{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Z]\\)\\2\\([0-9]+\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\mathbb{\\2}\\3\\4")
	;;   Operators
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Z][A-Z]+\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\OPR{\\2}\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Z]+\\)_\\([A-Z]+\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\OPR{\\2{\\\\char'137}\\3}\\4")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Z]+\\)_\\([A-Z]+\\)_\\([A-Z]+\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\OPR{\\2{\\\\char'137}\\3{\\\\char'137}\\4}\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Z]+\\)_\\([A-Z]+\\)_\\([A-Z]+\\)_\\([A-Z]+\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\OPR{\\2{\\\\char'137}\\3{\\\\char'137}\\4{\\\\char'137}\\5}\\6")
	;;   Types
	("\\(^\\|[^{_\\\\]\\)\\(\\<[A-Z][A-Z0-9]*[a-z][A-Za-z0-9]*\\)\\([']*\\>\\)\\($\\|[^}_]\\)" "\\1{}\\\\TYP{\\2}\\3\\4")
	;;   Variables with _bar
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z]\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\bar{\\\\mathbf{\\2}}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z][A-Za-z]+\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overline{\\\\mathbf{\\2}}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z]\\)\\([0-9]+\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\bar{\\\\mathbf{\\2}}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z][A-Za-z]+\\)\\([0-9]+\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overline{\\\\mathbf{\\2}}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z]\\)_bar_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\bar{\\\\mathbf{\\2}}_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z][A-Za-z]+\\)_bar_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overline{\\\\mathbf{\\2}}_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z]\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\bar{\\\\VAR{\\2}}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)\\(\\\\GREEK{[A-Za-z0-9\\\\_]+}\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\bar{\\2}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z]+\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overline{\\\\VAR{\\2}}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z]\\)\\([0-9]+\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\bar{\\\\VAR{\\2}}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\(\\\\GREEK{[A-Za-z0-9\\\\_]+}\\)\\([0-9]+\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\bar{\\2}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z]+\\)\\([0-9]+\\)_bar\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overline{\\\\VAR{\\2}}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z]\\)_bar_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\bar{\\\\VAR{\\2}}_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\(\\\\GREEK{[A-Za-z0-9\\\\_]+}\\)_bar_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\bar{\\2}_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z]+\\)_bar_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overline{\\\\VAR{\\2}}_{\\\\mathrm{\\3}}\\4\\5")
	;;   Variables with _vec
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z]\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\vec{\\\\mathbf{\\2}}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z][A-Za-z]+\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overrightarrow{\\\\mathbf{\\2}}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z]\\)\\([0-9]+\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\vec{\\\\mathbf{\\2}}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z][A-Za-z]+\\)\\([0-9]+\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overrightarrow{\\\\mathbf{\\2}}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z]\\)_vec_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\vec{\\\\mathbf{\\2}}_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)_\\([A-Za-z][A-Za-z]+\\)_vec_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overrightarrow{\\\\mathbf{\\2}}_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z]\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\vec{\\\\VAR{\\2}}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)\\(\\\\GREEK{[A-Za-z0-9\\\\_]+}\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\vec{\\2}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z]+\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overrightarrow{\\\\VAR{\\2}}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z]\\)\\([0-9]+\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\vec{\\\\VAR{\\2}}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\(\\\\GREEK{[A-Za-z0-9\\\\_]+}\\)\\([0-9]+\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\vec{\\2}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z]+\\)\\([0-9]+\\)_vec\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overrightarrow{\\\\VAR{\\2}}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z]\\)_vec_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\vec{\\\\VAR{\\2}}_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\(\\\\GREEK{[A-Za-z0-9\\\\_]+}\\)_vec_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\vec{\\2}_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z]+\\)_vec_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\overrightarrow{\\\\VAR{\\2}}_{\\\\mathrm{\\3}}\\4\\5")
	;;   Other cases
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z]+\\)\\([0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{\\2}_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\(\\\\GREEK{[A-Za-z0-9\\\\_]+}\\)\\([0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1\\2_{\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z]\\)_\\([A-Za-z0-9]+\\)\\([']*\\)\\($\\|[^}_]\\)" "\\1{\\2}_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\(\\\\GREEK{[A-Za-z0-9\\\\_]+}\\)_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1\\2_{\\\\mathrm{\\3}}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9]+\\)_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)"
	 "\\1{}\\\\VAR{\\2{\\\\tt\\\\_}\\3}\\4\\5")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9]+\\)_\\([A-Za-z0-9]+\\)_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)"
	 "\\1{}\\\\VAR{\\2{\\\\tt\\\\_}\\3{\\\\tt\\\\_}\\4}\\5\\6")
	("\\(^\\|[^{_\\\\]\\)\\<\\([A-Za-z][A-Za-z0-9]+\\)_\\([A-Za-z0-9]+\\)_\\([A-Za-z0-9]+\\)_\\([A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)"
	 "\\1{}\\\\VAR{\\2{\\\\tt\\\\_}\\3{\\\\tt\\\\_}\\4{\\\\tt\\\\_}\\5}\\6\\7")
	("\\(^\\|[^{_\\\\]\\)\\<\\(\\<[A-Za-z]+\\>\\)_\\($\\|[^}_]\\)" "\\1{}\\\\mathrm{\\2}\\3")
	;;   Trailing underscore quietly disappears after a Greek letter
	("\\(^\\|[^{_\\\\]\\)\\(\\\\GREEK{[A-Za-z0-9\\\\_]+}\\)_\\($\\|[^{}_A-Za-z0-9]\\)" "\\1\\2\\3")
	("\\(^\\|[^{_\\\\]\\)\\<\\(\\<[A-Za-z]\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{\\2}\\3\\4")
	("\\(^\\|[^{_\\\\]\\)\\<\\(\\<[A-Za-z][A-Za-z0-9]+\\)\\([']*\\)\\>\\($\\|[^}_]\\)" "\\1{}\\\\VAR{\\2}\\3\\4")
	;;   Plain boldface variables (must come after "other cases")
	("\\(^\\|[^{A-Za-z0-9_\\\\]\\)_\\([A-Za-z]+\\)\\([']*\\)\\($\\|[^}_]\\)" "\\1{}\\\\mathbf{\\2}\\3\\4")
	("\\(^\\|[^{A-Za-z0-9_\\\\]\\)_\\([A-Za-z]+\\)\\([0-9]+\\)\\([']*\\)\\($\\|[^}_]\\)" "\\1{}\\\\mathbf{\\2}_{\\3}\\4\\5")
	("\\(^\\|[^{A-Za-z0-9_\\\\]\\)_\\([A-Za-z]+\\)_\\([A-Za-z0-9]+\\)\\([']*\\)\\($\\|[^}_]\\)" "\\1{}\\\\mathbf{\\2}_{\\\\mathrm{\\3}}\\4\\5")
        ;;   Doubled underscores, leading and internal/trailing (only handle 1 pair)
        ("\\(^\\|[^{A-Za-z0-9_\\\\]\\)__\\([A-Za-z][A-Za-z0-9]*[']*\\)\\($\\|[^}_]\\)" "\\1\\\\VAR{{\\\\tt\\\\_\\\\_}\\2}\\3")
        ("\\(^\\|[^{A-Za-z0-9_\\\\]\\)\\([A-Za-z][A-Za-z0-9]*\\)__\\([A-Za-z0-9]*[']*\\)\\($\\|[^}_]\\)" "\\1\\\\VAR{\\2{\\\\tt\\\\_\\\\_}\\3}\\4")
	;; Figuring out left, right, and infix | and ||
	("\\(^\\| \\|\t\\|(\\|\\[\\|\\[\\\\\\|<\\\\\\|<<\\\\\\|,\\|;\\)||\\([^ \t\n]\\)" "\\1{}\\\\left\\\\|\\2")
	("\\(^\\| \\|\t\\|(\\|\\[\\|\\[\\\\\\|<\\\\\\|<<\\\\\\|,\\|;\\)|\\([^ \t\n|]\\)" "\\1{}\\\\left\\2")
	("\\([^ \t\n]\\)||\\($\\| \\|\t\\|)\\|\\]\\|\\\\\\]\\|\\\\>\\|\\\\>>\\|,\\|;\\)" "\\1{}\\\\right\\\\|\\2")
	("\\([^ \t\n\\\\|]\\)|\\($\\| \\|\t\\|)\\|\\]\\|\\\\\\]\\|\\\\>\\|\\\\>>\\|,\\|;\\)" "\\1{}\\\\right|\\2")
	("" "|")
	(" || " "{}\\\\,\\\\|\\\\,")
	("||" "{}\\\\|")
	(" | " " \\\\mid ")
	;; ******* Here is a major divide.
	;; ** Before this point, a replacement string beginning with \\\\ generally has {} in front of it,
	;; ** and a replacement string beginning with \\1\\\\ is really \\1{}\\\\ .  Not so after this point.
	;; Delete redundant {} delimiters
	;; Need two (or more?) of this first one.
	("{}\\([^A-Za-z0-9{]\\)" "\\1")
	("{}\\([^A-Za-z0-9{]\\)" "\\1")
	("\\(\\llbracket\\){}\\([A-Za-z]\\)" "\\1 \\2")
	("\\(\\^\\|{\\){}" "\\1")
	;; ******* "Fixups" come after this
	;; Fixup for consecutive numbers separated by whitespace (ugh, bletch)
	("\\([0-9]\\)[ ]+\\([0-9]\\)" "\\1{}\\\\;\\2")
	;; Fixup for consecutive keywords (two copies in case there are three or more consecutive keywords)
	("\\(\\\\KWD{[A-Za-z\\\\_]+}\\)[ ]*\\(\\\\KWD{[A-Za-z\\\\_]+}\\)" "\\1\\\\;\\\\;\\2")
	("\\(\\\\KWD{[A-Za-z\\\\_]+}\\)[ ]*\\(\\\\KWD{[A-Za-z\\\\_]+}\\)" "\\1\\\\;\\\\;\\2")
	;; Fixup for \rightarrow or \Rightarrow followed by keyword
	("\\(\\\\[rR]ightarrow\\)[ ]*\\(\\\\KWD{[A-Za-z\\\\_]+}\\)" "\\1\\\\;\\2")
	;; Fixup for consecutive \VAR or \\TYP or \mathbb or \mathit or \mathbf or \mathrm or \GREEK items (two copies in case there are three or more consecutive items)
	("\\(\\(\\\\VAR\\|\\\\TYP\\|\\\\mathbb\\|\\\\mathit\\|\\\\mathbf\\|\\\\mathrm\\|\\\\GREEK\\){[A-Za-z0-9\\\\_]+}\\)[ ]*\\(\\(\\\\VAR\\|\\\\TYP\\|\\\\mathbb\\|\\\\mathit\\|\\\\mathbf\\|\\\\mathrm\\|\\\\GREEK\\){[A-Za-z0-9\\\\_]+}\\|{[A-Za-z]}\\)"
	 "\\1\\\\:\\3")
	("\\(\\(\\\\VAR\\|\\\\TYP\\|\\\\mathbb\\|\\\\mathit\\|\\\\mathbf\\|\\\\mathrm\\|\\\\GREEK\\){[A-Za-z0-9\\\\_]+}\\)[ ]*\\(\\(\\\\VAR\\|\\\\TYP\\|\\\\mathbb\\|\\\\mathit\\|\\\\mathbf\\|\\\\mathrm\\|\\\\GREEK\\){[A-Za-z0-9\\\\_]+}\\|{[A-Za-z]}\\)"
	 "\\1\\\\:\\3")
	;; Fixup for right encloser then space then \VAR or \\TYP or \mathbb or \mathit or \mathbf or \mathrm or \GREEK item
	("\\([])}]\\)[ ]+\\(\\(\\\\VAR\\|\\\\TYP\\|\\\\mathbb\\|\\\\mathit\\|\\\\mathbf\\|\\\\mathrm\\|\\\\GREEK\\){[A-Za-z0-9\\\\_]+}\\|{[A-Za-z]}\\)"
	 "\\1\\\\:\\2")
	;; Fixup for decimal literal followed by \VAR or \TYP or \mathbb or \mathtt or \mathit or \mathrm
	("\\([0-9][.]?\\)[ ]*\\(\\\\\\(VAR\\|TYP\\|mathbb\\|mathtt\\|mathit\\|mathrm\\){\\)" "\\1\\\\,\\2")
	;; Fixup for unary \OPR{...} followed by \mathit or \mathbf or \VAR
	("\\([([{=][ ]*\\\\OPR{[A-Za-z0-9\\\\_]+}\\)[ ]*\\(\\(\\\\mathit\\|\\\\MATHBF\\|\\\\VAR\\){[A-Za-z0-9\\\\_]+}\\|{[A-Za-z]}\\)"
	 "\\1\\\\:\\2")
	;; Fixup for unary \mathbin{\TYP{...}} followed by \TYP{...} or \mathrm{...}
	("\\([([{=][ ]*\\\\mathbin{\\\\TYP{[A-Za-z0-9\\\\_]+}}\\)[ ]*\\(\\\\\\(TYP\\|mathrm\\){[A-Za-z0-9\\\\_]+}\\|{[A-Za-z]}\\)"
	 "\\1\\\\:\\2")
	;; Fixup for two consecutive occurrences of \mathbin{\TYP{...}} followed by \TYP or \mathrm
	("\\(\\\\mathbin{\\\\TYP{[A-Za-z0-9\\\\_]+}}[ ]*\\\\mathbin{\\\\TYP{[A-Za-z0-9\\\\_]+}}\\)[ ]*\\(\\\\\\(TYP\\|mathrm\\){[A-Za-z0-9\\\\_]+}\\|{[A-Za-z]}\\)"
	 "\\1\\\\:\\2")
	;; Fixup for "opr" followed by an operator
	("\\(\\\\KWD{opr}[ ]*\\)\\(\\\\OPR{[A-Za-z0-9\\\\_]*}\\|\\\\not\\\\[A-Za-z]+\\>\\|\\\\[A-Za-z]+\\>\\|[=<>:]\\)" "\\1\\\\mathord{\\2}")
	;; Counter-fixups for previous one when "operator" was \VAR or \left or something
	("\\(\\\\KWD{opr}[ ]*\\)\\\\mathord{\\(\\\\left\\)}" "\\1\\2")
	("\\(\\\\KWD{opr}[ ]*\\)\\\\mathord{\\(\\\\lfloor\\)}" "\\1\\2")
	("\\(\\\\KWD{opr}[ ]*\\)\\\\mathord{\\(\\\\lceil\\)}" "\\1\\2")
	("\\(\\\\KWD{opr}[ ]*\\)\\\\mathord{\\(\\\\lhfloor\\)}" "\\1\\2")
	("\\(\\\\KWD{opr}[ ]*\\)\\\\mathord{\\(\\\\lhceil\\)}" "\\1\\2")
	("\\(\\\\KWD{opr}[ ]*\\)\\\\mathord{\\(\\\\lhhfloor\\)}" "\\1\\2")
	("\\(\\\\KWD{opr}[ ]*\\)\\\\mathord{\\(\\\\lhhceil\\)}" "\\1\\2")
	("\\(\\\\KWD{opr}[ ]*\\)\\\\mathord{\\(\\\\llbracket\\)}" "\\1\\2")
	("\\(\\\\KWD{opr}[ ]*\\)\\\\mathord{\\(\\\\[A-Za-z]+\\)}\\({[^}]\\)" "\\1\\2\\3")
	;; Fixup for "self" where it's in an innocuous place
	("\\([(,][ ]*\\)\\\\mathord{\\\\KWD{self}}\\([ ]*[,)]\\)" "\\1\\\\KWD{self}\\2")
	;; Fixup for "=" followed by a keyword
	("\\(=[ ]*\\)\\(\\\\KWD{[A-Za-z\\\\_]*}\\)" "\\1\\\\;\\2")
	;; Fixup for operator followed by "="
	("\\(\\\\[A-Za-z]+{}\\|[-!@#$%*+?]\\)=" "\\\\mathrel{\\1}=")
	;; Fixups for operator followed by subscript
	("\\\\OPR{BIG}[ ]*\\(\\\\OPR{[A-Z_]+}\\)\\\\limits_" "\\\\mathop{\\1}\\\\limits_")
	("\\(\\\\OPR{[A-Z_]+}\\)\\\\limits_" "\\\\mathop{\\1}\\\\limits_")
	;; Fixups for operator symbol followed by subscript
	("\\\\OPR{BIG}[ ]*\\(\\\\[a-z]+\\)\\({}\\)*\\\\limits_" "\\\\mathop{\\1}\\\\limits_")
	("\\(\\\\[a-z]+\\)\\({}\\)*\\\\limits_" "\\\\mathop{\\1}\\\\limits_")
	("\\\\mathop{\\\\sum}" "\\\\sum")
	("\\\\mathop{\\\\prod}" "\\\\prod")
	("\\\\mathop{\\\\wedge}" "\\\\bigwedge")
	("\\\\mathop{\\\\vee}" "\\\\bigvee")
	("\\\\mathop{\\\\cap}" "\\\\bigcap")
	("\\\\mathop{\\\\cup}" "\\\\bigcup")
	("\\\\mathop{\\\\odot}" "\\\\bigodot")
	("\\\\mathop{\\\\otimes}" "\\\\bigotimes")
	("\\\\mathop{\\\\oplus}" "\\\\bigoplus")
	("\\\\mathop{\\\\uplus}" "\\\\biguplus")
	;; Fixup for defining opr |self|
	("\\\\KWD{opr} \\\\left|\\\\mathord{\\\\KWD{self}}|" "\\\\KWD{opr} \\\\left|\\\\mathord{\\\\KWD{self}}\\\\right|")
	;; Fixup for defining opr BIG |||(
	("\\\\KWD{opr} \\\\mathord{\\\\OPR{BIG}} \\\\left\\\\\\\\|(" "\\\\KWD{opr} \\\\OPR{BIG} \\\\left||\\\\right|(")
	;; Fixup for defining opr BIG ||(
	("\\\\KWD{opr} \\\\mathord{\\\\OPR{BIG}} \\\\left\\\\|(" "\\\\KWD{opr} \\\\OPR{BIG} \\\\left|\\\\right|(")
	;; Fixup for using BIG |||
	("\\\\OPR{BIG} \\\\left\\\\\\\\|" "\\\\OPR{BIG} \\\\left||\\\\right|")
	;; Fixup for using BIG |||
	("\\\\OPR{BIG} \\\\left\\\\\\\\right\\\\|" "\\\\OPR{BIG} \\\\left||\\\\right|")
	;; Fixup for using BIG ||
	("\\\\OPR{BIG} \\\\left\\\\|" "\\\\OPR{BIG} \\\\left|\\\\right|")
	;; Fixup for defining opr |||(
	("\\\\KWD{opr} \\\\left\\\\\\\\|(" "\\\\KWD{opr} \\\\left||\\\\right|(")
	;; Fixup for defining opr ||(
	("\\\\KWD{opr} \\\\left\\\\|(" "\\\\KWD{opr} \\\\left|\\\\right|(")
	;; Fixup for defining opr :
	("\\\\KWD{opr} \\\\mathrel{\\\\mathtt{:}}" "\\\\KWD{opr} \\\\mathinner{\\\\mathtt{:}}")
        ;; Fixup for missing space in BIG OP
        ("\\\\OPR{BIG}[ ]*\\\\" "\\\\OPR{BIG}\\\\,\\\\")
	;; Fixup for |self|
	("\\\\left|\\\\mathord{\\\\KWD{self}}\\\\lfloor)" "\\\\left|\\\\mathord{\\\\KWD{self}}\\\\right|}")
	;; Fixup for ||
	("\\\\lhfloor)" "\\\\left|\\\\right|}")
	;; Fixup for |||
	("\\\\lhhfloor)" "\\\\left||\\\\right|}")
	;; Fixup for defining opr ^(self, other)
	("\\\\KWD{opr} \\^(" "\\\\KWD{opr} \\\\mathord{\\\\hbox{\\\\tt\\\\char'136}}(")
	;; # operator
	(" # " " \\\\mathrel{\\\\hbox{\\\\tt\\\\char'43}} ")
	("\\([^@\\]\\)#\\([^@]\\)" "\\1\\\\mathinner{\\\\hbox{\\\\tt\\\\char'43}}\\2")
	;; Get rid of \GREEK
	("\\\\GREEK{o}" "{o}")
	("\\\\GREEK{\\([ABEHIKMNOPTXZ]\\)}" "\\\\mathrm{\\1}")
	("\\\\GREEK{\\([A-Za-z0-9\\\\_]*\\)}" "\\1{}")
	;; Make single-letter variables look good by deleting redundant braces
	("\\([^A-Za-z0-9]\\){\\([A-Za-z]\\)}\\([^A-Za-z0-9]\\)" "\\1\\2\\3")
	;; Surround lines with \( and \) \\
	("\n" "\\\\)\\\\\\\\\n\\\\(")
	;; Move \( to after leading tildes
	("^\\\\(\\({\\\\tt~*}\\)" "\\1\\\\(")
	;; Delete empty \(\) pairs
	("\\\\([ ]*\\\\)" "")
	;; Move poptabs to correct position (may need to add a \\)
	("\\\\-\\(\\(\\\\poptabs\\)+\\)\\($\\|\\\\\\\\\\)" "\\\\-\\\\\\\\\\1")
	;; Make blank lines pretty
	("\\\\\\\\\\(\\(\\\\poptabs\\)*\\)\n\\(\\(\\\\-\\)*\\)\\\\\\\\" "\\3\\\\\\\\[4pt]\\1")
	;; Delete extraneous spaces within braces
	("{ " "{")
	(" }" "}")
	))

(setq fortify-final-fixups
      '(
	;; Fixups for space before and after strings
	(" \\\\hbox{\\\\rm``" "\\\\;\\\\;\\\\hbox{\\\\rm``")
	("}''} " "}''}\\\\;\\\\;")
	;; Make single keywords look good
	("\\\\EXP{\\\\KWD{\\([^}]*\\)}}" "\\\\KWD{\\1}")
	;; Make single operators look good
	("\\\\EXP{\\\\OPR{\\(\\([A-Za-z0-9\\\\]\\|{\\\\char'137}\\)*\\)}}" "\\\\OPR{\\1}")
	;; Make single variables look good
	("\\\\EXP{\\\\VAR{\\([^}]*\\)}}" "\\\\VAR{\\1}")
	;; Make single types look good
	("\\\\EXP{\\\\TYP{\\([^}]*\\)}}" "\\\\TYP{\\1}")
	("\\\\EXP{\\\\mathbin{\\\\TYP{\\([^}]*\\)}}}" "\\\\TYP{\\1}")
	;; Make single variables look good
	("\\\\EXP{\\\\mathit{\\([^}]*\\)}}" "\\\\VAR{\\1}")
	("\\\\EXP{\\([A-Za-z]\\)}" "\\\\VAR{\\1}")
	))


;;; --------------- Shared stuff from the old fortify.el (could use a once-over)

;;; We assume these TeX macro definitions:
;;; \def\Method#1{...}

(defun method-fortify (prefix-arg)
  "Format the region as Fortress method definition headers.
The region is assumed to be a sequence of method declarations.
Each method declaration may span one or more lines of text.
Any line whose indentation matches that of the first line
is assumed to start a new method declaration.  Each method
declaration is formatted as Fortress code and becomes the
argument of the TeX macro \\Method (but \\Method* is used
for each declaration other than the first, except that a
blank line means that the next method uses \\Method again).
If the first character in the region is %, then the region
is first copied, and within the copy all lines have any
initial % character removed before the text is formatted,
but if the first two characters in the region are %%, then
C-U M-X comment-region is called instead, to do a cleverer job
of removing the comment characters; thus the net result is
that the original region precedes the formatted code.
In this way, Fortress code can be kept within a TeX source file
as a comment and easily altered and reformatted as necessary."
  (interactive "*p")
  (if (not (mark)) (keyboard-quit))
  (let* ((case-fold-search nil)
	 (old-point (copy-marker (point)))
	 (old-mark (copy-marker (mark)))
	 (overall-end (copy-marker (region-end)))
	 (overall-start (copy-marker (region-beginning)))
	 (chunk-start (make-marker))
	 (start (make-marker))
	 (end (make-marker)))
    (goto-char (marker-position overall-end))
    (while (> (point) (marker-position overall-start))
      ;; Find a nonblank line
      (while (and (> (point) (marker-position overall-start))
		  (or (= (point) (+ 1 (marker-position overall-start)))
		      (= (char-before (- (point) 1)) ?\n)))
	(forward-line -1))
      (set-marker end (point))
      ;; Find a blank line or overall start
      (while (and (> (point) (+ 1 (marker-position overall-start)))
		  (not (= (char-before (- (point) 1)) ?\n)))
	(forward-line -1))
      (set-marker chunk-start (point))
      (set-marker start (point))
      (cond ((and (< start end) (= (char-after (- (marker-position end) 1)) ?\n))
	     (set-marker end (- (marker-position end) 1))))
      (untabify start end)
      (cond ((and (= (char-after (marker-position start)) ?\%)
		  (or (null (char-before (marker-position start)))
		      (= (char-before (marker-position start)) ?\n)))
	     ;; Make a copy
	     (let ((region-data (buffer-substring (marker-position start) (marker-position end))))
	       (goto-char (marker-position end))
	       (insert "\n")
	       (set-marker start (point))
	       (insert region-data)
	       (set-marker end (point))
	       (goto-char (marker-position start))
	       (cond ((looking-at "%%") (comment-region (marker-position start) (marker-position end) '(4)))
		     (t (delete-char 1)
			;; Remove leading % from each line
			(process-fortify-rules '(("\n%" "\n")) (marker-position start) (marker-position end)))))))
      (let ((method-indent (current-indentation))
	    (first-method t))
	(goto-char (marker-position start))
	(while (< (point) (marker-position end))
	  (cond ((= (current-indentation) method-indent)
		 (delete-char (current-indentation))
		 (if first-method (insert "\\Method{") (insert "\\Method*{"))
		 (setq first-method nil)
		 (set-mark (point))
		 (end-of-line)
		 (newfortify 4)
		 (insert "}")
		 (forward-line))
		(t (backward-char)
		   (delete-char -1)
		   (insert "\\\\")
		   (forward-char)
		   (delete-char (min (current-indentation) method-indent))
		   (insert "\\hbox{\\tt")
		   (while (= (char-after (point)) ?\ )
		     (delete-char 1)
		     (insert "~"))
		   (insert "}")
		   (set-mark (point))
		   (end-of-line)
		   (newfortify 4)
		   (insert "}")
		   (forward-line)))))
      (goto-char (marker-position chunk-start)))
    (set-marker chunk-start nil)
    (set-marker start nil)
    (set-marker end nil)
    (set-marker overall-start nil)
    (set-marker overall-end nil)
    (set-mark (marker-position old-mark))
    (set-marker old-mark nil)
    (let ((old-point-position (marker-position old-point)))
      (set-marker old-point nil)
      (goto-char old-point-position))))


(defun batch-fortify ()
    "Fortify the whole buffer and write to a filename in pwd, with
extension .tex."
    (remove-copyright)
    (print-header "TOOL BATCH-FORTIFY")
    (mark-whole-buffer)
    (newfortify 4)
    (write-as-tex-file))

(defun fortick ()
  "Fortify all sections of a buffer delimited with backticks, and
write to a file in the same location as the read file, but with
extension '.tex'."
  (goto-char (point-min))
  (remove-copyright)
  (print-header "TOOL FORTICK")
  (do ((after-next-opening (search-forward "`" nil t) (search-forward "`" nil t)))
      ((null after-next-opening))
    (while (equal (char-after (point)) ?\`)
      (forward-char))
    (let* ((next-opening (- after-next-opening 1))
	   (len (- (point) next-opening))
	   (leading-newline (equal (char-after (point)) ?\n)))
      (cond ((oddp len)
	     ;; An odd number of ticks begins Fortress code to be rendered;
	     ;; the end is marked by an equal number of ticks.
	     (let* ((close-str (make-string len ?\`))
		    (after-matching-close (search-forward close-str nil t)))
	       (cond ((or (null after-matching-close) (equal (char-after (point)) ?\`))
		      (goto-char (+ next-opening len))
		      (signal-error (concat "Mismatched tick(s) " close-str)))
		     (t (let ((rendered-code (newfortify-region (+ next-opening len (if leading-newline 1 0))
								(- after-matching-close len))))
			  (delete-region next-opening after-matching-close)
			  (goto-char next-opening)
			  (insert rendered-code)
			  (when (and (equal (char-before (point)) ?\n)
				     (equal (char-after (point)) ?\n))
			    (delete-char -1)))))))
	    (t 
	     ;; An even number of ticks gets cut in half
	     (delete-char (- (/ len 2)))))))
	     (write-as-tex-file)
	     )

(defun fortify-region (left right)
  (save-excursion
    (goto-char left)
    (push-mark (point) t)
    (goto-char right)
    (fortify-if-not-blank-space)))

(defun fortex ()
  "Fortify the whole buffer except for stylized documentation
  comments, delimited by (** and *) as the first non-whitespace
  characters on the first and last line.  Extra asterisks in the
  opening and closing comments are permitted.  Whitespace and *
  are stripped from the start of each line of a documentation
  comment.  If any line except the closing line begins with %
  after stripping * and whitespace, fortify it (exception: %% are
  passed through).  Write the result to a file in the same
  location as the read file, but with extension .tex. Using this
  function, it is possible to write a legal Fortress file with
  doc comments (possibly containing embedded LaTeX commands) and
  produce a LaTeX file where all Fortress code is fortified and
  all doc comments are written as LaTeX prose describing the
  code."
  (interactive)
  (let ((case-fold-search t)
        (more-lines t))
    (remove-copyright)
    (goto-start-of-buffer)
    (print-header "TOOL FORTEX")
    (insert "\\FortexSettings\n")
    (while more-lines
      (cond ((at-start-of-doc-comment)
             (remove-doc-comment-chars)
             (setq more-lines (down-left-if-more-lines)))
            ((looking-at "^[ \t]*$")
             (setq more-lines (down-left-if-more-lines)))
            ((at-start-of-tests)
             (setq more-lines (omit-tests)))
            (t (setq more-lines (fortify-next-code-block))))))
  (write-as-tex-file))

(defun foreg ()
  "Fortify the region of the buffer delimited by special doc comments
  '(** EXAMPLE **)' and '(** END EXAMPLE **)'. Remove all other text,
  and save the result to a file at the same location as the read file,
  but with extension .tex."
  (remove-copyright)
  (print-header "TOOL FOREG")
  (let ((more-lines t))
    (goto-start-of-buffer)
    (while more-lines
      (if (at-start-of-example)
	  (setq more-lines (fortify-example))
	(setq more-lines (delete-line))))
  (write-as-tex-file)))

(defun remove-doc-comment-chars ()
  "Removes beginning comment characters of the contiguous doc comment
  starting at point. Once finished, point is at the very end of the
  processed doc comment."
  (interactive)
  (goto-char
   (save-excursion
     (let ((start (point)))
       (requires (looking-at "^\\( *\\)(\\*\\*+[ \t]*[\n]?"))
       (replace-match "\\\\begin{FortressDoc}{\\1}\n" t)  ; Strip opening delimiter
       (let ((end (point)))
         (while (search-backward " " start t)
           (replace-match "~" t))
         (goto-char end)))
     (remove-doc-comment-middle-lines)
     (beginning-of-line)
     (cond
      ((looking-at "^[ \t]*[*]+)[ \t]*$")  ; Just a terminator, kill the line.
       (replace-match "\\\\end{FortressDoc}" t))
      ((looking-at "^\\(.*?\\)[ \t]*[*]+)[ \t]*$")
       (replace-match "\\1\n\\\\end{FortressDoc}" t))
      (t
       (signal-error "Unterminated documentation comment")))
     (point))))

(defun remove-doc-comment-middle-lines ()
  "Iterate thru interior lines of doc comment, stripping junk & fortifying if needed"
  (let ((fortification-mark nil)
        (still-removing     t))
    (while still-removing
      (looking-at "^[ \t]*\\(\\*+\\([ \t]+\\|$\\|\\([^*)]\\)\\)\\)?")
      (replace-match "\\3" t)
      (beginning-of-line)
      ;; Handle block fortification (initial %)
      (cond
       ((looking-at "^%[^%]*?$")
        (if (not fortification-mark)
            (setq fortification-mark (copy-marker (point)))))
       (fortification-mark
        (fortify-region (marker-position fortification-mark) (point))
        (setq fortification-mark nil)))
      ;; Fortify intra-line %-delimited Fortress expressions
      (while (looking-at "\\([^%\n]*\\)%\\([^%\n]+\\)%\\([^\n]*\\)$")
        (replace-match "\\1%\\2\n\\2\n\\3" t)
        ;; Point now after replacement.
        (forward-line -1)
        (beginning-of-line)
        (push-mark (point) t)
        (end-of-line)
        (delete-char 1)
        (newfortify 4))
      (setq still-removing (and (not (looking-at ".*\\*)")) (down-left-if-more-lines))))))

(defun fortify-next-code-block ()
  "Finds and fortifies the contiguous block of Fortress code start at
  point and ending at the next doc comment (or the end of the
  file). Once finished, point is at the very end of the block of
  code."
  (interactive)
  (requires (not (at-start-of-doc-comment)))
  (let ((more-lines t))
    (push-mark (point) t)
    (while (and more-lines
		(not (or (at-start-of-doc-comment)
			 (at-start-of-tests))))
      (setq more-lines (down-left-if-more-lines)))
    (unless more-lines (end-of-line))
    (fortify-if-not-blank-space)
    more-lines))

(defun fortify-if-not-blank-space ()
  "Checks that the region isn't empty before calling fortify."
  (if (not (all-blank-spacep (region-beginning) (region-end)))
      (fortify 4)))

(defun fortify-example ()
  "Fortifies example code delimited by special doc comments
  '(** EXAMPLE **)' and '(** END EXAMPLE **)'."
  (requires (at-start-of-example))

  (delete-line)
  (push-mark (point) t)
  (let ((more-lines t))
    (while (and more-lines (not (at-end-of-example)))
      (setq more-lines (down-left-if-more-lines)))
    (if (at-end-of-example)
	(progn (fortify-if-not-blank-space)
	       (delete-line))
      (signal-error "Example must be terminated with '(* END EXAMPLE *)'."))))

(defun at-start-of-marked-copyright () (at-line "(** COPYRIGHT **)"))
(defun at-end-of-marked-copyright () (at-line "(** END COPYRIGHT **)"))

(defun at-start-of-example () (at-line "(** EXAMPLE **)"))
(defun at-end-of-example () (at-line "(** END EXAMPLE **)"))

(defun at-start-of-tests () (at-line "(** TESTS **)"))
(defun at-end-of-tests () (at-line "(** END TESTS **)"))

(defun remove-block (test-for-start test-for-end error-string)
  "Removes everything up to the line designated by `test-for-end`.
If that line isn't found, signal the error message `error-string`.
This function should only be called at a position where `test-for-start`
is true."
  (requires (funcall test-for-start))

  (let ((not-at-eof t))
    (while (and not-at-eof
		(not (funcall test-for-end)))
      (setq not-at-eof (delete-line)))
    (if (funcall test-for-end)
	(delete-line)
      (signal-error error-string))))

(defun remove-copyright ()
  (if (at-start-of-marked-copyright)
    (remove-block 'at-start-of-marked-copyright 'at-end-of-marked-copyright
                  (concat "Marked copyright notice must be terminated with"
                          "'(** END COPYRIGHT **)'."))
    (remove-block-copyright)))

(defun omit-tests ()
  (remove-block 'at-start-of-tests 'at-end-of-tests
		"Tests must be terminated with '(** END TESTS **)'"))

(defun at-line (line)
    "Boolean function that determines whether point is at the
beginning of an example, delimited by the doc comment '(** EXAMPLE **)'."
    (save-excursion
      (beginning-of-line)
      (skip-leading-whitespace)
      (let ((left (point)))
	(end-of-line)
	(skip-preceding-whitespace)
	(let* ((right (point))
	       (candidate (buffer-substring left right)))
	  (equal candidate line)))))

(defvar block-copyright-regexp
    "(\\*+[\n\t ]+Copyright[^*]*\\*+)[ \n\t]*"
    "regexp for recognizing block copyright notice.")

(defun remove-block-copyright ()
    "Attempt to remove a block copyright notice if one exists."
    (save-excursion
      (if (re-search-forward block-copyright-regexp nil t)
        (replace-match "" t))))

(defun at-start-of-doc-comment ()
  "Boolean function that determines whether point is at the beginning of a
doc comment."
  (looking-at "^ *(\\*\\*"))

(defun delete-whitespace ()
  "Simple helper function that deletes all whitespace immediately following
point."
  (while (and (char-after (point))
	      (whitespacep (char-to-string (char-after (point)))))
    (delete-char 1)))

(defun skip-leading-whitespace ()
  "Simple helper function that moves point to the next non-whitespace
character."
  (while (and (char-after (point))
	      (whitespacep (char-to-string (char-after (point)))))
    (forward-char)))

(defun skip-preceding-whitespace ()
  "Simple helper function that moves point to the previous non-whitespace
character."
  (while (and (char-before (point))
	      (whitespacep (char-to-string (char-before (point)))))
    (backward-char)))


(defun whitespacep (string)
  (or (equal string " ")
      (equal string "\t")))

(defun blank-spacep (string)
  (or (whitespacep string)
      (equal string "\n")
      (equal string "\f")
      (equal string "\r")))

(defun all-blank-spacep (left right)
  (let ((result t))
    (while (< left right)
      (setq result (and result
			(blank-spacep (char-to-string (char-after left)))))
      (setq left (1+ left)))
    result))

(defun delete-line ()
  "Delete the current line and, if successful, return t. If current
  line is the last line in the buffer (i.e., there is no newline
  character at the end of it), delete its contents and return nil."
  (beginning-of-line)
    (let ((left (point)))
      (end-of-line)
      (let ((right (point)))
	(if (char-after right)
	    ;; Delete the newline character immediately to the right
	    ;; of the line.
	    (progn (delete-region left (1+ right))
		   t)
	  (progn (delete-region left right)
		 nil)))))

(defun down-left-if-more-lines ()
  "If there is a next line after point, moves point to the beginning of the
next line and returns true. Returns false otherwise."
  (interactive)
  (let ((last-line nil))
    (save-excursion
      (end-of-line)
      (setq not-last-line (not (equal (point) (point-max)))))
    (if not-last-line
	(progn (forward-line 1)
	       (beginning-of-line)))
    not-last-line))

(defun goto-start-of-buffer ()
  "Simple helper function that moves point to the start of the buffer."
  (goto-char (point-min)))

(defun write-as-tex-file ()
  "Writes the current buffer to a new file with the same name and location,
but with suffix '.tex'."
  (write-file (concat
	       (file-name-sans-extension
		(file-name-nondirectory (buffer-file-name)))
	       ".tex")))

;; This isn't working yet
(defun print-header (author)
;;  (insert (concat "%% THIS FILE WAS AUTOGENERATED BY " author
;;		 " AT FORTRESS_HOME/Fortify/fortify.el"))
;;  (newline)
;;  (insert (concat "%% FROM SOURCE FILE" (buffer-file-name) "\n"))
;;  (newline)
;;  (forward-line))
)

(defun requires (condition)
  "Takes a condition and signals an error if the condition is false.
Intended to be used at the beginning of a function definition,
as a poor man's contract facility."
  (if (not condition)
      (signal-error "Precondition violated")))

(defun signal-error (msg)
  "Signals an error, indicating the file name of the current buffer,
the line position of point, and the given message."
  (error (concat (buffer-file-name) ": " msg)))
